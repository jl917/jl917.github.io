---
url: /hello/index.md
---

# Hello

:::giphy
xTiTngMMCIt7FramOc
:::


---
url: /hello/portfolio.md
---

# Portfolio

## Library

#### JECO

별도의 셋팅이 필요없는 React 개발 환경을 만들어 보고 싶어서 도전했던 프로젝트

- npm: https://www.npmjs.com/package/jeco
- github: https://github.com/jl917/jeco

#### JNPKG

NPM 패키지를 편하게 만들기 위해서 만들었던 좋은 도구이고 semantic-release가 포함되어서 초기 관리가 굉장히 편리

- npm: https://www.npmjs.com/package/jnpkg
- github: https://github.com/jl917/jnpkg

#### JBIN

NODE 기반 CLI를 누구나 만들수 있도록 도와주는 빌드도구

- npm: https://www.npmjs.com/package/@julong/jbin
- github: https://github.com/jl917/jbin

#### CHECKER

프로젝트 품질향상을 위한 도구로 eslint, stylelint, markdownlint, htmlhint를 포함

- npm: https://www.npmjs.com/package/@julong/checker
- github: https://github.com/jl917/checker

#### ESlint Watch

ESLint를 번들러에 포함시키지 않고 별도로 비동기처리 함으로써 개발환경을 개선하고자 만들었던 프로젝트

- npm: https://www.npmjs.com/package/@julong/eslint-watch
- github: https://github.com/jl917/eslintWatch

#### micro-frontend-utils

마이크로 프론트엔드 구축할때 React 또는 Vue의 mount, unmount를 도와주는 유틸

- npm: https://www.npmjs.com/package/@julong/micro-frontend-utils
- github: https://github.com/jl917/micro-frontend-utils

## Plugin

#### babel-plugin-add-optional-chaining

일부환경에 필요한 기능으로서 옵셔널 체이닝을 자동으로 추가해서 TypeError 오류를 발생 최소화

- npm: https://www.npmjs.com/package/babel-plugin-add-optional-chaining
- github: https://github.com/jl917/babel-plugin-add-optional-chaining

#### rspress-plugin-sitemap

SEO 검색엔진에 필요한 사이트맵 자동생성 플러그인

- npm: https://www.npmjs.com/package/rspress-plugin-sitemap
- github: https://github.com/jl917/rspress-plugin-sitemap

#### rspress-plugin-clarity

Microsoft Clarity 연동을 위한 플러그인

- npm: https://www.npmjs.com/package/rspress-plugin-clarity
- github: https://github.com/jl917/rspress-plugin-clarity

#### vite-plugin-jsx-remove-attrs

vite 개발환경에서 빌드시 불필요한 속성을 제거해주는 플러그인

- npm: https://www.npmjs.com/package/@julong/vite-plugin-jsx-remove-attrs
- github: https://github.com/jl917/vite-plugin-jsx-remove-attrs

#### webpack-plugin-runtime-assets

마이크로 프론트엔드 개발시 runtime에 꼭 필요한 js파일만 가져오는 플러그인

- npm: https://www.npmjs.com/package/@julong/webpack-plugin-runtime-assets
- github: https://github.com/jl917/webpack-plugin-runtime-assets

#### winston-mongodb

express 서버에서 winston 사용시 관련로그를 mongodb에 저장하는 플러그인

- npm: https://www.npmjs.com/package/@julong/winston-mongodb
- github: https://github.com/jl917/winston-mongodb



---
url: /hello/social.md
---

# Social

- https://github.com/jl917
- https://codesandbox.io/u/jl917
- https://www.npmjs.com/~julong
- https://leetcode.cn/u/julong1988/


---
url: /hello/software.md
---

# Software

## 개발용

| 이름               | 링크                                                                                                                       |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| Zsh                | [https://ohmyz.sh/](https://ohmyz.sh/)                                                                                     |
| Homebrew           | [https://brew.sh/](https://brew.sh/)                                                                                       |
| Git 다운로드       | [https://git-scm.com/download/mac](https://git-scm.com/download/mac)                                                       |
| Git SSH 키 생성    | [https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥](https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥) |
| Node.js            | [https://formulae.brew.sh/formula/node](https://formulae.brew.sh/formula/node)                                             |
| Pict               | `brew install pict`                                                                                                        |
| Visual Studio Code | [https://code.visualstudio.com/](https://code.visualstudio.com/)                                                           |
| VS Code 설정       | [https://code.visualstudio.com/docs/setup/mac](https://code.visualstudio.com/docs/setup/mac)                               |
| Spectacle          | [https://github.com/eczarny/spectacle/releases](https://github.com/eczarny/spectacle/releases)                             |
| VSCodium           | [https://vscodium.com/](https://vscodium.com/)                                                                             |
| Smart JSON Editor  | [http://www.smartjsoneditor.com/](http://www.smartjsoneditor.com/)                                                         |
| GitHub Desktop     | [https://desktop.github.com/](https://desktop.github.com/)                                                                 |
| NVM                | [https://github.com/nvm-sh/nvm/tree/master](https://github.com/nvm-sh/nvm/tree/master)                                     |
| Studio 3T          | [https://studio3t.com/download/](https://studio3t.com/download/)                                                           |
| Cursor             | [https://cursor.sh/](https://cursor.sh/)                                                                                   |
| PicGo              | [https://molunerfinn.com/PicGo/](https://molunerfinn.com/PicGo/)                                                           |
| Chrome 베타        | [https://www.google.com/chrome/beta/](https://www.google.com/chrome/beta/)                                                 |
| Chrome 한국어      | [https://www.google.com/intl/ko/chrome/](https://www.google.com/intl/ko/chrome/)                                           |
| Postman            | [https://www.postman.com/downloads/?utm_source=postman-home](https://www.postman.com/downloads/?utm_source=postman-home)   |
| Notion             | [https://www.notion.so/ko-kr](https://www.notion.so/ko-kr)                                                                 |
| Gas Mask           | [https://github.com/2ndalpha/gasmask](https://github.com/2ndalpha/gasmask)                                                 |
| reqable            | [https://reqable.com/en-US/](https://reqable.com/en-US/)                                                                   |
| Ophiuchi           | [https://www.ophiuchi.dev/](https://www.ophiuchi.dev/)                                                                     |
| Debugtron          | [https://github.com/pd4d10/debugtron](https://github.com/pd4d10/debugtron)                                                 |
| trae               | [https://www.trae.ai/](https://www.trae.ai/)                                                                               |
| rust               | [https://rust-lang.org/learn/get-started/](https://rust-lang.org/learn/get-started/)                                       |
| youtubedownload    | [https://ytdn.netlify.app/#mac](https://ytdn.netlify.app/#macr)                                                            |

## 개인용

| 이름      | 링크                                                                                                                                   |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| IINA      | [https://iina.io/](https://iina.io/)                                                                                                   |
| Motrix    | [https://motrix.app/](https://motrix.app/)                                                                                             |
| FileZilla | [https://filezilla-project.org/](https://filezilla-project.org/)                                                                       |
| Wireshark | [https://www.wireshark.org/](https://www.wireshark.org/)                                                                               |
| Infuse    | [https://apps.apple.com/kr/app/infuse-비디오-플레이어/id1136220934](https://apps.apple.com/kr/app/infuse-비디오-플레이어/id1136220934) |
| PicView   | [https://picview.org/](https://picview.org/)                                                                                           |

## 설정

```sh
alias pip=/usr/bin/pip3
alias python=/usr/bin/python3

echo 'export PATH=/opt/homebrew/bin:$PATH' >> ~/.zshrc

git config --global user.name "JuLong"
git config --global user.email julong1988@naver.com
npm install -g http-server
cd ~/
mkdir .ssh
cd .ssh
ssh-keygen -o
cat ~/.ssh/id_rsa.pub

xattr -cr /Applications/PicGo.app
sudo spctl --master-disable

defaults write com.apple.finder AppleShowAllFiles -bool true
killall Finder

## npm set
npm set init-author-name 'jl917'
npm set init-author-email 'julong1988@naver.com'
npm set init-author-url 'https://jl917.github.io'
npm set init-license 'MIT'


export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion



# .zshrc
export PATH="$HOME/.cargo/bin:$PATH"
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="robbyrussell"
plugins=(git)
source $ZSH/oh-my-zsh.sh
export PATH=/opt/homebrew/bin:$PATH
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
autoload -U add-zsh-hook
load-nvmrc() {
  local nvmrc_path
  nvmrc_path="$(nvm_find_nvmrc)"

  if [ -n "$nvmrc_path" ]; then
    local nvmrc_node_version
    nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")

    if [ "$nvmrc_node_version" = "N/A" ]; then
      nvm install
    elif [ "$nvmrc_node_version" != "$(nvm version)" ]; then
      nvm use
    fi
  elif [ -n "$(PWD=$OLDPWD nvm_find_nvmrc)" ] && [ "$(nvm version)" != "$(nvm version default)" ]; then
    echo "Reverting to nvm default version"
    nvm use default
  fi
}

add-zsh-hook chpwd load-nvmrc
load-nvmrc
```

![](https://raw.githubusercontent.com/jl917/s/master/image/20250302222328-4ecb61c77381ddc25c759173828383ae.png)

## 기타 설치

```
brew install python
```



---
url: /algorithm/pattern/01.md
---

# 抽象工厂模式(Abstract Factory)

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

```js
class Employee {
  constructor(name) {
    this.name = name;
  }
  say() {
    console.log(`I am ${this.name}`);
  }
}

class EmployeeFactory {
  constructor() {}
  create(name) {
    return new Employee(name);
  }
}

export { EmployeeFactory };
```

```js
const employeeFactory = new EmployeeFactory();
const dao = employeeFactory.create("DaoLang");
dao.say();
```



---
url: /algorithm/pattern/02.md
---

# 构建者模式(Builder)

将对象构造与其表示分开

```js
class Starbucks {
  constructor() {}
  create(builder) {
    builder.step1();
    builder.step2();
    builder.step3();
    return builder.get();
  }
}

class Americano {
  constructor() {
    this.water = null;
    this.coffee = null;
  }
  addCoffee() {
    this.coffee = "20g";
  }
  addWater() {
    this.water = "400ml";
  }
}

class AmericanoBuilder {
  constructor() {
    this.drink = null;
  }
  step1() {
    this.drink = new Americano();
  }
  step2() {
    this.drink.addCoffee();
  }
  step3() {
    this.drink.addWater();
  }
  get() {
    return this.drink;
  }
}

export { Starbucks, AmericanoBuilder };
```

```js
let starbucks = new Starbucks();
let americanoBuilder = new AmericanoBuilder();
starbucks.create(americanoBuilder);
```



---
url: /algorithm/pattern/03.md
---

# 工厂方法模式(Factory Method)

创建多个派生类的实例

```js
class Apple {
  constructor(model) {
    this.model = model;
  }
  get() {
    return this.model;
  }
}

class AppleCreate {
  constructor() {}
  create(model) {
    return new Apple(model);
  }
}

export default AppleCreate;
```

```js
let appleCreate = new AppleCreate();
appleCreate.create("iphone 7");
```



---
url: /algorithm/pattern/04.md
---

# 原型模式(Prototype)

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

```js
class CustomerPrototype {
  constructor(proto) {
    this.proto = proto;
  }
  clone() {
    const customer = new Customer();
    customer.first = proto.first;
    customer.last = protp.last;
    customer.status = proto.status;
    return customer;
  }
}

class Customer {
  constructor(first, last, status) {
    this.first = fisrt;
    this.last = last;
    this.status = status;
  }
  say() {
    console.log(`name: ${this.first} ${this.last}, status: ${this.status}`);
  }
}
```

```js
const proto = new Customer("n/a", "n/a", "pending");
const prototype = new CustomerPrototype(proto);
const customer = prototype.clone();
customer.say();
```



---
url: /algorithm/pattern/05.md
---

# 单例模式(Singleton)

确保一个类只有一个实例，并提供一个全局访问点。

```js
//普通单体
let Singleton1 = {
  name: "Apple",
  get() {
    return this.name;
  },
};

//有局部变量的单体
let Singleton2 = () => {
  let _name = "apple";
  let _color = "red";
  return {
    name: _name,
    color: _color,
  };
};

export { Singleton1, Singleton2 };
```

```js
Singleton1.get();
Singleton2();
```



---
url: /algorithm/pattern/06.md
---

# 适配器模式(Adapter)

匹配不同类的接口

```js
// old api
class Mart {
  constructor() {
    this.cola = 3;
    this.bread = 5;
  }
  getPrice(type, num) {
    return this[type] * Math.floor(num);
  }
}

// new api
class NewMart {
  constructor() {
    this.cola = 3;
    this.bread = 5;
  }
  getTotalPrice(...rest) {
    let _result = 0;
    rest.forEach((e) => {
      _result += this[e.type] * e.length;
    });
    return _result;
  }
}

//adapter
class MartAdapter {
  constructor() {}

  getPrice(type, num) {
    return new Mart().getPrice(type, num);
  }

  getTotalPrice(...rest) {
    return new NewMart().getTotalPrice(...rest);
  }
}

export { Mart, NewMart, MartAdapter };
```

```js
let martAdapter = new MartAdapter();
//old
martAdapter.getPrice("cola", 5);
//new
martAdapter.getTotalPrice({ type: "cola", length: 3 }, { type: "bread", length: 2 });
```



---
url: /algorithm/pattern/07.md
---

# 桥接模式(Bridge)

将抽象与其实现分离，以便两者可以独立变化。

```js
// input device
class Mouse {
  constructor(output) {
    this.output = output;
  }
  click() {
    this.output.click();
  }
  move() {
    this.output.move();
  }
}

// output device
class Screen {
  construcotr() {}
  click() {
    console.log("screen click");
  }
  move() {
    console.log("screen move");
  }
}
export { Mouse, Screen };
```

```js
const screen = new Screen();
const mouse = new Mouse(screen);
mouse.click();
mouse.move();
```



---
url: /algorithm/pattern/08.md
---

# 组合模式(Composite Pattern)

又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。



---
url: /algorithm/pattern/09.md
---

# 装饰者模式(Decorator)

动态地将附加职责附加到对象。 装饰器为子类化提供了灵活的替代扩展功能。

```js
class User {
  constructor(name, password) {
    this.name = name;
    this.password = password;
  }
}
class DecoratorUser {
  constructor(user, email, tel) {
    this.name = user.name;
    this.password = user.password;
    this.email = email;
    this.tel = tel;
  }
  get() {
    return this;
  }
}

export { User, DecoratorUser };
```

```js
let user = new User("dao", "1234");
let decUser = new DecoratorUser(user, "julong1988@naver.com", "15526719999");
decUser.get();
```



---
url: /algorithm/pattern/10.md
---

# 外观模式(Facade)

为子系统中的一组接口提供统一接口。 Façade 定义了一个更高级别的接口，使子系统更易于使用。

```js
class s1 {
  constructor() {}
  get(name, score) {
    return name == "julong" || score == 100;
  }
}

class s2 {
  constructor() {}
  get(score) {
    return score >= 80;
  }
}

class s3 {
  constructor() {}
  get(score) {
    return score >= 60;
  }
}

class Student {
  constructor(name, score) {
    this.name = name;
    this.score = score;
  }
}
class CheckScore {
  constructor(student) {
    this.name = student.name;
    this.score = student.score;
    this.message = "";
  }
  result() {
    if (new s1().get(this.name, this.score)) {
      this.message = "全球旅游";
    } else if (new s2().get(this.score)) {
      this.message = "挨打50大板";
    } else if (new s3().get(this.score)) {
      this.message = "强制移民去印度";
    } else {
      this.message = "死刑";
    }
    return this;
  }
}

export { Student, CheckScore };
```

```js
let s01 = new Student("julong", 50);
let s01Check = new CheckScore(s01);
s01Check.result();
```



---
url: /algorithm/pattern/11.md
---

# 享元模式(Flyweight Pattern)

主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

```js
let textCount = 0;
let textAttrCount = 0;

class Text {
  constructor() {
    this.text = "";
  }
  add(text) {
    this.text = text;
    textCount++;
  }
}

class TextAttr {
  constructor() {}
  add(color, size) {
    this.color = color;
    this.size = size;
    textAttrCount++;
  }
}

class TextFactory {
  constructor() {
    this.textObj = new Text();
    this.resultText = [];
  }
  create(text, color, size) {
    if (this.textObj.text != text) {
      this.textObj = new Text();
      this.textObj.add(text);
    }
    let textAttr = new TextAttr();
    textAttr.add(color, size);
    this.resultText.push({
      id: this.textObj.text + textAttr.color + textAttr.size,
      text: this.textObj.text,
      color: textAttr.color,
      size: textAttr.size,
    });
  }

  get() {
    return this.resultText;
  }

  getCount() {
    return {
      textCount,
      textAttrCount,
    };
  }
}

export default TextFactory;
```

```js
let text01 = new TextFactory();
text01.create("hello world", "red", 14);
text01.create("hello world", "blue", 16);
text01.create("hello world", "green", 15);
text01.create("what the fuck~", "gray", 30);
text01.get();
text01.getCount();
```



---
url: /algorithm/pattern/12.md
---

# 代理模式(Proxy)

为另一个对象提供代理或占位符以控制对它的访问。

```js
class Cola {
  constructor() {
    this.length = 0;
  }
  buy(length) {
    this.length = this.length + length;
  }
  get() {
    return this.length;
  }
}

class ColaProxy {
  constructor() {
    this.buyCola = new Cola();
    this.count = 0;
  }
  buy(length) {
    this.buyCola.buy(length);
    this.count++;
  }
  get() {
    return this.buyCola.get();
  }
  getCount() {
    return this.count;
  }
}

export { Cola, ColaProxy };
```



---
url: /algorithm/pattern/13.md
---

# 职责链模式(Chain of Responsibility)

通过为多个对象提供处理请求的机会，避免将请求的发送者耦合到其接收者。 链接接收对象并沿链传递请求，直到对象处理它。

```js
class Request {
  constructor(amount) {
    this.amount = amount;
    console.log("Requested: $" + amount + "\n");
  }

  get(bill) {
    const count = Math.floor(this.amount / bill);
    this.amount -= count * bill;
    console.log("Dispense " + count + " $" + bill + " bills");
    return this;
  }
}
```

```js
const request = new Request(378);
request.get(100).get(50).get(20).get(10).get(5).get(1);
```



---
url: /algorithm/pattern/14.md
---

# 命令模式(Command)

请求以命令的形式包裹在对象中

```js
let add = (...rest) => rest.reduce((total, num) => total + num);
let sub = (a, b) => a - b;
let mul = (a, b) => a * b;
let div = (a, b) => a / b;

class Calculator {
  constructor() {}
  add(...rest) {
    return add(...rest);
  }
  sub(a, b) {
    return sub(a, b);
  }
  mul(a, b) {
    return mul(a, b);
  }
  div(a, b) {
    return div(a, b);
  }
}

export default Calculator;
```

```js
calculator.add(2, 4, 5);
calculator.sub(22, 13);
calculator.mul(3, 7);
calculator.div(9, 3);
```



---
url: /algorithm/pattern/15.md
---

# 解释器模式(Interpreter)

一种在程序中包含语言元素的方法



---
url: /algorithm/pattern/16.md
---

# 迭代器模式(Iterator)

提供一种顺序访问聚合对象元素的方法，而不会暴露其基础表示。

```js
class Iterator {
  constructor(items) {
    this.index = 0;
    this.items = items;
  }
  first() {
    this.index = 0;
    return this.items[0];
  }
  next() {
    this.index++;
    return this.items[this.index];
  }
  hasNext() {
    return this.items.length - 1 > this.index;
  }
  reset() {
    this.index = 0;
  }
  each(callback) {
    for (let i = 0; i < this.items.length; i++) {
      callback(this.items[i]);
    }
  }
}
```

```js
const items = ["one", 2, "circle", true, "Applepie"];
const iter = new Iterator(items);

console.log(iter.first());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.hasNext());
console.log(iter.next());

iter.each(function (e) {
  console.log(e);
});
```



---
url: /algorithm/pattern/17.md
---

# 中介者模式(Mediator)

定义类之间的简化通信

```js
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sendMessage(target, message) {
    target.addMessage(this.name, message);
  }
}

class ChatRoom {
  constructor(crname) {
    this.crname = crname;
    this.message = [];
  }
  addMessage(name, message) {
    this.message.unshift({ name, message });
  }
  showMessage() {
    return this.message;
  }
}
export { User, ChatRoom };
```

```js
let user1 = new User("julong", "23");
let user2 = new User("dao", "32");
let devRoom = new ChatRoom("devroom");
user1.sendMessage(devRoom, "hello");
user1.sendMessage(devRoom, "hi~  what");
user2.sendMessage(devRoom, "halou ju long ");
devRoom.showMessage();
```



---
url: /algorithm/pattern/18.md
---

# 备忘录模式(Memento)

可以使用此模式的一个例子是将物件回复到其先前的状态

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  hydrate() {
    return { ...this };
  }

  deydreate({ name, age }) {
    this.name = name;
    this.age = age;
  }
}

class Store {
  constructor() {
    this.store = {};
  }

  add(key, value) {
    this.store[key] = value;
  }
  get(key) {
    return this.store[key];
  }
}
```

```js
const dao = new Person("dao", 12);
const lang = new Person("lang", 30);
const store = new Store();

store.add(1, dao.hydrate());
store.add(2, lang.hydrate());

dao.name = "newdao";
lang.name = "newlang";

console.log(dao);
console.log(lang);

dao.deydreate(store.get(1));
lang.deydreate(store.get(2));
console.log(dao);
console.log(lang);
```



---
url: /algorithm/pattern/19.md
---

# 观察者模式(Observer)

定义对象之间的一对多依赖关系，以便当一个对象更改状态时，将自动通知和更新其所有依赖项。

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sendPrice(target, price) {
    target.addPrice(price);
  }
  getPrice(target) {
    return target.getPrice();
  }
}

class Auction {
  constructor() {
    this.price = 0;
    this.sellState = true;
  }
  addPrice(price) {
    this.sellState ? (price > this.price ? (this.price = price) : "") : "";
  }
  getPrice() {
    return this.price;
  }
  closeSell() {
    this.sellState = false;
  }
}

export { User, Auction };
```

```js
let user1 = new User("julong");
let user2 = new User("dao");
let auction = new Auction();
user1.sendPrice(auction, 12);
user2.sendPrice(auction, 32);
user1.getPrice(auction);
auction.closeSell();
user2.sendPrice(auction, 36);
user1.getPrice(auction);
```



---
url: /algorithm/pattern/20.md
---

# 状态模式(State)

在状态发生变化时改变对象的行为

```js
/*
state
0 销售中
1 订单成功
2 商品转到物流
3 物流发送
*/
class System {
  constructor() {
    this.state = 0;
  }
  setState(state) {
    this.state = state;
  }
}

class Sales {
  constructor() {}
  confirmOrder(target) {
    target.state == 1 ? target.setState(2) : "";
  }
}

class Logistics {
  constructor() {}
  complet(target) {
    target.state == 2 ? target.setState(3) : "";
  }
}

class Client {
  constructor() {}
  buy(target) {
    target.state == 0 ? target.setState(1) : "";
  }
}

export { System, Sales, Logistics, Client };
```

```js
let system = new System();
let client = new Client("julong");
let sales = new Sales("sale1");
let logistics = new Logistics("l1");
client.buy(system);
sales.confirmOrder(system);
logistics.complet(system);
```



---
url: /algorithm/pattern/21.md
---

# 策略模式(Strategy)

将算法封装在类中

```js
class Market1 {
  constructor() {
    this.products = {
      cola: {
        price: 3,
        length: 20,
      },
    };
  }

  caculate(obj) {
    return this.products[obj.name].price * obj.length;
  }
}

class Market2 {
  constructor() {
    this.products = {
      cola: {
        price: 2.5,
        length: 20,
      },
    };
  }

  caculate(obj) {
    return this.products[obj.name].price * obj.length;
  }
}

class Shop {
  constructor(market) {
    this.market = market;
  }

  caculate(obj) {
    return this.market.caculate(obj);
  }
}

export { Shop, Market1, Market2 };
```

```js
let market1 = new Shop(new Market1());
let market2 = new Shop(new Market2());
market1.caculate({ name: "cola", length: 3 });
market2.caculate({ name: "cola", length: 3 });
```



---
url: /algorithm/pattern/22.md
---

# 模板方法模式(Template Method)



---
url: /algorithm/pattern/23.md
---

# 访问者模式(Visitor)



---
url: /algorithm/structures.md
---

# Structures

## Stack
```js
function Stack() {
  let items = [];
  // 添加元素
  this.push = (element) => (items = [...items, element]);
  // 删除元素
  this.pop = () => items.pop();
  // 返回顶元素
  this.peek = () => items[items.length - 1];
  // 是否为空
  this.isEmpty = () => items.length === 0;
  // 清空
  this.clear = () => (items = []);
  // 元素个数
  this.size = () => items.length;
  // 打印
  this.print = () => items;
}
```

## Queue

```js
function Queue() {
  let items = [];
  // 添加元素
  this.enqueue = (element) => (items = [...items, element]);
  // 删除元素
  this.dequeue = () => items.shift();
  // 第一个元素
  this.front = () => items[0];
  // 是否为空
  this.isEmpty = () => items.length === 0;
  // 元素个数
  this.size = () => items.length;
  // 打印
  this.print = () => items;
}

function PriorityQueue() {
  let items = [];
  // 添加元素
  this.enqueue = (element, priority) => {
    const obj = { element, priority };
    for (let i = 0; i < items.length; i++) {
      // 根据重要度插入到特定位置
      if (priority > items[i].priority) {
        return (items = [...items.slice(0, i), obj, ...items.slice(i)]);
      }
    }
    return (items = [...items, obj]);
    // 速度慢
    // items = [...items, obj].sort((a,b) => b.priority - a.priority)
  };
  // 删除元素
  this.dequeue = () => items.shift();
  // 第一个元素
  this.front = () => items[0];
  // 是否为空
  this.isEmpty = () => items.length === 0;
  // 元素个数
  this.size = () => items.length;
  // 打印
  this.print = () => items;
}
```

## LinkedList

```js
function LinkedList() {
  function Node(element) {
    this.element = element;
    this.next = null;
  }
  let length = 0;
  let head;

  // 尾部添加
  this.append = (value) => {
    const element = new Node(value);
    if (head) {
      let current = head;
      while (current.next) {
        current = current.next;
      }
      current.next = element;
    } else {
      head = element;
    }
    length++;
  };

  // 特定位置插入
  this.insert = (position, value) => {
    const element = new Node(value);
    let index = 1;
    let current = head;
    let tmp;

    while (index < position) {
      current = current.next;
      index++;
    }
    length++;
    if (position === 0) {
      element.next = current;
      head = element;
    } else {
      tmp = current.next;
      current.next = element;
      current.next.next = tmp;
    }
  };

  // 特定位置移除一项
  this.removeAt = (position) => {
    let index = 0;
    let previos;
    let current = head;

    while (index < position) {
      previos = current;
      current = current.next;
      index++;
    }
    previos.next = current.next;

    length--;
  };

  // 移除一项
  this.remove = (value) => {
    let previos;
    let current = head;
    while (current.element !== value) {
      previos = current;
      current = current.next;
    }
    previos.next = current.next;
    length--;
  };

  // 返回索引
  this.indexOf = (value) => {
    let index = 0;
    let current = head;
    while (current.element !== value) {
      current = current.next;
      index++;
    }
    return index;
  };

  // 是否为空
  this.isEmpty = () => length === 0;

  // 元素个数
  this.size = () => length;

  // 获取链头
  this.getHead = () => head.element;

  // 打印
  this.print = () => head;
}
```

## Set

```js
function NS_Set(a, b) {
  // 并集
  this.union = () => [...new Set(a.concat(b))];

  // 交集
  this.intersection = () => a.filter((e) => b.includes(e));

  // 差集
  this.difference = () => a.filter((e) => !b.includes(e));

  // 子集
  this.subset = () => b.every((e) => a.includes(e));
}
```

## Tree

```js
function BinarySearchTree() {
  function Node(element) {
    this.element = element;
    this.left = null;
    this.right = null;
  }
  let root;

  // 添加值
  this.insert = (element) => {
    const node = new Node(element);
    let current = root;

    if (!root) {
      return (root = node);
    }

    while (current.element !== node.element) {
      if (current.element > node.element) {
        current.left ? (current = current.left) : (current.left = node);
      }

      if (current.element < node.element) {
        current.right ? (current = current.right) : (current.right = node);
      }
    }
    return ''
  };

  // 搜索
  this.search = (element) => {
    let current = root;

    while (current) {
      if (current.element === element) {
        return true;
      }
      current = current[current.element > element ? 'left' : 'right'];
    }

    return false;
  };

  // 最小值
  this.min = (current = root) => {
    while (current.left) {
      current = current.left;
    }
    return current.element;
  };

  // 最大值
  this.max = (current = root) => {
    while (current.right) {
      current = current.right;
    }
    return current.element;
  };

  // 删除元素
  this.remove = (element, isAll = true) => {
    let current = root;
    let previos = {
      node: root,
      type: 'left',
    };

    if (root.element === element) {
      return console.log('root无法删除');
    }

    while (current) {
      if (current.element === element) {
        // 删除整个节点或者无子元素
        if (isAll || (current.left === null && current.right === null)) {
          return (previos.node[previos.type] = null);
        }

        if (current.left !== null && current.right !== null) {
          // 两个子节点
          // 替换为右侧节点中最小值并保持原先的lr
          // const value = this.min(current.right)
          // 替换为左侧节点中最大值并保持原先的lr
          const value = this.max(current.left);
          this.remove(value, true);
          previos.node[previos.type].element = value;
        } else {
          // 一个子节点
          previos.node[previos.type] = current[current.left || current.right];
        }
        return '';
        //
      }
      previos = {
        node: current,
        type: current.element > element ? 'left' : 'right',
      };
      current = current[current.element > element ? 'left' : 'right'];
    }

    return false;
  };

  // 中序遍历
  this.inOrderTraverse = () => {
    function fn(node) {
      if (node.left) {
        fn(node.left);
      }
      console.log(node.element);
      if (node.right) {
        fn(node.right);
      }
    }
    fn(root);
  };
  // 先序遍历
  this.preOrderTraverse = () => {
    function fn(node) {
      console.log(node.element);
      if (node.left) {
        fn(node.left);
      }

      if (node.right) {
        fn(node.right);
      }
    }
    fn(root);
  };
  // 后序遍历7
  this.postOrderTraverse = () => {
    function fn(node) {
      if (node.left) {
        fn(node.left);
      }
      if (node.right) {
        fn(node.right);
      }
      console.log(node.element);
    }
    fn(root);
  };

  this.print = () => console.log(JSON.stringify(root, null, 2));
}
```



---
url: /note/graphql/index.md
---

# GraphQL

- GraphQL 是一种协议和一种 API 查询语言(实现数据查询的 runtime), 通常基于 http 协议
- GraphQL 是客户端和服务器之间通信的规范。

## 优点

### 1.提高开发速度

- 可以减少发出请求
- 单个调用来获取所需数据
- 减少延迟， 还能降低服务器的压力
- GraphQL 具有自文档的特点

### 2.提升开发者体验

- 更少的时间思考如何获取数据
- 在使用 Apollo 时，只需要在 UI 中声明数据
- 数据和 UI 放在一起，阅读代码和编写代码都变得更方便了
- GraphQL 之于数据， 就如 React 之于 UI

### 3.将复杂的 API 进行简化和标准化

- 可以按照需求自由组合和嵌套对象
- 对于每个对象都能够获得所需的数据，不多也不少

### 4.提升安全性

- 需要进行 schema 验证，而且是强类型的，因为这是它规范的一部分。
- 它可以频繁更新，而不会因为引入了新类型造成重大变更。

## 设计原则

- 分层(查询字段层次分明。字段嵌套在其他字段当中，查询字段的结构与其返回的数据结构相似)
- 以产品为中心(客户端所需的数据，以及客户端支持的语言和 runtime)
- 强类型(每个数据点在模版当中都有其特定的类型，并且均会进行验证)
- 客户端指定查询(服务器提供功能供客户端使用)
- 类型自查(能够查询 GraphQL 服务器的类型检测系统)

## REST 缺点

- 过量获取
- 缺乏灵活性

## 术语

- SEQL(Structured English Query Language) - 结构化英文查询语言
- SQL(Structured Query Language) - 结构化查询语言
- SDL(Schema Definition Language) - 模版定义语言
- scalar type - 标量类型（String, Int, Boolean, ID, Float）
- ID(Identity Document)



---
url: /note/graphql/client.md
---

# Client

```sh
npm install --save @apollo/client graphql
```

### Client

```js
import { ApolloClient, InMemoryCache } from "@apollo/client";

const client = new ApolloClient({
  uri: "http://localhost:4000",
  cache: new InMemoryCache(),
  defaultOptions: {
    watchQuery: {
      fetchPolicy: "no-cache",
      errorPolicy: "ignore",
    },
    query: {
      fetchPolicy: "no-cache",
      errorPolicy: "all",
    },
  },
});

export default client;
```

### ApolloProvider

```jsx
render(
  <ApolloProvider client={client}>
    <Provider store={store}>
      <Router />
    </Provider>
  </ApolloProvider>,
  document.getElementById("app")
);
```

### Mutation

```jsx
import React, { useState } from "react";
import { Form, Input, Button, InputNumber } from "antd";
import { useMutation, gql } from "@apollo/client";

// graphql부분(1)
const ADD_USER = gql`
  mutation AddUser($first: String, $last: String, $email: String) {
    addUser(first: $first, last: $last, email: $email) {
      email
    }
  }
`;

const Page = () => {
  const [resetKey, setResetKey] = useState(0);
  // graphql부분(2)
  const [addUser, { data }] = useMutation(ADD_USER);

  const onFinish = ({ first, last, email }) => {
    // graphql부분(3)
    addUser({ variables: { first, last, email } });
    setResetKey(resetKey + 1);
  };
  return (
    <Form
      onFinish={onFinish}
      labelCol={{ span: 4 }}
      wrapperCol={{ span: 20 }}
      initialValues={{
        first: `dao${new Date().getTime()}`,
        last: `lang${new Date().getTime()}`,
        email: `daolang${new Date().getTime()}@gmail.com`,
      }}
      key={resetKey}
    >
      <Form.Item
        name="first"
        label="first"
      >
        <Input />
      </Form.Item>
      <Form.Item
        name="last"
        label="last"
      >
        <Input />
      </Form.Item>
      <Form.Item
        name="email"
        label="Email"
      >
        <Input />
      </Form.Item>
      <Form.Item>
        <Button
          type="primary"
          htmlType="submit"
        >
          Submit
        </Button>
      </Form.Item>
    </Form>
  );
};

export default Page;
```

Query

```jsx
import React, { useCallback } from "react";
import { useQuery, gql } from "@apollo/client";
import { useDispatch, useSelector } from "react-redux";
import { setCount } from "./redux";
import { Table } from "antd";

// graphql(1)
const GET_USERS = gql`
  query Users {
    users {
      key: _id
      name {
        first
        last
      }
      email
    }
  }
`;

const columns = [
  {
    title: "Id",
    dataIndex: "key",
    key: "key",
  },
  {
    title: "First",
    dataIndex: "name",
    key: "name",
    render: (item) => item.first,
  },
  {
    title: "Last",
    dataIndex: "name",
    key: "name",
    render: (item) => item.first,
  },
  {
    title: "Email",
    dataIndex: "email",
    key: "email",
  },
];

const Page = () => {
  // graphql(2)
  const { loading, error, data } = useQuery(GET_USERS);
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error :(</p>;

  return (
    <div>
      <Table
        columns={columns}
        dataSource={data.users}
      />
    </div>
  );
};

export default Page;
```



---
url: /note/graphql/query.md
---

# Query

### 工具

1. GraphiQL (http://snowtooth.herokuapp.com/graphql)

2. GraphQL Playground (https://www.graphqlbin.com/)

   ```shell
   $ brew cask install praphql-playground
   ```

### 公共 API （https://github.com/APIs-guru/graphql-apis）

### 内置类型

- Int
- FLoat
- String
- Boolean
- ID

参考： http://snowtooth.moonhighway.com

### 查询字段 query

```graphql
## Basic
query liftsAndTrails {
  liftCount(status: OPEN)
  allLifts {
    name
    status
  }
  allTrails {
    name
    diffculty
  }
}
## NameSpace
query liftsAndTrails {
  open: liftCount(status: OPEN)
  chairlifts: allLifts {
    name
    status
  }
  skiSlopes: allTrails {
    name
    diffculty
  }
}
```

### 片段 Fragment

```graphql
fragment liftInfo on Lift {
  name
  status
  capacity
  night
  elevationGain
}
fragment trailInfo on Trail {
  name
  difficulty
}

query {
  Lift(id: "jazz-cat") {
    ...liftInfo
    trailAccess {
      ...trailInfo
    }
  }
  Trail(id: "river-run") {
    ...trailInfo
    accessedByLifts {
      ...liftInfo
    }
  }
}
```

### 变更 mutation

```graphql
mutation createSong {
  addSong(title: "No Scrubs", numberOne: true, performerName: "TLC") {
    id
    title
    numberOne
  }
}
```

### 订阅 subscription

```graphql
subscription {
  liftStatusChange {
    name
    capacity
    status
  }
}

## 修改
mutation closeLift {
  setLiftStatus(id: "astra-express", status: HOLD) {
    name
    status
  }
}
```

### 自检 inrospection ???

```graphql
query {
  __schema {
    types {
      name
      description
    }
  }
}

query {
  __type(name: "Lift") {
    name
    fields {
      name
      description
      type {
        name
      }
    }
  }
}
```



---
url: /note/graphql/schema.md
---

# SCHEMA

你要对 API 包含的数据类型进行统筹，讨论并正式确定下来。 这种类型的集合就是后端程序员所熟知的 schema

schema 优先是一种设计方法论，遵循它可以使团队保持一致的数据类型。

### TYPE

```graphql
type Photo {
  id: ID! # 非空字段 non-nullable
  name: String!
  url: String!
  description: String
}
```

### 标量类型 scalar

https://www.npmjs.com/package/graphql-custom-types

```graphql
scalar DataTime
type Photo {
  id: ID!
  name: String!
  url: String!
  description: String
  created: DateTime!
}
```

```js
import { GraphQLScalarType } from "graphql";

const myCustomScalarType = new GraphQLScalarType({
  name: "MyCustomScalar",
  description: "Description of my custom scalar type",
  serialize(value) {
    let result;
    // 从服务端发送给客户端的数据
    return result;
  },
  parseValue(value) {
    // 从客户端接收的数据
    let result;
    return result;
  },
  parseLiteral(ast) {
    switch (ast.kind) {
    }
  },
});

const schemaString = `
scalar MyCustomScalar

type Foo {
  aField: MyCustomScalar
}

type Query {
  foo: Foo
}
`;
```

### 枚举 enum

```graphql
enum PhotoCategory {
  SELFIE
  PORTRAIT
  ACTION
  LANDSCAPE
  GRAPHIC
}
```

### 列表 list

```
[String]
[Int] # 可空的整数值列表
# [] => ok, [null,1,2] => ok
[Int!] # 不可空的整数值列表
# [] => ok, [null,1,2] => error
[Int]! # 可空的整数值非空列表
# [] => error, [null,1,2] => ok
[Int!]! # 不可空的整数值非空列表
# [] => error, [null,1,2] => error
```

### 连接 Linked

#### 一对一

```
type User {
	username: ID!
	name: String
	avatar: String
}
type Photo {
	id: ID!
	url: String!
	description: String
	created: DateTime!
	postedBy: User!
}
```

#### 一对多

```
type User {
	username: ID!
	name: String
	avatar: String
	photos: [Photo!]
}
type Photo {
	id: ID!
	url: String!
	description: String
	created: DateTime!
	postedBy: User!
}
```

#### 多对多？？

#### 直通类型

```
type User {
	username: ID!
	name: String
	avatar: String
}
type User {
	friends [User!]!
}
```

### 联合类型 union type

### 接口 interface

### 参数 argument

```
type Query {
	# 查询
	User(id: ID!): User!
	# 筛选
	allPhotos(category: PhotoCategory): [Photo!]!
}
```

####

### 输入



---
url: /note/graphql/server.md
---

# Server

```js
module.exports = "db"; // https://randomuser.me/api/?results=50
```

### typeDefs

```js
const { gql } = require("apollo-server");

module.exports = gql`
  type Name {
    first: String
    last: String
  }
  type User {
    name: Name
    email: String
  }
  type Query {
    users: [User]
  }
  type Mutation {
    addUser(first: String, last: String, email: String): User
  }
`;
```

### resolves

```js
const db = require("./db");

module.exports = {
  Query: {
    users: () => db.results,
  },
  Mutation: {
    addUser: (obj, args, ctx) => {
      console.log(args); // 받은 객체 저장.
      return "등록 완료";
    },
  },
};
```

### app

```js
const { ApolloServer, makeExecutableSchema } = require("apollo-server");
const typeDefs = require("./typeDefs");
const resolvers = require("./resolves");

const schema = makeExecutableSchema({ typeDefs, resolvers });
const server = new ApolloServer({ schema });

// The `listen` method launches a web server.
server.listen().then(({ url }) => {
  console.log(`🚀  Server ready at ${url}`);
});
```



---
url: /note/html/doctype.md
---

# Doctype

### Doctype
```html
<!doctype html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

### meta

```html
<meta charset="UTF-8">

<!-- 页面关键词 -->
<meta name="keywords" content=""/>
<!-- 页面描述 -->
<meta name="description" content="网站介绍"/>
<meta name ="viewport" content ="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no">

<!-- 优先使用 IE 最新版本和 Chrome -->
<meta http-equiv="X-UA-Compatible" content="IE=edge">


<!-- mobile -->
<!-- 忽略数字自动识别为电话号码； -->
<meta name="format-detection" content="telephone=no" />
<!-- 忽略数字自动识别为邮箱 -->
<meta name="format-detection" content="email=no">

<!-- ios -->
<!-- 添加到主屏后设置状态栏的背景颜色； -->
<meta content="black" name="apple-mobile-web-app-status-bar-style">
<!-- 添加到主屏后的标题（iOS 6 新增） -->
<meta name="apple-mobile-web-app-title" content="标题">
<!-- 启动WebApp全屏模式； -->
<meta name="apple-mobile-web-app-capable" content="yes" />

<!-- 搜索引擎抓取 -->
<meta name="robots" content="index,follow"/>

<!-- sns 社交标签 begin -->
<!-- 参考微博API -->
<meta property="og:type" content="类型" />
<meta property="og:url" content="URL地址" />
<meta property="og:title" content="标题" />
<meta property="og:image" content="图片" />
<meta property="og:description" content="描述" />
<!-- sns 社交标签 end -->

<!-- Theme Color for Chrome, Firefox OS and Opera -->
<meta name="theme-color" content="#4285f4">

<!-- Windows Phone -->
<meta name="msapplication-navbutton-color" content="#4285f4">

<!-- Security -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
<meta http-equiv="X-Content-Type-Options" content="nosniff">

<!-- PWA -->
<link rel="manifest" href="/manifest.json">
<meta name="mobile-web-app-capable" content="yes">

<!-- Favicon -->
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">

<!-- DNS Prefetch -->
<link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="dns-prefetch" href="//www.google-analytics.com">

<!-- Preconnect -->
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
```

### link

```html
<!-- iOS 图标 begin -->
<link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-57x57-precomposed.png"/>
<!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"/>
<!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"/>
<!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->
<!-- iOS 图标 end -->

<!-- iOS 启动画面 begin -->
<link rel="apple-touch-startup-image" sizes="768x1004" href="/splash-screen-768x1004.png"/>
<!-- iPad 竖屏 768 x 1004（标准分辨率） -->
<link rel="apple-touch-startup-image" sizes="1536x2008" href="/splash-screen-1536x2008.png"/>
<!-- iPad 竖屏 1536x2008（Retina） -->
<link rel="apple-touch-startup-image" sizes="1024x748" href="/Default-Portrait-1024x748.png"/>
<!-- iPad 横屏 1024x748（标准分辨率） -->
<link rel="apple-touch-startup-image" sizes="2048x1496" href="/splash-screen-2048x1496.png"/>
<!-- iPad 横屏 2048x1496（Retina） -->

<link rel="apple-touch-startup-image" href="/splash-screen-320x480.png"/>
<!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) -->
<link rel="apple-touch-startup-image" sizes="640x960" href="/splash-screen-640x960.png"/>
<!-- iPhone/iPod Touch 竖屏 640x960 (Retina) -->
<link rel="apple-touch-startup-image" sizes="640x1136" href="/splash-screen-640x1136.png"/>
<!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) -->
<!-- iOS 启动画面 end -->
```


---
url: /note/html/entity.md
---

# HTML Entity

## ASCII Characters (Printable)

인쇄 가능한 문자만 표시되며 제어 문자(0-31)는 시각적 표현이 없으므로 HTML 페이지에 있어서는 안 됩니다.

| Character | Entity Name | Entity Number |         Description          |
| :-------: | :---------: | :-----------: | :--------------------------: |
|           |             |   &amp;#32;   |            Space             |
|     !     |             |   &amp;#33;   |       Exclamation mark       |
|     "     |             |   &amp;#34;   |        Quotation mark        |
|     #     |             |   &amp;#35;   |         Number sign          |
|     $     |             |   &amp;#36;   |         Dollar sign          |
|     %     |             |   &amp;#37;   |         Percent sign         |
|   &amp;   |  &amp;amp;  |   &amp;#38;   |          Ampersand           |
|     '     |             |   &amp;#39;   |          Apostrophe          |
|     (     |             |   &amp;#40;   |   Opening/Left Parenthesis   |
|     )     |             |   &amp;#41;   |  Closing/Right Parenthesis   |
|    \*     |             |   &amp;#42;   |           Asterisk           |
|     +     |             |   &amp;#43;   |          Plus sign           |
|     ,     |             |   &amp;#44;   |            Comma             |
|     -     |             |   &amp;#45;   |            Hyphen            |
|     .     |             |   &amp;#46;   |            Period            |
|     /     |             |   &amp;#47;   |            Slash             |
|     0     |             |   &amp;#48;   |           Digit 0            |
|     1     |             |   &amp;#49;   |           Digit 1            |
|     2     |             |   &amp;#50;   |           Digit 2            |
|     3     |             |   &amp;#51;   |           Digit 3            |
|     4     |             |   &amp;#52;   |           Digit 4            |
|     5     |             |   &amp;#53;   |           Digit 5            |
|     6     |             |   &amp;#54;   |           Digit 6            |
|     7     |             |   &amp;#55;   |           Digit 7            |
|     8     |             |   &amp;#56;   |           Digit 8            |
|     9     |             |   &amp;#57;   |           Digit 9            |
|     :     |             |   &amp;#58;   |            Colon             |
|     ;     |             |   &amp;#59;   |          Semicolon           |
|   &lt;    |  &amp;lt;   |   &amp;#60;   |          Less-than           |
|     =     |             |   &amp;#61;   |         Equals sign          |
|   &gt;    |  &amp;gt;   |   &amp;#62;   |         Greater than         |
|     ?     |             |   &amp;#63;   |        Question mark         |
|     @     |             |   &amp;#64;   |           At sign            |
|     A     |             |   &amp;#65;   |         Uppercase A          |
|     B     |             |   &amp;#66;   |         Uppercase B          |
|     C     |             |   &amp;#67;   |         Uppercase C          |
|     D     |             |   &amp;#68;   |         Uppercase D          |
|     E     |             |   &amp;#69;   |         Uppercase E          |
|     F     |             |   &amp;#70;   |         Uppercase F          |
|     G     |             |   &amp;#71;   |         Uppercase G          |
|     H     |             |   &amp;#72;   |         Uppercase H          |
|     I     |             |   &amp;#73;   |         Uppercase I          |
|     J     |             |   &amp;#74;   |         Uppercase J          |
|     K     |             |   &amp;#75;   |         Uppercase K          |
|     L     |             |   &amp;#76;   |         Uppercase L          |
|     M     |             |   &amp;#77;   |         Uppercase M          |
|     N     |             |   &amp;#78;   |         Uppercase N          |
|     O     |             |   &amp;#79;   |         Uppercase O          |
|     P     |             |   &amp;#80;   |         Uppercase P          |
|     Q     |             |   &amp;#81;   |         Uppercase Q          |
|     R     |             |   &amp;#82;   |         Uppercase R          |
|     S     |             |   &amp;#83;   |         Uppercase S          |
|     T     |             |   &amp;#84;   |         Uppercase T          |
|     U     |             |   &amp;#85;   |         Uppercase U          |
|     V     |             |   &amp;#86;   |         Uppercase V          |
|     W     |             |   &amp;#87;   |         Uppercase W          |
|     X     |             |   &amp;#88;   |         Uppercase X          |
|     Y     |             |   &amp;#89;   |         Uppercase Y          |
|     Z     |             |   &amp;#90;   |         Uppercase Z          |
|     [     |             |   &amp;#91;   | Opening/Left square bracket  |
|    \      |             |   &amp;#92;   |          Backslash           |
|     ]     |             |   &amp;#93;   | Closing/Right square bracket |
|     ^     |             |   &amp;#94;   |            Caret             |
|    \_     |             |   &amp;#95;   |          Underscore          |
|     `     |             |   &amp;#96;   |         Grave accent         |
|     a     |             |   &amp;#97;   |         Lowercase a          |
|     b     |             |   &amp;#98;   |         Lowercase b          |
|     c     |             |   &amp;#99;   |         Lowercase c          |
|     d     |             |  &amp;#100;   |         Lowercase d          |
|     e     |             |  &amp;#101;   |         Lowercase e          |
|     f     |             |  &amp;#102;   |         Lowercase f          |
|     g     |             |  &amp;#103;   |         Lowercase g          |
|     h     |             |  &amp;#104;   |         Lowercase h          |
|     i     |             |  &amp;#105;   |         Lowercase i          |
|     j     |             |  &amp;#106;   |         Lowercase j          |
|     k     |             |  &amp;#107;   |         Lowercase k          |
|     l     |             |  &amp;#108;   |         Lowercase l          |
|     m     |             |  &amp;#109;   |         Lowercase m          |
|     n     |             |  &amp;#110;   |         Lowercase n          |
|     o     |             |  &amp;#111;   |         Lowercase o          |
|     p     |             |  &amp;#112;   |         Lowercase p          |
|     q     |             |  &amp;#113;   |         Lowercase q          |
|     r     |             |  &amp;#114;   |         Lowercase r          |
|     s     |             |  &amp;#115;   |         Lowercase s          |
|     t     |             |  &amp;#116;   |         Lowercase t          |
|     u     |             |  &amp;#117;   |         Lowercase u          |
|     v     |             |  &amp;#118;   |         Lowercase v          |
|     w     |             |  &amp;#119;   |         Lowercase w          |
|     x     |             |  &amp;#120;   |         Lowercase x          |
|     y     |             |  &amp;#121;   |         Lowercase y          |
|     z     |             |  &amp;#122;   |         Lowercase z          |
|     {     |             |  &amp;#123;   |   Opening/Left curly brace   |
|    \|     |             |  &amp;#124;   |         Vertical bar         |
|     }     |             |  &amp;#125;   |  Closing/Right curly brace   |
|     ~     |             |  &amp;#126;   |            Tilde             |

## ISO 8859-1 Characters

지원되는 ISO-8859-1 문자의 전체 목록 이름은 대소문자를 구분하므로 대문자를 원할 경우 이름도 대문자로 시작해야 합니다.

| Character | Entity Name | Entity Number |         Description          |
| :-------: | :---------: | :-----------: | :--------------------------: |
|           |             |   &amp;#32;   |            Space             |
|     !     |             |   &amp;#33;   |       Exclamation mark       |
|     "     |             |   &amp;#34;   |        Quotation mark        |
|     #     |             |   &amp;#35;   |         Number sign          |
|     $     |             |   &amp;#36;   |         Dollar sign          |
|     %     |             |   &amp;#37;   |         Percent sign         |
|   &amp;   |  &amp;amp;  |   &amp;#38;   |          Ampersand           |
|     '     |             |   &amp;#39;   |          Apostrophe          |
|     (     |             |   &amp;#40;   |   Opening/Left Parenthesis   |
|     )     |             |   &amp;#41;   |  Closing/Right Parenthesis   |
|    \*     |             |   &amp;#42;   |           Asterisk           |
|     +     |             |   &amp;#43;   |          Plus sign           |
|     ,     |             |   &amp;#44;   |            Comma             |
|     -     |             |   &amp;#45;   |            Hyphen            |
|     .     |             |   &amp;#46;   |            Period            |
|     /     |             |   &amp;#47;   |            Slash             |
|     0     |             |   &amp;#48;   |           Digit 0            |
|     1     |             |   &amp;#49;   |           Digit 1            |
|     2     |             |   &amp;#50;   |           Digit 2            |
|     3     |             |   &amp;#51;   |           Digit 3            |
|     4     |             |   &amp;#52;   |           Digit 4            |
|     5     |             |   &amp;#53;   |           Digit 5            |
|     6     |             |   &amp;#54;   |           Digit 6            |
|     7     |             |   &amp;#55;   |           Digit 7            |
|     8     |             |   &amp;#56;   |           Digit 8            |
|     9     |             |   &amp;#57;   |           Digit 9            |
|     :     |             |   &amp;#58;   |            Colon             |
|     ;     |             |   &amp;#59;   |          Semicolon           |
|   &lt;    |  &amp;lt;   |   &amp;#60;   |          Less-than           |
|     =     |             |   &amp;#61;   |         Equals sign          |
|   &gt;    |  &amp;gt;   |   &amp;#62;   |         Greater than         |
|     ?     |             |   &amp;#63;   |        Question mark         |
|     @     |             |   &amp;#64;   |           At sign            |
|     A     |             |   &amp;#65;   |         Uppercase A          |
|     B     |             |   &amp;#66;   |         Uppercase B          |
|     C     |             |   &amp;#67;   |         Uppercase C          |
|     D     |             |   &amp;#68;   |         Uppercase D          |
|     E     |             |   &amp;#69;   |         Uppercase E          |
|     F     |             |   &amp;#70;   |         Uppercase F          |
|     G     |             |   &amp;#71;   |         Uppercase G          |
|     H     |             |   &amp;#72;   |         Uppercase H          |
|     I     |             |   &amp;#73;   |         Uppercase I          |
|     J     |             |   &amp;#74;   |         Uppercase J          |
|     K     |             |   &amp;#75;   |         Uppercase K          |
|     L     |             |   &amp;#76;   |         Uppercase L          |
|     M     |             |   &amp;#77;   |         Uppercase M          |
|     N     |             |   &amp;#78;   |         Uppercase N          |
|     O     |             |   &amp;#79;   |         Uppercase O          |
|     P     |             |   &amp;#80;   |         Uppercase P          |
|     Q     |             |   &amp;#81;   |         Uppercase Q          |
|     R     |             |   &amp;#82;   |         Uppercase R          |
|     S     |             |   &amp;#83;   |         Uppercase S          |
|     T     |             |   &amp;#84;   |         Uppercase T          |
|     U     |             |   &amp;#85;   |         Uppercase U          |
|     V     |             |   &amp;#86;   |         Uppercase V          |
|     W     |             |   &amp;#87;   |         Uppercase W          |
|     X     |             |   &amp;#88;   |         Uppercase X          |
|     Y     |             |   &amp;#89;   |         Uppercase Y          |
|     Z     |             |   &amp;#90;   |         Uppercase Z          |
|     [     |             |   &amp;#91;   | Opening/Left square bracket  |
|    \      |             |   &amp;#92;   |          Backslash           |
|     ]     |             |   &amp;#93;   | Closing/Right square bracket |
|     ^     |             |   &amp;#94;   |            Caret             |
|    \_     |             |   &amp;#95;   |          Underscore          |
|     `     |             |   &amp;#96;   |         Grave accent         |
|     a     |             |   &amp;#97;   |         Lowercase a          |
|     b     |             |   &amp;#98;   |         Lowercase b          |
|     c     |             |   &amp;#99;   |         Lowercase c          |
|     d     |             |  &amp;#100;   |         Lowercase d          |
|     e     |             |  &amp;#101;   |         Lowercase e          |
|     f     |             |  &amp;#102;   |         Lowercase f          |
|     g     |             |  &amp;#103;   |         Lowercase g          |
|     h     |             |  &amp;#104;   |         Lowercase h          |
|     i     |             |  &amp;#105;   |         Lowercase i          |
|     j     |             |  &amp;#106;   |         Lowercase j          |
|     k     |             |  &amp;#107;   |         Lowercase k          |
|     l     |             |  &amp;#108;   |         Lowercase l          |
|     m     |             |  &amp;#109;   |         Lowercase m          |
|     n     |             |  &amp;#110;   |         Lowercase n          |
|     o     |             |  &amp;#111;   |         Lowercase o          |
|     p     |             |  &amp;#112;   |         Lowercase p          |
|     q     |             |  &amp;#113;   |         Lowercase q          |
|     r     |             |  &amp;#114;   |         Lowercase r          |
|     s     |             |  &amp;#115;   |         Lowercase s          |
|     t     |             |  &amp;#116;   |         Lowercase t          |
|     u     |             |  &amp;#117;   |         Lowercase u          |
|     v     |             |  &amp;#118;   |         Lowercase v          |
|     w     |             |  &amp;#119;   |         Lowercase w          |
|     x     |             |  &amp;#120;   |         Lowercase x          |
|     y     |             |  &amp;#121;   |         Lowercase y          |
|     z     |             |  &amp;#122;   |         Lowercase z          |
|     {     |             |  &amp;#123;   |   Opening/Left curly brace   |
|    \|     |             |  &amp;#124;   |         Vertical bar         |
|     }     |             |  &amp;#125;   |  Closing/Right curly brace   |
|     ~     |             |  &amp;#126;   |            Tilde             |

## ISO-8859-1 Symbols

HTML에서 지원되는 ISO-8859-1 기호의 전체 목록입니다.

| Symbol | Entity Name  | Entity Number |            Description             |
| :----: | :----------: | :-----------: | :--------------------------------: |
|        |  &amp;nbsp;  |  &amp;#160;   |         Non-breaking space         |
|   ¡    | &amp;iexcl;  |  &amp;#161;   |     Inverted exclamation mark      |
|   ¢    |  &amp;cent;  |  &amp;#162;   |                Cent                |
|   £    | &amp;pound;  |  &amp;#163;   |               Pound                |
|   ¤    | &amp;curren; |  &amp;#164;   |              Currency              |
|   ¥    |  &amp;yen;   |  &amp;#165;   |                Yen                 |
|   ¦    | &amp;brvbar; |  &amp;#166;   |        Broken vertical bar         |
|   §    |  &amp;sect;  |  &amp;#167;   |              Section               |
|   ¨    |  &amp;uml;   |  &amp;#168;   |         Spacing diaeresis          |
|   ©    |  &amp;copy;  |  &amp;#169;   |             Copyright              |
|   ª    |  &amp;ordf;  |  &amp;#170;   |     Feminine ordinal indicator     |
|   «    | &amp;laquo;  |  &amp;#171;   | Opening/Left angle quotation mark  |
|   ¬    |  &amp;not;   |  &amp;#172;   |              Negation              |
|   ­    |  &amp;shy;   |  &amp;#173;   |            Soft hyphen             |
|   ®    |  &amp;reg;   |  &amp;#174;   |        Registered trademark        |
|   ¯    |  &amp;macr;  |  &amp;#175;   |           Spacing macron           |
|   °    |  &amp;deg;   |  &amp;#176;   |               Degree               |
|   ±    | &amp;plusmn; |  &amp;#177;   |           Plus or minus            |
|   ²    |  &amp;sup2;  |  &amp;#178;   |           Superscript 2            |
|   ³    |  &amp;sup3;  |  &amp;#179;   |           Superscript 3            |
|   ´    | &amp;acute;  |  &amp;#180;   |           Spacing acute            |
|   µ    | &amp;micro;  |  &amp;#181;   |               Micro                |
|   ¶    |  &amp;para;  |  &amp;#182;   |             Paragraph              |
|   ¸    | &amp;cedil;  |  &amp;#184;   |          Spacing cedilla           |
|   ¹    |  &amp;sup1;  |  &amp;#185;   |           Superscript 1            |
|   º    |  &amp;ordm;  |  &amp;#186;   |    Masculine ordinal indicator     |
|   »    | &amp;raquo;  |  &amp;#187;   | Closing/Right angle quotation mark |
|   ¼    | &amp;frac14; |  &amp;#188;   |            Fraction 1/4            |
|   ½    | &amp;frac12; |  &amp;#189;   |            Fraction 1/2            |
|   ¾    | &amp;frac34; |  &amp;#190;   |            Fraction 3/4            |
|   ¿    | &amp;iquest; |  &amp;#191;   |       Inverted question mark       |
|   ×    | &amp;times;  |  &amp;#215;   |           Multiplication           |
|   ÷    | &amp;divide; |  &amp;#247;   |               Divide               |

## Math Symbols

HTML에서 지원되는 모든 수학 기호의 전체 목록입니다.

| Symbol | Entity Name  | Entity Number |    Description    |
| :----: | :----------: | :-----------: | :---------------: |
|   ∀    | &amp;forall; |  &amp;#8704;  |      For all      |
|   ∂    |  &amp;part;  |  &amp;#8706;  |       Part        |
|   ∃    | &amp;exist;  |  &amp;#8707;  |       Exist       |
|   ∅    | &amp;empty;  |  &amp;#8709;  |       Empty       |
|   ∇    | &amp;nabla;  |  &amp;#8711;  |       Nabla       |
|   ∈    |  &amp;isin;  |  &amp;#8712;  |       Is in       |
|   ∉    | &amp;notin;  |  &amp;#8713;  |      Not in       |
|   ∋    |   &amp;ni;   |  &amp;#8715;  |        Ni         |
|   ∏    |  &amp;prod;  |  &amp;#8719;  |      Product      |
|   ∑    |  &amp;sum;   |  &amp;#8721;  |        Sum        |
|   −    | &amp;minus;  |  &amp;#8722;  |       Minus       |
|   ∗    | &amp;lowast; |  &amp;#8727;  | Asterisk (Lowast) |
|   √    | &amp;radic;  |  &amp;#8730;  |    Square root    |
|   ∝    |  &amp;prop;  |  &amp;#8733;  |  Proportional to  |
|   ∞    | &amp;infin;  |  &amp;#8734;  |     Infinity      |
|   ∠    |  &amp;ang;   |  &amp;#8736;  |       Angle       |
|   ∧    |  &amp;and;   |  &amp;#8743;  |        And        |
|   ∨    |   &amp;or;   |  &amp;#8744;  |        Or         |
|   ∩    |  &amp;cap;   |  &amp;#8745;  |        Cap        |
|   ∪    |  &amp;cup;   |  &amp;#8746;  |        Cup        |
|   ∫    |  &amp;int;   |  &amp;#8747;  |     Integral      |
|   ∴    | &amp;there4; |  &amp;#8756;  |     Therefore     |
|   ∼    |  &amp;sim;   |  &amp;#8764;  |    Similar to     |
|   ≅    |  &amp;cong;  |  &amp;#8773;  |   Congurent to    |
|   ≈    | &amp;asymp;  |  &amp;#8776;  |   Almost equal    |
|   ≠    |   &amp;ne;   |  &amp;#8800;  |     Not equal     |
|   ≡    | &amp;equiv;  |  &amp;#8801;  |    Equivalent     |
|   ≤    |   &amp;le;   |  &amp;#8804;  |   Less or equal   |
|   ≥    |   &amp;ge;   |  &amp;#8805;  | Greater or equal  |
|   ⊂    |  &amp;sub;   |  &amp;#8834;  |     Subset of     |
|   ⊃    |  &amp;sup;   |  &amp;#8835;  |    Superset of    |
|   ⊄    |  &amp;nsub;  |  &amp;#8836;  |   Not subset of   |
|   ⊆    |  &amp;sube;  |  &amp;#8838;  |  Subset or equal  |
|   ⊇    |  &amp;supe;  |  &amp;#8839;  | Superset or equal |
|   ⊕    | &amp;oplus;  |  &amp;#8853;  |   Circled plus    |
|   ⊗    | &amp;otimes; |  &amp;#8855;  |   Circled times   |
|   ⊥    |  &amp;perp;  |  &amp;#8869;  |   Perpendicular   |
|   ⋅    |  &amp;sdot;  |  &amp;#8901;  |   Dot operator    |

## Greek Letters

HTML에서 지원되는 모든 그리스 문자의 전체 목록입니다.

| Letter |  Entity Name   | Entity Number |  Description   |
| :----: | :------------: | :-----------: | :------------: |
|   Α    |  &amp;Alpha;   |  &amp;#913;   |     Alpha      |
|   Β    |   &amp;Beta;   |  &amp;#914;   |      Beta      |
|   Γ    |  &amp;Gamma;   |  &amp;#915;   |     Gamma      |
|   Δ    |  &amp;Delta;   |  &amp;#916;   |     Delta      |
|   Ε    | &amp;Epsilon;  |  &amp;#917;   |    Epsilon     |
|   Ζ    |   &amp;Zeta;   |  &amp;#918;   |      Zeta      |
|   Η    |   &amp;Eta;    |  &amp;#919;   |      Eta       |
|   Θ    |  &amp;Theta;   |  &amp;#920;   |     Theta      |
|   Ι    |   &amp;Iota;   |  &amp;#921;   |      Iota      |
|   Κ    |  &amp;Kappa;   |  &amp;#922;   |     Kappa      |
|   Λ    |  &amp;Lambda;  |  &amp;#923;   |     Lambda     |
|   Μ    |    &amp;Mu;    |  &amp;#924;   |       Mu       |
|   Ν    |    &amp;Nu;    |  &amp;#925;   |       Nu       |
|   Ξ    |    &amp;Xi;    |  &amp;#926;   |       Xi       |
|   Ο    | &amp;Omicron;  |  &amp;#927;   |    Omicron     |
|   Π    |    &amp;Pi;    |  &amp;#928;   |       Pi       |
|   Ρ    |   &amp;Rho;    |  &amp;#929;   |      Rho       |
|   Σ    |  &amp;Sigma;   |  &amp;#931;   |     Sigma      |
|   Τ    |   &amp;Tau;    |  &amp;#932;   |      Tau       |
|   Υ    | &amp;Upsilon;  |  &amp;#933;   |    Upsilon     |
|   Φ    |   &amp;Phi;    |  &amp;#934;   |      Phi       |
|   Χ    |   &amp;Chi;    |  &amp;#935;   |      Chi       |
|   Ψ    |   &amp;Psi;    |  &amp;#936;   |      Psi       |
|   Ω    |  &amp;Omega;   |  &amp;#937;   |     Omega      |
|   α    |  &amp;alpha;   |  &amp;#945;   |     alpha      |
|   β    |   &amp;beta;   |  &amp;#946;   |      beta      |
|   γ    |  &amp;gamma;   |  &amp;#947;   |     gamma      |
|   δ    |  &amp;delta;   |  &amp;#948;   |     delta      |
|   ε    | &amp;epsilon;  |  &amp;#949;   |    epsilon     |
|   ζ    |   &amp;zeta;   |  &amp;#950;   |      zeta      |
|   η    |   &amp;eta;    |  &amp;#951;   |      eta       |
|   θ    |  &amp;theta;   |  &amp;#952;   |     theta      |
|   ι    |   &amp;iota;   |  &amp;#953;   |      iota      |
|   κ    |  &amp;kappa;   |  &amp;#954;   |     kappa      |
|   λ    |  &amp;lambda;  |  &amp;#955;   |     lambda     |
|   μ    |    &amp;mu;    |  &amp;#956;   |       mu       |
|   ν    |    &amp;nu;    |  &amp;#957;   |       nu       |
|   ξ    |    &amp;xi;    |  &amp;#958;   |       xi       |
|   ο    | &amp;omicron;  |  &amp;#959;   |    omicron     |
|   π    |    &amp;pi;    |  &amp;#960;   |       pi       |
|   ρ    |   &amp;rho;    |  &amp;#961;   |      rho       |
|   ς    |  &amp;sigmaf;  |  &amp;#962;   |     sigmaf     |
|   σ    |  &amp;sigma;   |  &amp;#963;   |     sigma      |
|   τ    |   &amp;tau;    |  &amp;#964;   |      tau       |
|   υ    | &amp;upsilon;  |  &amp;#965;   |    upsilon     |
|   φ    |   &amp;phi;    |  &amp;#966;   |      phi       |
|   χ    |   &amp;chi;    |  &amp;#967;   |      chi       |
|   ψ    |   &amp;psi;    |  &amp;#968;   |      psi       |
|   ω    |  &amp;omega;   |  &amp;#969;   |     omega      |
|   ϑ    | &amp;thetasym; |  &amp;#977;   |  Theta symbol  |
|   ϒ    |  &amp;upsih;   |  &amp;#978;   | Upsilon symbol |
|   ϖ    |   &amp;piv;    |  &amp;#982;   |   Pi symbol    |

## Miscellaneous HTML entities

기타 HTML 엔터티 목록입니다.

| Symbol | Entity Name  | Entity Number |         Description          |
| :----: | :----------: | :-----------: | :--------------------------: |
|   Œ    | &amp;OElig;  |  &amp;#338;   |    Uppercase ligature OE     |
|   œ    | &amp;oelig;  |  &amp;#339;   |    Lowercase ligature OE     |
|   Š    | &amp;Scaron; |  &amp;#352;   |    Uppercase S with caron    |
|   š    | &amp;scaron; |  &amp;#353;   |    Lowercase S with caron    |
|   Ÿ    |  &amp;Yuml;  |  &amp;#376;   |    Capital Y with diaeres    |
|   ƒ    |  &amp;fnof;  |  &amp;#402;   |     Lowercase with hook      |
|   ˆ    |  &amp;circ;  |  &amp;#710;   |      Circumflex accent       |
|   ˜    | &amp;tilde;  |  &amp;#732;   |            Tilde             |
|        |  &amp;ensp;  |  &amp;#8194;  |           En space           |
|        |  &amp;emsp;  |  &amp;#8195;  |           Em space           |
|        | &amp;thinsp; |  &amp;#8201;  |          Thin space          |
|   ‌    |  &amp;zwnj;  |  &amp;#8204;  |    Zero width non-joiner     |
|   ‍    |  &amp;zwj;   |  &amp;#8205;  |      Zero width joiner       |
|   ‎    |  &amp;lrm;   |  &amp;#8206;  |      Left-to-right mark      |
|   ‏    |  &amp;rlm;   |  &amp;#8207;  |      Right-to-left mark      |
|   –    | &amp;ndash;  |  &amp;#8211;  |           En dash            |
|   —    | &amp;mdash;  |  &amp;#8212;  |           Em dash            |
|   ‘    | &amp;lsquo;  |  &amp;#8216;  |  Left single quotation mark  |
|   ’    | &amp;rsquo;  |  &amp;#8217;  | Right single quotation mark  |
|   ‚    | &amp;sbquo;  |  &amp;#8218;  | Single low-9 quotation mark  |
|   “    | &amp;ldquo;  |  &amp;#8220;  |  Left double quotation mark  |
|   ”    | &amp;rdquo;  |  &amp;#8221;  | Right double quotation mark  |
|   „    | &amp;bdquo;  |  &amp;#8222;  | Double low-9 quotation mark  |
|   †    | &amp;dagger; |  &amp;#8224;  |            Dagger            |
|   ‡    | &amp;Dagger; |  &amp;#8225;  |        Double dagger         |
|   •    |  &amp;bull;  |  &amp;#8226;  |            Bullet            |
|   …    | &amp;hellip; |  &amp;#8230;  |     Horizontal ellipsis      |
|   ‰    | &amp;permil; |  &amp;#8240;  |          Per mille           |
|   ′    | &amp;prime;  |  &amp;#8242;  |      Minutes (Degrees)       |
|   ″    | &amp;Prime;  |  &amp;#8243;  |      Seconds (Degrees)       |
|   ‹    | &amp;lsaquo; |  &amp;#8249;  | Single left angle quotation  |
|   ›    | &amp;rsaquo; |  &amp;#8250;  | Single right angle quotation |
|   ‾    | &amp;oline;  |  &amp;#8254;  |           Overline           |
|   €    |  &amp;euro;  |  &amp;#8364;  |             Euro             |
|   ™    | &amp;trade;  |  &amp;#8482;  |          Trademark           |
|   ←    |  &amp;larr;  |  &amp;#8592;  |          Left arrow          |
|   ↑    |  &amp;uarr;  |  &amp;#8593;  |           Up arrow           |
|   →    |  &amp;rarr;  |  &amp;#8594;  |         Right arrow          |
|   ↓    |  &amp;darr;  |  &amp;#8595;  |          Down arrow          |
|   ↔    |  &amp;harr;  |  &amp;#8596;  |       Left right arrow       |
|   ↵    | &amp;crarr;  |  &amp;#8629;  |    Carriage return arrow     |
|   ⌈    | &amp;lceil;  |  &amp;#8968;  |         Left ceiling         |
|   ⌉    | &amp;rceil;  |  &amp;#8969;  |        Right ceiling         |
|   ⌊    | &amp;lfloor; |  &amp;#8970;  |          Left floor          |
|   ⌋    | &amp;rfloor; |  &amp;#8971;  |         Right floor          |
|   ◊    |  &amp;loz;   |  &amp;#9674;  |           Lozenge            |
|   ♠    | &amp;spades; |  &amp;#9824;  |            Spade             |
|   ♣    | &amp;clubs;  |  &amp;#9827;  |             Club             |
|   ♥    | &amp;hearts; |  &amp;#9829;  |            Heart             |
|   ♦    | &amp;diams;  |  &amp;#9830;  |           Diamond            |



---
url: /note/html/indexedDB.md
---

# IndexedDB

### 特点

- 键值对储存。
- 异步
- 支持事物(transaction)
- 同源限制
- 储存空间大
- 支持二进制

### 基本概念

- 数据库：IDBDatabase 对象
- 对象仓库：IDBObjectStore 对象
- 索引： IDBIndex 对象
- 事务： IDBTransaction 对象
- 操作请求：IDBRequest 对象
- 指针： IDBCursor 对象
- 主键集合：IDBKeyRange 对象

### 打开数据库

```js
const request = window.indexedDB.open("dbname", 1);
// error事件表示打开数据库失败。
request.onerror = function (event) {
  console.log("数据库打开报错");
};
// success事件表示成功打开数据库。
request.onsuccess = function (event) {
  console.log(request.result);
  console.log("数据库打开成功");
};
// 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。
request.onupgradeneeded = function (event) {
  console.log(event.target.result);
};
```

### 新建数据库

```js
request.onupgradeneeded = function (event) {
  const db = event.target.result;
  const objectStore = db.createObjectStore("person", { keyPath: "id" });

  // 自动生成主键
  // const objectStore = db.createObjectStore('person', { autoIncrement: true });

  // 创建索引
  objectStore.createIndex("name", "name", { unique: false });
  objectStore.createIndex("email", "email", { unique: true });
};
```

### 新增数据

通过 objectStore 对象的 add()方法，向表格写入一条记录。

```js
function add() {
  var request = db
    .transaction(["person"], "readwrite")
    .objectStore("person")
    .add({ id: 1, name: "张三", age: 24, email: "zhangsan@example.com" });

  request.onsuccess = function (event) {
    console.log("数据写入成功");
  };

  request.onerror = function (event) {
    console.log("数据写入失败");
  };
}
```

### 读取数据

读取数据也是通过事务完成。 objectStore.get()方法用于读取数据，参数是主键的值。

```js
function read() {
  var transaction = db.transaction(["person"]);
  var objectStore = transaction.objectStore("person");
  var request = objectStore.get(1);

  request.onerror = function (event) {
    console.log("事务失败");
  };

  request.onsuccess = function (event) {
    if (request.result) {
      console.log(request.result);
    } else {
      console.log("未获得数据记录");
    }
  };
}
```

### 遍历数据

新建指针对象的 openCursor()方法是一个异步操作，所以要监听 success 事件。

```js
function readAll() {
  var objectStore = db.transaction("person").objectStore("person");

  objectStore.openCursor().onsuccess = function (event) {
    var cursor = event.target.result;

    if (cursor) {
      console.log(cursor);
      cursor.continue();
    } else {
      console.log("没有更多数据了！");
    }
  };
}
```

### 更新数据

put()方法自动更新了主键为 1 的记录。

```js
function update() {
  var request = db
    .transaction(["person"], "readwrite")
    .objectStore("person")
    .put({ id: 1, name: "李四", age: 35, email: "lisi@example.com" });

  request.onsuccess = function (event) {
    console.log("数据更新成功");
  };

  request.onerror = function (event) {
    console.log("数据更新失败");
  };
}
```

### 删除数据

IDBObjectStore.delete()方法用于删除记录。

```js
function remove() {
  var request = db.transaction(["person"], "readwrite").objectStore("person").delete(1);

  request.onsuccess = function (event) {
    console.log("数据删除成功");
  };
}
```

### 使用索引

```js
var transaction = db.transaction(["person"], "readonly");
var store = transaction.objectStore("person");
var index = store.index("name");
var request = index.get("李四");

request.onsuccess = function (e) {
  var result = e.target.result;
  if (result) {
    // ...
  } else {
    // ...
  }
};
```

### html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
  </head>

  <body>
    <div id="app">
      <button class="add">add</button>
      <button class="get">get</button>
      <button class="getall">getall</button>

      <button class="put">put</button>

      <button class="del">del</button>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.0.min.js"></script>
    <script>
      $(function () {
        let db;

        const request = window.indexedDB.open("dbname", 2);
        // error事件表示打开数据库失败。
        request.onerror = function (event) {
          console.log("数据库打开报错");
        };
        // success事件表示成功打开数据库。
        request.onsuccess = function (event) {
          db = request.result;
          console.log(request.result);
          console.log("数据库打开成功");
        };
        // 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。
        request.onupgradeneeded = function (event) {
          console.log(event.target.result);
          db = event.target.result;
          if (!db.objectStoreNames.contains("person")) {
            const objectStore = db.createObjectStore("person", { keyPath: "id" });
            objectStore.createIndex("name", "name", { unique: false });
            objectStore.createIndex("email", "email", { unique: true });
          }
          console.log(111);
        };

        $(".add").click(function () {
          let req = db
            .transaction(["person"], "readwrite")
            .objectStore("person")
            .add({ id: new Date().getTime(), name: "张三", age: 24, email: `${new Date().getTime()}+a@.com` });

          req.onsuccess = function (event) {
            console.log("数据写入成功");
          };

          req.onerror = function (event) {
            console.log("数据写入失败");
          };
        });

        $(".get").click(function () {
          var transaction = db.transaction(["person"]);
          var objectStore = transaction.objectStore("person");
          var req = objectStore.get(1);

          req.onerror = function (event) {
            console.log("事务失败");
          };

          req.onsuccess = function (event) {
            if (req.result) {
              console.log(req.result);
            } else {
              console.log("未获得数据记录");
            }
          };
        });

        $(".getall").click(function () {
          var objectStore = db.transaction(["person"], "readwrite").objectStore("person");

          objectStore.openCursor().onsuccess = function (event) {
            var cursor = event.target.result;

            if (cursor) {
              console.log(cursor);
              cursor.continue();
            } else {
              console.log("没有更多数据了！");
            }
          };
        });

        $(".put").click(function () {
          var req = db.transaction(["person"], "readwrite").objectStore("person").put({ id: 1, name: "李四" });

          req.onsuccess = function (event) {
            console.log("数据更新成功");
          };

          req.onerror = function (event) {
            console.log("数据更新失败");
          };
        });

        $(".del").click(function () {
          var req = db.transaction(["person"], "readwrite").objectStore("person").delete(1587451687741);

          req.onsuccess = function (event) {
            console.log("数据删除成功");
          };
        });
      });
    </script>
  </body>
</html>
```



---
url: /note/html/storage.md
---

# Web Storage

## localStorage, sessionStorage

```js
localStorage.setItem("myCat", "Tom");
localStorage.getItem("myCat");
localStorage.removeItem("myCat");
localStorage.clear();
```

## setItem 값 모니터링

```js
const orignalSetItem = localStorage.setItem;

localStorage.setItem = function (key, newValue) {
  let setItemEvent = new Event("setItemEvent");
  setItemEvent.value = localStorage.getItem(key); // 필요에 따라 사용.
  setItemEvent.newValue = newValue;
  setItemEvent.key = key;
  window.dispatchEvent(setItemEvent);
  orignalSetItem.apply(this, arguments);
};

window.addEventListener("setItemEvent", function (e) {
  console.log(e);
});
```

### cookie

```js
// 读取Cookie
document.cookie;

// 基本
document.cookie = "name=Raymond";
// 动态使用
document.cookie = "name=" + encodeURIComponent(name);
// 创建2个cookie
document.cookie = "name=Raymond";
document.cookie = "age=43";
// 设置过期
document.cookie = "name=Raymond; expires=Fri, 31 Dec 9999 23:59:59 GMT";
// 设置子域名访问
document.cookie = "name=Raymond; domail=app.guryong.cc";

// 删除Cookie 只需把时间设置为过去的时间
document.cookie = "name=Raymond; expires=Thu, 01 Jan 1970 00:00:00 GMT";
```



---
url: /note/html/tag.md
---

# Markup Tag

Elements
이 페이지는 태그를 사용해 만들 수 있는 모든 HTML 요소의 목록을 제공합니다. 필요로 하는 요소를 쉽게 찾을 수 있도록 기능별로 분류했으며, 각각의 요소 참조 페이지 사이드바에서는 사전 순으로 정렬된 목록도 확인할 수 있습니다.

## 메인 루트

| 요소 | 설명                                                                                                             |
| ---- | ---------------------------------------------------------------------------------------------------------------- |
| html | HTML 문서의 루트(최상위 요소)를 나타내므로 root 요소라고도 합니다. 다른 모든 요소는 이 요소의 자손이어야 합니다. |

## 문서 메타데이터

메타데이터는 스타일, 스크립트, 각종 소프트웨어검색 엔진, 브라우저 등의 탐색 및 렌더링을 도와줄 데이터 등 페이지에 대한 정보를 가집니다. 스타일과 스크립트 메타데이터는 페이지 안에서 정의할 수도 있고, 해당하는 정보를 가진 다른 파일로 링크할 수도 있습니다.

| 요소  | 설명                                                                                                                                                                                                                        |
| ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| base  | 문서의 모든 상대 URL에 사용할 기본 URL을 지정합니다. 문서에는 이러한 요소가 하나만 있을 수 있습니다.                                                                                                                        |
| head  | 제목 스크립트 및 스타일 시트와 같은 문서에 대한 기계 판독 가능 정보(메타데이터)를 포함합니다.                                                                                                                               |
| link  | 현재 문서와 외부 리소스 간의 관계를 지정합니다. 이 요소는 CSS에 연결하는 데 가장 일반적으로 사용되지만 무엇보다도 사이트 아이콘("favicon" 스타일 아이콘과 홈 화면용 아이콘 및 모바일 장치의 앱)을 설정하는 데도 사용됩니다. |
| meta  | base, link, script, style, title과 같은 다른 메타관련 요소로 나타낼 수 없는 메타데이터를 나타냅니다.                                                                                                                        |
| style | 문서 또는 문서의 일부에 대한 스타일 정보를 포함합니다. 이 요소를 포함하는 문서의 내용에 적용되는 CSS를 포함합니다                                                                                                           |
| title | browser의 제목 표시줄 또는 페이지의 탭에 표시되는 문서의 제목을 정의합니다. 텍스트만 포함합니다. 요소 내의 태그는 무시됩니다.                                                                                               |

## 섹션 루트

| 요소 | 설명                                                                           |
| ---- | ------------------------------------------------------------------------------ |
| body | HTML 문서의 내용을 나타냅니다. 문서에는 이러한 요소가 하나만 있을 수 있습니다. |

## 콘텐츠 섹션

콘텐츠 섹션 요소를 사용하면 문서 콘텐츠를 논리적 조각으로 구성할 수 있습니다. 섹션 요소를 사용하여 머리글 및 바닥글 탐색, 콘텐츠 섹션을 식별하는 머리글 요소를 포함하여 페이지 콘텐츠에 대한 광범위한 개요를 만듭니다.

| 요소                   | 설명                                                                                                                                                                                |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| address                | 가까운 HTML 요소의 사람, 단체, 조직 등에 대한 연락처 정보를 나타냅니다.                                                                                                             |
| article                | 문서, 페이지, 애플리케이션, 또는 사이트 안에서 독립적으로 구분해 배포하거나 재사용할 수 있는 구획을 나타냅니다. 사용 예제로 게시판과 블로그 글, 매거진이나 뉴스 기사 등이 있습니다. |
| aside                  | 문서의 주요 내용과 간접적으로만 연관된 부분을 나타냅니다. 주로 사이드바 혹은 콜아웃 박스로 표현합니다.                                                                              |
| footer                 | 가장 가까운 섹션 콘텐츠나 섹션 루트의 푸터를 나타냅니다. 푸터는 일반적으로 섹션의 작성자, 저작권 정보, 관련 문서 등의 내용을 담습니다.                                              |
| header                 | 소개 및 탐색에 도움을 주는 콘텐츠를 나타냅니다. 제목, 로고, 검색 폼, 작성자 이름 등의 요소도 포함할 수 있습니다.                                                                    |
| h1, h2, h3, h4, h5, h6 | 6단계의 구획 제목을 나타냅니다. 구획 단계는 h1이 가장 높고 h6은 가장 낮습니다.                                                                                                      |
| main                   | 문서 body의 주요 콘텐츠를 나타냅니다. 주요 콘텐츠 영역은 문서의 핵심 주제나 앱의 핵심 기능에 직접적으로 연결됐거나 확장하는 콘텐츠로 이루어집니다.                                  |
| nav                    | 문서의 부분 중 현재 페이지 내, 또는 다른 페이지로의 링크를 보여주는 구획을 나타냅니다. 자주 쓰이는 예제는 메뉴, 목차, 색인입니다.                                                   |
| section                | HTML 문서의 독립적인 구획을 나타내며, 더 적합한 의미를 가진 요소가 없을 때 사용합니다. 보통 `<section>`은 제목을 포함하지만, 항상 그런 것은 아닙니다.                               |

## 텍스트 콘텐츠

HTML 텍스트 콘텐츠를 사용하여 여는 body와 닫는 `</body>` 태그 사이의 블록이나 콘텐츠 구획을 정리할 수 있습니다. 해당 콘텐츠의 목적이나 구조 판별에 사용하므로 접근성과 SEO에 중요합니다.

| 요소       | 설명                                                                                                                                                                                                                             |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| blockquote | 안쪽의 텍스트가 긴 인용문임을 나타냅니다. 주로 들여쓰기를 한 것으로 그려집니다. 인용문의 출처 URL은 `cite` 속성으로, 출처 텍스트는 cite 요소로 제공할 수 있습니다.                                                               |
| dd         | 설명 목록(dl)에서 선행 용어(dt)에 대한 설명, 정의 또는 값을 제공합니다.                                                                                                                                                          |
| div        | 유동 콘텐츠의 일반 컨테이너입니다. CSS를 사용하여 어떤 식으로든 스타일을 지정할 때까지 콘텐츠나 레이아웃에 영향을 미치지 않습니다(예: 스타일이 직접 적용되거나 flexbox와 같은 일종의 레이아웃 모델이 적용됨) 부모 요소.          |
| dl         | 설명 목록을 나타냅니다. `<dl>`은 dt로 표기한 용어와 dd 요소로 표기한 설명 그룹의 목록을 감싸서 설명 목록을 생성합니다. 주로 용어사전 구현이나 메타데이터(키-값 쌍 목록)를 표시할 때 사용합니다.                                  |
| dt         | 설명 혹은 정의 리스트에서 용어를 나타냅니다. dl 요소 안에 위치해야 합니다. 보통 dd 요소가 뒤따르지만, 여러 개의 \<dt> 요소를 연속해 배치하면 바로 다음 dd 요소로 한꺼번에 서술할 수 있습니다.                                    |
| figcaption | 부모 figure 요소가 포함하는 다른 콘텐츠에 대한 설명 혹은 범례를 나타냅니다.                                                                                                                                                      |
| figure     | 독립적인 콘텐츠를 표현합니다. figcaption 요소를 사용해 설명을 붙일 수 있습니다. 피규어, 설명, 콘텐츠는 하나의 단위로 참조됩니다.                                                                                                 |
| hr         | 이야기 장면 전환, 구획 내 주제 변경 등, 문단 레벨 요소에서 주제의 분리를 나타냅니다.                                                                                                                                             |
| li         | 목록의 항목을 나타냅니다. 반드시 정렬 목록(ol), 비정렬 목록 ul, 혹은 메뉴(menu) 안에 위치해야 합니다. 메뉴와 비정렬 목록에서는 보통 불릿으로 항목을 나타내고, 정렬 목록에서는 숫자나 문자를 사용한 오름차순 카운터로 나타냅니다. |
| menu       | 사용자가 수행하거나 하는 명령 묶음을 말합니다. 이것은 스크린 위에 나오는 목록 메뉴와 눌려진 버튼 아래에 나오는 것과 같은 맥락 메뉴를 포함합니다.                                                                                 |
| ol         | 정렬된 목록을 나타냅니다. 보통 숫자 목록으로 표현합니다.                                                                                                                                                                         |
| p          | 하나의 문단을 나타냅니다. 시각적인 매체에서, 문단은 보통 인접 블록과의 여백과 첫 줄의 들여쓰기로 구분하지만, HTML에서 문단은 이미지나 입력 폼 등 서로 관련있는 콘텐츠 무엇이나 될 수 있습니다.                                   |
| pre        | 미리 서식을 지정한 텍스트를 나타내며, HTML에 작성한 내용 그대로 표현합니다. 텍스트는 보통 고정폭 글꼴을 사용해 렌더링하고, 요소 내 공백문자를 그대로 유지합니다.                                                                 |
| ul         | 정렬되지 않은 목록을 나타냅니다. 보통 불릿으로 표현합니다.                                                                                                                                                                       |

## 인라인 텍스트 시멘틱

HTML 인라인 텍스트 시멘틱을 사용해서 단어, 줄, 혹은 아무 부분의 의미나 구조, 스타일을 정의할 수 있습니다.

| 요소   | 설명                                                                                                                                                                                                                                                                                                                                                                         |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| a      | `href` 특성을 통해 다른 페이지나 같은 페이지의 어느 위치, 파일, 이메일 주소와 그 외 다른 URL로 연결할 수 있는 하이퍼링크를 만듭니다. `<a>` 안의 콘텐츠는 링크 목적지의 설명을 **나타내야 합니다**.                                                                                                                                                                           |
| abbr   | 준말 또는 머리글자를 나타냅니다. 선택 속성인 `title`을 사용하면 준말의 전체 뜻이나 설명을 제공할 수 있습니다. `title` 속성은 전체 설명만을 가져야 하며 다른건 포함할 수 없습니다.                                                                                                                                                                                            |
| b      | 독자의 주의를 요소의 콘텐츠로 끌기 위한 용도로 사용합니다. 그 외의 다른 특별한 중요도는 주어지지 않습니다. 원래는 "굵은 글씨 요소"로 불렸으며, 대부분의 브라우저도 여전히 텍스트를 굵은 글씨체로 강조합니다. 그러나 `<b>`를 사용해 텍스트를 꾸미면 안됩니다. 대신 CSS font-weight를 사용해 굵은 글씨체를 적용하거나, strong 요소를 사용해 특별히 중요한 텍스트를 나타내세요. |
| bdi    | 포함된 텍스트를 주변 텍스트와 분리하여 처리하도록 브라우저의 양방향 알고리즘에 지시합니다. 웹 사이트가 일부 텍스트를 동적으로 삽입하고 삽입되는 텍스트의 방향성을 모를 때 특히 유용합니다.                                                                                                                                                                                   |
| bdo    | 현재 텍스트의 쓰기 방향을 덮어쓰고 다른 방향으로 렌더링 할 때 사용합니다.                                                                                                                                                                                                                                                                                                    |
| br     | 텍스트 안에 줄바꿈(캐리지 리턴)을 생성합니다. 주소나 시조 등 줄의 구분이 중요한 내용을 작성할 때 유용합니다.                                                                                                                                                                                                                                                                 |
| cite   | 저작물의 출처를 표기할 때 사용하며, 제목을 반드시 포함해야 합니다. 적절한 맥락 아래에서는 출처를 축약해서 표기할 수 있습니다.                                                                                                                                                                                                                                                |
| code   | 짧은 코드 조각을 나타내는 스타일을 사용해 자신의 콘텐츠를 표시합니다. 기본 스타일은 사용자 에이전트의 고정폭 글씨체입니다.                                                                                                                                                                                                                                                   |
| data   | 주어진 콘텐츠를 기계가 읽을 수 있는 해석본과 연결합니다. 콘텐츠가 시간 혹은 날짜 관련 정보라면 대신 time 요소를 사용하세요.                                                                                                                                                                                                                                                  |
| dfn    | 현재 맥락이나 문장에서 정의하고 있는 용어를 나타냅니다. `<dfn>`에서 가장 가까운 p, dt/dd 쌍, section 조상 요소를 용어 정의로 간주합니다.                                                                                                                                                                                                                                     |
| em     | 텍스트의 강세를 나타냅니다. `<em>` 요소를 중첩하면 더 큰 강세를 뜻하게 됩니다.                                                                                                                                                                                                                                                                                               |
| i      | 텍스트에서 어떤 이유로 주위와 구분해야 하는 부분을 나타냅니다. 기술 용어, 외국어 구절, 등장인물의 생각 등을 예시로 들 수 있습니다. 보통 기울임꼴로 표시합니다.                                                                                                                                                                                                               |
| kbd    | 키보드 입력, 음성 입력 등 임의의 장치를 사용한 사용자의 입력을 나타냅니다. 관례에 따라 사용자 에이전트의 고정폭 글꼴로 표시하지만, HTML 표준은 그런 점을 강제하지 않습니다.                                                                                                                                                                                                  |
| mark   | 현재 맥락에 관련이 깊거나 중요해 표시 또는 하이라이트한 부분을 나타냅니다.                                                                                                                                                                                                                                                                                                   |
| q      | 둘러싼 텍스트가 짧은 인라인 인용문이라는것을 나타냅니다. 대부분의 브라우저에서는 앞과 뒤에 따옴표를 붙여 표현합니다. `<q>`는 줄 바꿈이 없는 짧은 경우에 적합합니다. 긴 인용문은 blockquote 요소를 사용하세요.                                                                                                                                                                |
| rp     | ruby 요소를 사용한 루비 주석을 지원하지 않는 경우 보여줄 괄호를 제공할 때 사용합니다. rt 요소를 감싸는 여는 괄호와 닫는 괄호를 각각의 `<rp>` 요소로 나타내야 합니다.                                                                                                                                                                                                         |
| rt     | 동아시아 문자의 루비 주석에서 발음, 번역 등을 나타내는 텍스트 부분을 지정합니다.                                                                                                                                                                                                                                                                                             |
| ruby   | 루비 주석을 나타냅니다. 루비 주석은 동아시아 문자의 발음을 표기할 때 사용합니다.                                                                                                                                                                                                                                                                                             |
| s      | 글자에 취소선, 즉 글자를 가로지르는 선을 그립니다. `<s>` 요소를 사용해 이제 관계 없거나 더 이상 정확하지 않은 부분을 나타내세요. 그러나, `<s>`는 문서의 편집 기록을 나타내는 용도로는 적합하지 않습니다. 상황에 따라 del과 ins 요소를 대신 사용하세요.                                                                                                                       |
| samp   | 컴퓨터 프로그램 출력의 예시(혹은 인용문)를 나타냅니다. 보통 브라우저의 기본 고정폭 글씨체(보통 Courier, Lucida Console)를 사용해 렌더링합니다.                                                                                                                                                                                                                               |
| small  | 덧붙이는 글이나, 저작권과 법률 표기 등의 작은 텍스트를 나타냅니다. 기본 상태에서 `<small>`은 자신의 콘텐츠를 한 사이즈 작은 글꼴(`small`에서 `x-small` 등)로 표시하지만, 스타일을 적용한 후에도 글씨 크기가 작을 필요는 없습니다.                                                                                                                                            |
| span   | 구문 콘텐츠를 위한 통용 인라인 컨테이너로, 본질적으로는 아무것도 나타내지 않습니다. 스타일을 적용하기 위해서, 또는 `lang` 등 어떤 특성의 값을 서로 공유하는 요소를 묶을 때 사용할 수 있습니다. 적절한 의미를 가진 다른 요소가 없을 때에만 사용해야 합니다. `<span>`은 div와 매우 유사하지만, div는 블록 레벨 요소인 반면 `<span>`은 인라인 요소입니다.                       |
| strong | 중대하거나 긴급한 콘텐츠를 나타냅니다. 보통 브라우저는 굵은 글씨로 표시합니다.                                                                                                                                                                                                                                                                                               |
| sub    | 활자 배치를 아래 첨자로 해야 하는 인라인 텍스트를 지정합니다. 아래 첨자는 보통 더 작은 글씨 크기를 가지고, 기준선을 아래로 내려 렌더링 합니다.                                                                                                                                                                                                                               |
| sup    | 활자 배치를 위 첨자로 해야 하는 인라인 텍스트를 지정합니다. 위 첨자는 보통 더 작은 글씨 크기를 가지고, 기준선을 위로 올려 렌더링 합니다.                                                                                                                                                                                                                                     |
| time   | 시간의 특정 지점 또는 구간을 나타냅니다. `datetime` 특성의 값을 지정해 보다 적절한 검색 결과나, 알림 같은 특정 기능을 구현할 때 사용할 수 있습니다.                                                                                                                                                                                                                          |
| u      | 글자로 표현하지 않는 주석을 가진 것으로 렌더링 해야 하는 텍스트를 나타냅니다. 기본값에서는 단순한 밑줄로 표시하지만 CSS를 사용해 바꿀 수 있습니다.                                                                                                                                                                                                                           |
| var    | 수학 표현 또는 프로그래밍에서 변수의 이름을 나타냅니다. 보통 현재 글씨체의 기울임꼴로 표시하지만, 브라우저마다 다를 수 있습니다.                                                                                                                                                                                                                                             |
| wbr    | 현재 요소의 줄 바꿈 규칙을 무시하고 브라우저가 줄을 바꿀 수 있는 위치를 나타냅니다.                                                                                                                                                                                                                                                                                          |

## 이미지 & 멀티미디어

HTML은 사진, 오디오, 비디오 등 다양한 멀티미디어 리소스를 지원합니다..

| 요소  | 설명                                                                                                                                                                                                                                                 |
| ----- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| area  | 이미지의 핫스팟 영역을 정의하고 하이퍼링크를 추가할 수 있습니다. map 요소 안에서만 사용할 수 있습니다.                                                                                                                                               |
| audio | 문서에 소리 콘텐츠를 포함할 때 사용합니다. `src` 특성 또는 source 요소를 사용해 한 개 이상의 오디오 소스를 지정할 수 있으며, 다수를 지정한 경우 가장 적절한 소스를 브라우저가 고릅니다. MediaStream을 사용하면 미디어 스트림을 바라볼 수도 있습니다. |
| img   | 문서에 이미지를 넣습니다.                                                                                                                                                                                                                            |
| map   | area 요소와 함께 이미지 맵(클릭 가능한 링크 영역)을 정의할 때 사용합니다.                                                                                                                                                                            |
| track | 미디어 요소(audio, video)의 자식으로서, 자막 등 시간별 텍스트 트랙(시간 기반 데이터)를 지정할 때 사용합니다. 트랙은 WebVTT(Web Video Text Tracks, `.vtt` 파일) 또는 Timed Text Markup Language(TTML)형식을 사용해야 합니다.                          |
| video | 비디오 플레이백을 지원하는 미디어 플레이어를 문서에 삽입합니다. 오디오 콘텐츠에도 사용할 수 있으나, audio 요소가 사용자 경험에 좀 더 적합합니다.                                                                                                     |

## 내장 콘텐츠

HTML은 일반적인 멀티미디어 콘텐츠 외에도 다양한 종류의 기타 콘텐츠를 포함할 수 있습니다.

| 요소    | 설명                                                                                                                                                                                                                                                                                                                                      |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| embed   | 외부 어플리케이션이나 대화형 컨텐츠와의 통합점을 나타냅니다.                                                                                                                                                                                                                                                                              |
| iframe  | 중첩 브라우징 맥락을 나타내는 요소로, 현재 문서 안에 다른 HTML 페이지를 삽입합니다.                                                                                                                                                                                                                                                       |
| object  | 이미지나, 중첩된 브라우저 컨텍스트, 플러그인에 의해 다뤄질수 있는 리소스와 같은 외부 리소스를 나타냅니다.                                                                                                                                                                                                                                 |
| picture | 0개 이상의 source 요소와 하나의 img 요소를 포함하여 다양한 디스플레이/장치 시나리오에 대한 이미지의 대체 버전을 제공합니다.                                                                                                                                                                                                               |
| portal  | 새 페이지로의 원활한 탐색을 위해 다른 HTML 페이지를 현재 페이지에 포함할 수 있습니다.                                                                                                                                                                                                                                                     |
| source  | 그림, 오디오 요소 또는 비디오 요소에 대한 여러 미디어 리소스를 지정합니다. 이는 콘텐츠가 없고 닫는 태그가 없음을 의미하는 무효 요소입니다. 일반적으로 이미지 파일 형식과 미디어 파일 형식에 대한 서로 다른 지원을 제공하는 광범위한 브라우저와의 호환성을 제공하기 위해 여러 파일 형식으로 동일한 미디어 콘텐츠를 제공하는 데 사용됩니다. |

## SVG와 MathML

svg 및 math 요소를 사용하여 SVG 및 MathML 콘텐츠를 HTML 문서에 직접 삽입할 수 있습니다.

| 요소 | 설명                                                                                                                                                                                                       |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| svg  | 새 좌표계 및 뷰포트를 정의하는 컨테이너입니다. SVG 문서의 가장 바깥쪽 요소로 사용되지만 SVG 또는 HTML 문서 내부에 SVG 조각을 포함하는 데에도 사용할 수 있습니다.                                           |
| math | MathML의 최상위 요소입니다. 모든 유효한 MathML 인스턴스는 여기에 래핑되어야 합니다. 또한 두 번째 `<math>` 요소를 다른 요소에 중첩해서는 안 되지만 그 안에 임의의 수의 다른 자식 요소를 포함할 수 있습니다. |

## 스크립트

HTML은 동적인 콘텐츠와 웹 어플리케이션을 위해 스크립트 언어, 그 중에서도 주로 JavaScript를 지원합니다. 특정 요소가 이런 기능을 가지고 있습니다.

| 요소     | 설명                                                                                                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| canvas   | 캔버스 스크립팅 API 또는 WebGL API와 함께 사용해 그래픽과 애니메이션을 그릴 수 있습니다.                                                                                 |
| noscript | 페이지의 스크립트 유형을 지원하지 않거나, 브라우저가 스크립트를 비활성화한 경우 보여줄 HTML 구획을 정의합니다.                                                           |
| script   | 데이터와 실행 가능한 코드를 문서에 포함할 때 사용하며 보통 JavaScript 코드와 함께 씁니다. WebGL의 GLSL 셰이더 프로그래밍 언어, JSON 등 다른 언어와도 사용할 수 있습니다. |

## 수정사항 표시

텍스트의 특정 부분이 수정됐다는 것을 표시할 수 있습니다.

| 요소 | 설명                                                                                                                                                      |
| ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| del  | 문서에서 제거된 텍스트의 범위를 나타냅니다. 문서나 소스 코드의 변경점 추적 등에 사용할 수 있습니다. ins 요소를 추가된 텍스트의 범위를 나타낼 수 있습니다. |
| ins  | 문서에 추가된 텍스트의 범위를 나타냅니다. del 요소를 사용하면 삭제된 텍스트의 범위를 나타낼 수 있습니다.                                                  |

## 표 콘텐츠

표 형식의 데이터를 생성하고 처리할 때 사용합니다.

| 요소     | 설명                                                                                                                   |
| -------- | ---------------------------------------------------------------------------------------------------------------------- |
| caption  | 표의 설명 또는 제목을 나타냅니다.                                                                                      |
| col      | 표의 열을 나타내며, 열에 속하는 칸에 공통된 의미를 부여할 때 사용합니다. colgroup 안에서 찾을 수 있습니다.             |
| colgroup | 표의 열을 묶는 그룹을 정의합니다.                                                                                      |
| table    | 행과 열로 이루어진 표를 나타냅니다.                                                                                    |
| tbody    | 표의 여러 행(tr)을 묶어서 표 본문을 구성합니다.                                                                        |
| td       | 데이터를 포함하는 표의 셀을 정의합니다. 이것은 표 모델에 참여합니다.                                                   |
| tfoot    | 테이블의 열을 요약하는 행들의 집합입니다.                                                                              |
| th       | 테이블 셀 그룹의 헤더로 셀을 정의합니다. 이 그룹의 정확한 특성은 `scope` 및 `headers` 속성으로 정의됩니다.             |
| thead    | 테이블 열의 헤드를 정의하는 일련의 행을 정의합니다.                                                                    |
| tr       | 테이블의 셀 행을 정의합니다. 그런 다음 td(데이터 셀) 및 th(헤더 셀) 요소를 혼합하여 행의 셀을 설정할 수 있습니다.ents. |

## 양식

HTML은 여러가지 입력 가능한 요소를 제공합니다. 이런 요소를 서로 조합하면 사용자가 내용을 채우고, 웹사이트나 어플리케이션에 제출할 수 있습니다. HTML 폼 안내서에 더욱 다양한 내용이 있습니다.

| 요소     | 설명                                                                                                                                                                                                                                                                               |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| button   | 클릭 가능한 버튼을 나타냅니다. 버튼은 양식 내부는 물론 간단한 표준 버튼 기능이 필요한 곳이라면 문서 어디에나 배치할 수 있습니다. 기본값의 HTML 버튼은 사용자 에이전트의 호스트 플랫폼과 비슷한 디자인을 따라가지만, 외형은 CSS로 변경할 수 있습니다.                               |
| datalist | 다른 컨트롤에서 고를 수 있는 가능한, 혹은 추천하는 선택지를 나타내는 option 요소 여럿을 담습니다.                                                                                                                                                                                  |
| fieldset | 웹 양식의 여러 컨트롤과 레이블(label)을 묶을 때 사용합니다.                                                                                                                                                                                                                        |
| form     | 정보를 제출하기 위한 대화형 컨트롤을 포함하는 문서 구획을 나타냅니다.                                                                                                                                                                                                              |
| input    | 웹 기반 양식에서 사용자의 데이터를 받을 수 있는 대화형 컨트롤을 생성합니다. 사용자 에이전트에 따라서 다양한 종류의 입력 데이터 유형과 컨트롤 위젯이 존재합니다. 입력 유형과 특성의 다양한 조합 가능성으로 인해, `<input>` 요소는 HTML에서 제일 강력하고 복잡한 요소 중 하나입니다. |
| label    | 사용자 인터페이스 항목의 설명을 나타냅니다.                                                                                                                                                                                                                                        |
| legend   | 부모 fieldset 콘텐츠의 설명을 나타냅니다.                                                                                                                                                                                                                                          |
| meter    | 특정 범위 내에서의 스칼라 값, 또는 백분율 값을 나타냅니다.                                                                                                                                                                                                                         |
| optgroup | select 요소의 옵션을 묶을 수 있습니다.                                                                                                                                                                                                                                             |
| option   | select, optgroup, datalist 요소의 항목을 정의합니다. 그러므로, `<option>`을 사용해 팝업 메뉴 등 목록에서 하나의 항목을 나타낼 수 있습니다.                                                                                                                                         |
| output   | 웹 사이트나 앱에서 계산이나 사용자 행동의 결과를 삽입할 수 있는 컨테이너 요소입니다.                                                                                                                                                                                               |
| progress | 어느 작업의 완료 정도를 나타내며, 주로 진행 표시줄의 형태를 띕니다.                                                                                                                                                                                                                |
| select   | 옵션 메뉴를 제공하는 컨트롤을 나타냅니다.                                                                                                                                                                                                                                          |
| textarea | 멀티라인 일반 텍스트 편집 컨트롤을 나타냅니다.                                                                                                                                                                                                                                     |

## 대화형 요소

HTML은 상호작용 가능한 사용자 인터페이스 객체를 만들 때 사용할 수 있는 요소를 지원합니다.

| 요소    | 설명                                                                                                                                    |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| details | "열림" 상태일 때만 내부 정보를 보여주는 정보 공개 위젯을 생성합니다. 요약이나 레이블은 summary 요소를 통해 제공할 수 있습니다.          |
| dialog  | 닫을 수 있는 경고, 검사기, 창 등 대화 상자 및 기타 다른 상호작용 가능한 컴포넌트를 나타냅니다.                                          |
| summary | ("상세") 요소의 공개 상자에 대한 요약, 캡션 또는 범례를 지정한다. `<요약>` 요소를 클릭하면 부모 `<상세>` 요소의 상태가 열리거나 닫힌다. |

## 웹 컴포넌트

웹 컴포넌트는 완전히 새로운 형태의 요소를 생성한 후 일반적인 HTML처럼 사용할 수 있는 기술입니다. 또한 표준 HTML 요소의 맞춤 버전을 만들 수도 있습니다.

| 요소     | 설명                                                                                                                                            |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| slot     | 웹 컴포넌트 사용자가 자신만의 마크업으로 채워 별도의 DOM 트리를 생성하고, 컴포넌트와 함께 표현할 수 있는 웹 컴포넌트 내부의 플레이스홀더입니다. |
| template | 페이지를 불러온 순간 즉시 그려지지는 않지만, 이후 JavaScript를 사용해 인스턴스를 생성할 수 있는 HTML 코드를 담을 방법을 제공합니다.             |

## 폐기됐거나 사용하지 않는 요소들

> **경고:** 다음은 더 이상 사용하지 않고, 사용해서도 안되는 오래된 HTML 요소입니다. **새로운 프로젝트에서 절대 사용해서는 안되고, 오래된 프로젝트에서도 가능한 빨리 대체해야 합니다.** 아래 목록은 정보성 목적으로만 존재합니다.

| 요소      | 설명                                                                                                                                                                                                                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| acronym   | 작성자가 단어의 두문자어 또는 약어를 구성하는 일련의 문자를 명확하게 표시할 수 있습니다.                                                                                                                                                                                                                                             |
| applet    | 문서에 Java 애플릿을 포함합니다. 이 요소는 object를 위해 더 이상 사용되지 않습니다.                                                                                                                                                                                                                                                  |
| bgsound   | 페이지가 사용되는 동안 백그라운드에서 재생되도록 사운드 파일을 설정합니다. 대신 audio를 사용하세요.                                                                                                                                                                                                                                  |
| big       | 포함된 텍스트를 주변 텍스트보다 한 수준 더 큰 글꼴 크기로 렌더링합니다(예: 'medium'은 'large'가 됨). 크기는 브라우저의 최대 허용 글꼴 크기로 제한됩니다.                                                                                                                                                                             |
| center    | 포함하는 요소 내에서 수평 중앙에 블록 수준 또는 인라인 콘텐츠를 표시합니다.                                                                                                                                                                                                                                                          |
| content   | Web Components 기술 제품군의 구식 부분은 삽입 지점으로 Shadow DOM 내부에서 사용되었으며 일반 HTML에서는 사용되지 않았습니다. 이제 slot 요소로 대체되어 Shadow DOM을 삽입할 수 있는 DOM의 지점을 생성합니다.                                                                                                                          |
| dir       | 잠재적으로 사용자 에이전트에 의해 적용된 스타일 및 아이콘이 있는 파일 및/또는 폴더의 디렉토리에 대한 컨테이너입니다. 이 오래된 요소를 사용하지 마십시오. 대신 파일 목록을 포함하여 목록에 ul 요소를 사용해야 합니다.                                                                                                                 |
| font      | 콘텐츠의 글꼴 크기, 색상 및 면을 정의합니다.                                                                                                                                                                                                                                                                                         |
| frame     | 다른 HTML 문서를 표시할 수 있는 특정 영역을 정의합니다. 프레임은 frameset 내에서 사용해야 합니다.                                                                                                                                                                                                                                    |
| frameset  | frame 요소를 포함하는 데 사용됩니다.                                                                                                                                                                                                                                                                                                 |
| image     | img 요소에 대한 오래되고 제대로 지원되지 않는 전구체입니다. 사용해서는 안됩니다.                                                                                                                                                                                                                                                     |
| marquee   | 텍스트의 스크롤 영역을 삽입하는 데 사용됩니다. 속성을 사용하여 텍스트가 콘텐츠 영역의 가장자리에 도달할 때 발생하는 상황을 제어할 수 있습니다.                                                                                                                                                                                       |
| menuitem  | 사용자가 팝업 메뉴를 통해 호출할 수 있는 명령을 나타냅니다. 여기에는 상황에 맞는 메뉴와 메뉴 버튼에 연결될 수 있는 메뉴가 포함됩니다.                                                                                                                                                                                                |
| nobr      | 포함된 텍스트가 여러 줄에 걸쳐 자동으로 줄바꿈되지 않도록 방지하여 잠재적으로 사용자가 텍스트의 전체 너비를 보기 위해 가로로 스크롤해야 합니다.                                                                                                                                                                                      |
| noembed   | embed 요소를 지원하지 않거나 작성자가 사용하려는 embedded content 유형을 지원하지 않는 브라우저에 대한 대안 또는 "대체" 콘텐츠를 제공하는 더 이상 사용되지 않는 비표준 방식입니다. 이 요소는 object 요소의 여는 태그와 닫는 태그 사이에 대체 콘텐츠를 배치하기 위해 HTML 4.01 이상에서 더 이상 사용되지 않습니다.                    |
| noframes  | frame 요소를 지원하지 않거나 지원하지 않는 브라우저에 표시할 콘텐츠를 제공합니다. 가장 일반적으로 사용되는 브라우저는 프레임을 지원하지만 텍스트 모드 브라우저뿐만 아니라 일부 모바일 브라우저를 포함한 특정 특수 용도 브라우저를 포함하여 예외가 있습니다.                                                                          |
| param     | object 요소에 대한 매개변수를 정의합니다.                                                                                                                                                                                                                                                                                            |
| plaintext | object 요소의 매개변수를 정의합니다.                                                                                                                                                                                                                                                                                                 |
| rb        | ruby 주석의 기본 텍스트 구성 요소, 즉 주석이 추가되는 텍스트를 구분하는 데 사용됩니다. 하나의 `<rb>` 요소는 기본 텍스트의 각 개별 원자 세그먼트를 래핑해야 합니다.                                                                                                                                                                   |
| rtc       | ruby 표기의 기반 텍스트 구성요소(루비 주석을 적용하려는 글자)를 나눌 때 사용합니다. 하나의 `<rb>` 요소는 기반 텍스트에서의 최소 단위를 하나 감싸야 합니다.                                                                                                                                                                           |
| shadow    | rb 요소가 표시하는 문자의 의미에 대한 주석을 나타냅니다. `<rb>`는 발음(rt)과 의미(`<rtc>`) 둘 다 가질 수 있습니다.                                                                                                                                                                                                                   |
| spacer    | 페이지에 빈 공간을 삽입할 수 있습니다. 웹 디자이너가 실제로 이미지를 사용하지 않고 웹 페이지에 공백을 추가하는 데 사용했던 단일 픽셀 레이아웃 이미지와 동일한 효과를 달성하기 위해 Netscape가 고안했습니다. 그러나 `<spacer>`는 더 이상 주요 브라우저에서 지원되지 않으며 이제 간단한 CSS를 사용하여 동일한 효과를 얻을 수 있습니다. |
| strike    | 텍스트 위에 취소선(수평선)을 그립니다.                                                                                                                                                                                                                                                                                               |
| tt        | 사용자 에이전트 기본 모노스페이스 글꼴을 사용하여 표시되는 인라인 텍스트를 생성합니다. 이 요소는 텔레타이프, 텍스트 전용 화면 또는 라인 프린터와 같은 고정 너비 디스플레이에 표시되는 텍스트를 렌더링하기 위해 만들어졌습니다.                                                                                                       |
| xmp       | 시작 태그와 끝 태그 사이의 HTML을 해석하지 않고 고정 폭 글꼴을 사용하여 텍스트를 렌더링합니다. HTML2 사양에서는 한 줄에 80자를 허용할 만큼 충분히 넓게 렌더링해야 한다고 권장했습니다.                                                                                                                                               |



---
url: /note/performance/metric.md
---

# 关键性能指标

## 连接性能

### 延迟

延迟是指 IP 数据包从一个网络端点到另一个网络端点所话费的时间。与之相关的是往返延时(RTT - Rount-Trip Time), 它是延迟的时间的两倍。延迟是制约 Web 性能的主要瓶颈，尤其对于 HTTP 这样的协议，因为其中包含大量往返于服务器的请求

(一些移动设备为节省电力，可能暂时关闭移动数据信号。如果设备需要临时唤醒移动数据设备，建立新连接时还要增加数秒的延迟)

### 宽带

只要宽带没有饱和，两个网络端点之间的连接会一次处理尽可能多的数据量。依据 Web 页面饮用资源的大小和网络连接的传输能力，宽带可能会成为性能的瓶颈

### DNS 查询

在客户端能够获取 Web 页面钱，它需要通过域名系统把主机名称转换成 IP 地址，DNS 相当于互联网上的电话号码薄。获取的 HTML 页面中所引用；哦你给的各个不同余名也需要转换；幸运的事，一个域名只需转换一次

### 建立连接时间

在客户端和服务器之间建立连接需要往返数据应答， 成为‘三次握手’。

### TLS(Transport Layer Security)协商时间

如果客户端发起 HTTPS 连接，它需要进行 TLS 协商; TLS 用来取代 SSL(Secure Sockets Layer)。除了服务器和客户端的计算处理耗时之外，TLS 还会造成额外的往返传输

### 单点故障(SPOF - Single Point Of Failure)

Web 页面上引用的某个资源，如果它出问题，将延迟整个页面的加载(甚至导致页面出错)。

## 服务器或内容

### TTFB(Time To First Byte)

客户端从开始定位到 Web 页面，直接收到主体页面响应的第一字节所耗费的时间。它包含了之前连接性能各种耗时，还要加上服务器的处理时间。对于主体页面上的资源，TTFB 测量的是从浏览器发起请求至收到其第一字节之间的耗时。

### Content Download

等同于被请求资源的最后字节到达时间。

### 开始渲染时间(Time to First Meaningful Paint)

客户端的屏幕上什么时候开始现实内容？这个指标测量的是用户看到空白页面的时长

### 文档加载完成时间

这是客户端浏览器认为页面加载完毕的时间

## 额外考虑

- 更多的字节
- 更多的资源
- 更高的复杂度
- 更多的域名
- 更多的 TCP socket

## 网络

#### 减少 http 请求

- 合并 js

- 合并 css

- css sprite

- base64

#### 减少资源大小

- html, css, js minify
- gzip 压缩
- image minify
- 不滥用字体

#### 缓存

- DNS 缓存

```html
<link rel="dns-prefetch" href="//ajax.googleapis.com" />
```

- http 缓存(Cache-Control, E-tag)
- 部署 CDN
- 使用长缓存
- 避免重定向

- TCP 连接(参考: https://istlsfastyet.com/)

```html
<link rel="precontent" href="//fonts.google.com" crossorigin />
```

- 避免阻塞 CSS/JS

## 浏览器渲染

### DOM 优化

- 避免进行繁琐的 DOM 操作
- 复杂的 UI 元素, 设置 position 为 absolute 或者 fixed
- requestAnimationFrame 代替 setTimeout
- 适当使用 canvas
- 使用事件代理

### 样式优化

- 尽量避免内联样式
- 禁用 css Expression
- 尽量使用 css 动画

### html 优化

- css 文件放头部, js 放底部或者异步处理

### 图片优化

- Lazyload

### 异步

- 常用数据缓存



---
url: /note/performance/rail.md
---

# RAIL

RAIL(Response Animation Idle Load)의 성능의 핵심은 '사용자에게 초점을 맞추세요. 최종 목표는 사이트가 특정 장치에서 빠르게 작동하도록 만드는 것이 아니라 사용자를 행복하게 만드는 것'입니다.

## Response

100ms 이내에 사용자 입력을 승인하여 즉시 사용자에게 응답합니다.

## Animation

애니메이션을 적용할 때, 각 프레임을 16ms 미만으로 렌더링하여 일관성을 유지하고 버벅거림을 방지하세요.

## Idle

기본 JavaScript 스레드를 사용하는 경우, 50ms 미만의 시간 동안 청크로 작업하여 사용자 상호작용을 위한 스레드를 확보합니다.

## Load

5초 이내에 상호작용 가능한 콘텐츠를 제공합니다.

### 참고

- https://web.dev/articles/rail?hl=ko#focus_on_the_user



---
url: /note/react/hooks.md
---

# Hooks

### useState

```jsx
const App = () => {
  const [count, setCount] = useState(0);
  return <h1 onClick={() => setCount(count + 1)}>{count}</h1>;
};
```

### useReducer

```jsx
const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
    </>
  );
}
```

### useContext

```jsx
import { createContext, useContext } from "react";

const Context = createContext({ theme: "light" });

const Child = () => {
  const { theme } = useContext(Context);
  return <>{theme}</>;
};

const Parent = () => {
  return <Child />;
};

const App = () => {
  return (
    <Context.Provider value={{ theme: "dark" }}>
      <Parent />
    </Context.Provider>
  );
};

export default App;
```

## effect관련

### useEffect

```jsx
const App = () => {
  useEffect(() => {
    console.log(111);
  }, []);
  return <div>title</div>;
};
```

### useLayoutEffect

```jsx
const App = () => {
  useLayoutEffect(() => {
    console.log(111);
  }, []);
  return <div>title</div>;
};
```

### useInsertionEffect

```jsx
const App = () => {
  useInsertionEffect(() => {
    console.log(111);
  }, []);
  return <div>title</div>;
};
```

### useEffectEvent

```jsx

```

## ref관련

### useRef

```jsx
import { useRef, forwardRef } from "react";

const Child = forwardRef((props: any, ref: any) => {
  return <input ref={ref} />;
});

const Parent = () => {
  const inputRef = (useRef < HTMLInputElement) | (null > null);
  const onClick = () => {
    if (inputRef.current) {
      inputRef.current.value = "reset";
    }
  };
  return (
    <>
      <Child ref={inputRef} />
      <button onClick={onClick}>reset</button>
    </>
  );
};

const App = () => {
  return <Parent />;
};

export default App;
```

### useImperativeHandle

```jsx

```

## 성능관련

### useMemo

```jsx
const App = () => {
  const title = useMemo(() => "dao", []);
  return <div>{title}</div>;
};
```

### useCallback

```jsx
const App = () => {
  const setTitle = useCallback(() => {
    console.log(111);
  }, []);
  return (
    <button
      type="button"
      onClick={setTitle}
    >
      +
    </button>
  );
};
```

### useMemoCache

```jsx

```

## 디버깅관련

### useDebugValue

```jsx

```

## concurrent 동시성모드

### useTransition

```jsx
const App = () => {
  const [value, setValue] = useState("");
  const [isPending, startTransition] = useTransition();

  const onChange = (e: ChangeEvent<HTMLInputElement>) => {
    // 긴급처리건.
    setValue(e.target.value);
    startTransition(() => {
      // 후순위 처리.
      setContent(e.target.value);
    });
  };
  return (
    <>
      <input
        value={value}
        onChange={onChange}
      />
      <div>{value.length}</div>
    </>
  );
};
```

### useDeferredValue

```jsx
const App = () => {
  const [value, setValue] = useState("");
  const lowValue = useDeferredValue(value.length);

  const onChange = (e: ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  };

  return (
    <>
      <input
        value={value}
        onChange={onChange}
      />
      <div>{lowValue}</div>
    </>
  );
};
```

### useSyncExternalStore(useMutableSource)

```jsx
// todoStore.js
let nextId = 0;
let todos = [{ id: nextId++, text: "Todo #1" }];
let listeners = [];

export const todosStore = {
  addTodo() {
    todos = [...todos, { id: nextId++, text: "Todo #" + nextId }];
    emitChange();
  },
  subscribe(listener) {
    listeners = [...listeners, listener];
    return () => {
      listeners = listeners.filter((l) => l !== listener);
    };
  },
  getSnapshot() {
    return todos;
  },
};

function emitChange() {
  for (let listener of listeners) {
    listener();
  }
}

// App.jsx
const App = () => {
  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
  return (
    <>
      <button onClick={todosStore.addTodo}>Add todo</button>
      <hr />
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
};
```

## RSC(React Server Component)

### useId

```jsx
// 여러번 불러오는 컴포넌트일 경우 아래와 같이 필요함.
const App = () => {
  const inputId = useId();

  return (
    <>
      <input id={`${inputId}-firstName`} />
      <input id={`${inputId}-lastName`} />
    </>
  );
};
// ssr일경우 생성한 id가 다른경우가 있음.
// 1. 서버단 생성시 id="1" 생성
// 2. <div id="1"></div>을 client에게 전달
// 3. csr랭딩시 hydrate를 통해서 id="2" 로 처리.
```

### use

```jsx

```

### useCacheRefresh

```jsx

```

### useOptimistic

```jsx

```

### useFormStatus(react-dom)

```jsx

```



---
url: /note/react/pattern.md
---

#### 函数组件 (Function component)

```jsx
function Greeting(props) {
  return <div>Hi {props.name}!</div>;
}
Greeting.defaultProps = {
  name: "Guest",
};
```

#### 属性解构 (Destructuring props)

```jsx
function Greeting({ name = "dao" }) {
  return <div>Hi {props.name}!</div>;
}
```

#### JSX 中的属性展开 (JSX spread attributes)

```jsx
function Greeting({ name, ...restProps }) {
  return <div {...restProps}>Hi {name}!</div>;
}
```

#### 合并解构属性和其它值 (Merge destructured props with other values)

```jsx
function MyButton(props) {
  return (
    <button
      className="btn"
      {...props}
    />
  );
}
```

#### 条件渲染 (Conditional rendering)

```jsx
// 如果
{
  condition && <span>Rendered when `truthy`</span>;
}
// 除非
{
  condition || <span>Rendered when `falsy`</span>;
}
// 如果-否则
{
  condition ? <span>Rendered when `truthy`</span> : <span>Rendered when `falsy`</span>;
}
```

#### 渲染属性 (Render prop)

```jsx
const Width = ({ children }) => children(500);
<Width>{(width) => <div>window is {width}</div>}</Width>;
```

#### 代理组件 (Proxy component)

```jsx
const Button = props => <button type="button" {...props}>
```

#### 样式组件 (Style component)

```jsx
import classnames from "classnames";
const PrimaryBtn = props => <Btn {...props} primary />;

const Btn = ({ className, primary, ...props }) => (
  <button
    type="button"
    className={classnames("btn", primary && "btn-primary", className)}
    {...props}
  />
);

<PrimaryBtn />
<Btn primary />
```

#### 组织事件 (Event switch)

```jsx
handleEvent({type}) {
  switch(type) {
    case "click":
      return require("./actions/doStuff")(/* action dates */)
    case "mouseenter":
      return this.setState({ hovered: true })
    case "mouseleave":
      return this.setState({ hovered: false })
    default:
      return console.warn(`No case for event type "${type}"`)
  }
}
```

#### 布局组件 (Layout component)

```jsx
<HorizontalSplit
  leftSide={<SomeSmartComponent />}
  rightSide={<AnotherSmartComponent />}
/>;
const HorizontalSplit = ({ leftSide, rightSide }) => (
  <FlexContainer>
    <div>{leftSide}</div>
    <div>{rightSide}</div>
  </FlexContainer>
);
```

#### 容器组件 (Container component)

容器用来获取数据然后渲染到子组件上，仅仅如此。 —Jason Bonta

```jsx
const CommentList = ({ comments }) => (
  <ul>
    {comments.map(comment => (
      <li>
        {comment.body}-{comment.author}
      </li>
    ))}
  </ul>
);

const CommentListContainer = () => {
  useEffect(() => {
    $.ajax({
      url: "/my-comments.json",
      dataType: 'json',
      success: comments =>
        this.setState({comments: comments});
    })
  },[])

  return <CommentList comments={this.state.comments} />
}
```

#### 高阶组件 (Higher-order component)

- 接受一个或多个组件作为输入
- 输出一个组件

```jsx
const WrapContainer = (Component) => {
  return () => (
    <Container>
      <Component />
    </Container>
  );
};
```

#### 受控组件

input 的 value 和 state 同步

#### sub Components

```jsx
const ListGroup = ({ children }) => <ul>{children}</ul>;
const List = () => (
  <Fragment>
    <li>1</li>
    <li>2</li>
  </Fragment>
);

List.group = ListGroup;

const App = () => (
  <List.group>
    <List />
  </List.group>
);
```

#### context

```jsx
const ContextCounter = React.createContext();

const App = () => (
  <ContextCounter.Provider value={0}>
    <Child />
  </ContextCounter.Provider>
);

const Child = () => {
  const count = useContext(ContextCounter);
  return <h1>{count}</h1>;
};
```

#### createPortal

```jsx
import { createPortal } from "react-dom";

const Po = ({ children }) => {
  return createPortal(children, document.getElementById("modal"));
};

export default Po;
```

#### Profiler

```jsx
import React, { Profiler, useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  const onRender = (id, phase, actualDuration, baseDuration, startTime, commitTime, interactions) => {
    // id: string - 发生提交的 Profiler 树的 id。 如果有多个 profiler，它能用来分辨树的哪一部分发生了“提交”。
    // phase: "mount" | "update" - 判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。
    // actualDuration: number - 本次更新在渲染 Profiler 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。（例如 React.memo，useMemo，shouldComponentUpdate）。 理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。
    // baseDuration: number - 在 Profiler 树中最近一次每一个组件 render 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。
    // startTime: number - 本次更新中 React 开始渲染的时间戳。
    // commitTime: number - 本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。
    // interactions: Set - 当更新被制定时，“interactions” 的集合会被追踪。（例如当 render 或者 setState 被调用时）。
  };

  return (
    <Profiler
      id="App"
      onRender={onRender}
    >
      <div>{count}</div>
      <button onClick={() => setCount(count + 1)}>sc</button>
    </Profiler>
  );
};

export default App;
```



---
url: /note/react/performance.md
---

# React성능 최적화

## Diff Algorithm (VDOM)

#### 1. Tree diff 동일레벨(depth) 요소끼리 비교

```jsx
// 전부 교체
<section>
	<div className="content">hello</div>
</section>
<div className="content">hello</div>
```

#### 2. component 비교

```jsx
// 전부 교체
const About = () => <div>About</div>;
const Main = () => <div>About</div>;

visible ? <About /> : <Main />;
```

#### 3. Element Type 비교

```jsx
// 전부 교체
<section>
	<div className="content">hello</div>
</section>
<div>
	<div className="content">hello</div>
</div>

// Element가 동일하니 다음 단계로 pass
<div>
	<section className="content">hello</section>
</div>
<div>
	<div className="content">hello</div>
</div>

```

#### 4. Element Props 비교

```jsx
// Element가 동일할 경우 props 변경된 부분만 교체, 순서 중요하지 않음. 스타일 obj도 마찬가지.
<div style={{width: 40}} id="a">
	<div className="content">hello</div>
</div>
<div style={{width: 70, height: 30}} id="b">
	<div className="content">hello</div>
</div>

// style값이 동일하더라도 변경은 없지만 내부적으로 변화를 비교함
<div style={{width: 40}}>
	<div className="content">hello</div>
</div>
<div style={{width: 40}}>
	<div className="content">hello</div>
</div>
```

#### 5. key(우선순위 제일 높음.)

```jsx
// key설정 하지 않으면 null로 처리.
<div></div>
<div id="a"></div>

// key 다르면 판단하지 않고 교체.
<div key="1">123</div>
<div key="2">123</div>

// key & type(component, element포함)이 동일한 경우 vdom(fiber) 노드를 그대로 사용. (업데이트와 생성의 차이))
// 전부 교체.
<div key="1">123</div>
<p key="1">123</p>
```

#### 6. 멀티노드 비교

1. 1단계(비교)

```jsx
// newChildNode, oldChildNode 동시 끝나는 경우(Update 처리)
// old
<ul>
<li key="0" className="normal">0</li>
<li key="1" className="normal">1</li>
<li key="2" className="normal">2</li>
</ul>
// new
<ul>
<li key="0" className="bold">0</li>
<li key="1" className="bold">1</li>
<li key="2" className="bold">2</li>
</ul>
//
// newChildNode 순회가 먼저 끝나는 경우(Vdom Delection 처리)
// old
<ul>
<li key="0">0</li>
<li key="1">1</li>
<li key="2">2</li> <!-- Delection 처리 -->
</ul>
// new
<ul>
<li key="0">0</li>
<li key="1">1</li>
</ul>
//
// oldChildNode 순회가 먼저 끝나는 경우(Vdom Placement 처리)
// old
<ul>
<li key="0">0</li>
<li key="1">1</li>
</ul>
// new
<ul>
<li key="0">0</li>
<li key="1">1</li>
<li key="2">2</li> <!-- Placement 처리 -->
</ul>
//
// key가 동일하고 type이 다를 경우 oldChildNode Deletion처리.
// old
<ul>
<li key="0">0</li>
<li key="1">1</li> <!-- Delection 처리 -->
<li key="2">2</li>
</ul>
// new
<ul>
<li key="0">0</li>
<div key="1">1</div>
<li key="2">2</li>
</ul>
//
// oldChildNode, newChildNode모두 남아 있는 경우(key가 다른 부분이 있으면 바로 다음단계.)
// old
<ul>
<li key="0">0</li>
<li key="1">1</li>
<li key="2">2</li>
</ul>
// new
<ul>
<li key="0">0</li>
<li key="2">2</li>
<li key="1">1</li>
</ul>
```

2. 2단계(교체)

```jsx
- 빠른 처리를 위해서 남아있는 oldChildNode를 map객체에 [key]: fiber(vdom) 추가한다.
- placeChild 실행
    1. lastPlacedIndex = 0
    2. oldIndex ≥ lastPlaceIndex 일때 이동하지 않고 lastPlaceIndex = oldIndex로 설정.
    3. oldIndex < lastPlaceIndex 일때 맨 뒤로 이동.
    4. map객체에 관련된 데이터가 없을 경우 Placement
    5. oldChildNode순회후 newChildNode랑 매핑되지 않는 부분은 Deletion 처리

// old
<ul>
<li key="a">a</li>
<li key="b">b</li>
<li key="c">c</li>
<li key="d">d</li>
</ul>
// new
<ul>
<li key="d">d</li>
<li key="a">a</li>
<li key="b">b</li>
<li key="c">c</li>
</ul>
// lastPlacedIndex = 0;
// D가 oldChildNode에서의 index가 3임
// 3 >= lastPlaceIndex 이므로 이동이 필요 없음. lastPlaceIndex = 3으로 지정
// A가 oldChildNode에서의 index가 0임
// 1 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.
// B가 oldChildNode에서의 index가 1임
// 2 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.
// C가 oldChildNode에서의 index가 2임
// 2 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.
```

<br />

## React render하는 조건(bailout조건)

- oldProps === newProps
- context 값의 변화가 있는지?
- workInProgress.type === current.type (only Dev mode, live-reload)
- state변화가 있는지 ?? ~~업데이트 EffectTag가 존재한지, 존재하면 이번 priority 업데이트 task에 포함 되는건지 ?~~

<br/>
<br/>

## 최적화 유형

1. ~~PureComponent,shouldComponentUpdate~~
2. React.memo로 캐시(PureComponent로 만들고 싶을때 사용.)

```jsx
// React는 기본적으로 state변경시 해당 컴포넌트 및 자식 컴포넌트 전부 rerender한다.
// bailout로직중 newProps === oldProps 여야만 컴포넌트를 랜딩하지 않는다.
// 하위 컴포넌트에 React.memo 적용시 알고리즘을 실행해서 랭딩한다.
// 자주 변하는 값은 필요없지만 업데이트가 적거나 static한 컴포넌트는 필요하다.
// 컴포넌트 자체에서 props, state, context변화가 없고 부모의 부모의 .....  key값이 변화가 없는데 rerender된다.

import React, { useState, useMemo } from "react";

const EffectComponent = () => {
  console.log("render effect Component");
  return <>effect Component</>;
};

// const a = <EffectComponent />

// const diff = (prevProps, nextProps) => {
//   console.log(prevProps === nextProps);
//   return prevProps === nextProps;
// }

// const MemoEffectComponent = React.memo(EffectComponent, diff);

const App = () => {
  const [count, setCount] = useState(0); // state또는 context를 건드렸기 때문.
  const onChange = (e) => {
    setCount(count + 1);
  };

  // const b = useMemo(() => <EffectComponent />, [])

  return (
    <>
      <h2>Register</h2>
      <input onChange={onChange} />
      <p>{count}</p>
      <EffectComponent />
      {/* {a} */}
      {/* <MemoEffectComponent /> */}
    </>
  );
};

export default App;
```

3. useMemo, useCallback로 캐시

```jsx
import { useCallback, useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);

  const handleCount = useCallback(() => {
    setCount((count) => count + 1);
  }, []);

  const handleCount2 = useCallback(() => {
    setCount(count + 1);
  }, []);

  return (
    <div className="App">
      <h1>{count}</h1>
      <button onClick={handleCount}>+1</button>
      <button onClick={handleCount2}>+1</button>
    </div>
  );
}
```

4. inlineObject 사용금지

```jsx
// bad
<div style={{width: 200}}></div>
// good
const style = {width:200}
<div style={style}></div>
```

5. 익명함수 사용금지.

```jsx
// bad
<button onClick={() => {...}}>123</button>

// good
const onClick = () => {...};
<button onClick={onClick}>123</button>
```

6. key활용
7. React.Fragment사용

```jsx
// bad
<div>
  <p>1</p>
  <p>2</p>
</div>

// good
<React.Fragment>
  <p>1</p>
  <p>2</p>
<React.Fragment/>
```

8. lazyload(suspense) with webpack
9. transtion(react18)
10. immer 사용(구조공유)
11. useLayoutEffect, useInsertionEffect에 오래 실행되는 스크립트 사용하지 말것.(useEffect와 달리 sync로 실행됨.)

<br/>
<br/>

## React Design

- 변화(props, state, context)랑 불변을 분리해서 처리.

```js
const App = () => {
  const [count, setCount] = useState(0);
  return (
    <>
      {/* Title 컴포넌트 분리 */}
      <h1>h1</h1>

      {/* 이부분 분리 필요 */}
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      {/* 이부분 분리 필요 */}
    </>
  );
};
```

- 자주 랜더되는 컴포넌트를 찾고 그 parent노드를 찾아 가면서 최적화.

<br/>
<br/>

### 시험단계

- **React forget(React without memo)**
- **Offscreen API** https://vuejs.org/guide/built-ins/keep-alive.html#include-exclude

<br/>
<br/>

### 참고링크

- [https://ko.reactjs.org/docs/reconciliation.html#the-diffing-algorithm](https://ko.reactjs.org/docs/reconciliation.html#the-diffing-algorithm)
- https://github.com/facebook/react/blob/bd081376665f5f081dcf4bf72f06b7e563c8046d/packages/react-reconciler/src/ReactChildFiber.old.js#L736
- https://zhuanlan.zhihu.com/p/20346379
- https://react.iamkasong.com/diff/multi.html



---
url: /note/react/sources/01.md
---

# 리액트 특징

### React강점?

지속가능한 인터랙티브(consistently interactive), 즉 time slice(concurent)

프레임워크 비교에서 리액트가 후순위로 밀려나는 이유는 consistently interactive가 성능에서 제외되었기 때문이다.(링크참고)

react legacy

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/07/08/20220708165000.png)

react concurrent

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/07/08/20220708165201.png)

<br />

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/07/14/20220714182526.png)

<br />

### AOT(A Head Of Time) vs JIT(Just In Time)

- AOT
  - 소스코드를 미리 컴파일
  - 정적이다
  - svelte
- JIT
  - 런타임 환경에 필요한 부분만 컴파일
  - 유연하다
  - react(jsx, react render fn은 완전 동적이여서 최적화가 어려움.)

<br />

### Algebraic Effect(OCaml)

- functional programing중 개념.
- 부작용(effect)을 함수 내부에서 분리
- React 개발시 useState 같은 경우 내부적으로 어떻게 처리하는지 신경쓰지 않아도 되고 어떤 데이터를 반환하는지 만 알고 코드 작성하면 된다.

```jsx
const getTotal = () => {
  const a = getPrice1(); // effect
  const b = getPrice2(); // effect
  return a + b;
};
// getTotal실행시 바로 결과 가져오게 처리.

const Total = () => {
  const a = usePrice(1); // async
  const b = usePrice(2); // async
  return <div>{a + b}</div>;
};
// <Total />
```

<br />

### 참고

- https://yeoulcoding.me/124
- https://overreacted.io/algebraic-effects-for-the-rest-of-us/
- https://github.com/halfnelson/svelte-it-will-scale
- https://krausest.github.io/js-framework-benchmark/2022/table_chrome_103.0.5060.53_osx.html
- https://web.dev/i18n/ko/interactive/
- https://maxkim-j.github.io/posts/suspense-argibraic-effect
- https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160



---
url: /note/react/sources/02.md
---

# Fiber

### 용어

Fiber Architecture

Fiber Node, Fiber Tree, FiberRoot, rootFiber

Fiber Reconciler는 Fiber Node 기반으로 실현

<br/>

### Vdom에 대한 이해?

1. Fiber 객체 자체가 Vdom이다.
2. vitrual DOM은 React.createElement()로 return된 객체. fiber는 vdom 을 realdom으로 실현하는 일부분.

<br/>

### Fiber 아키텍처의 의미

fiber는 node단위를 한개 workUnit으로 비동기 이고 중단 가능한 업데이트를 실현(concurrent 모드, timeSlice실현.)
<br/>
<br/>

### 데이터 구조

```jsx
// https://github.com/facebook/react/blob/16.8.6/packages/react-reconciler/src/ReactFiber.js
function FiberNode(tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode) {
  this.tag = tag; // fiber 대응하는 컴포넌트 유형 Function/Class/Host
  this.key = key;
  this.elementType = null; // type이랑 동일 하지만 일부 제외(예: React.memo사용시 제외)
  this.type = null; // FC=>함수자체, CC=>클래스, HostComponent=>tagName
  this.stateNode = null;

  // 다른 fiber 연결용
  this.return = null;
  this.child = null;
  this.sibling = null;

  this.index = 0; // fiber관련 dom insert할때 인덱스.
  this.ref = null;

  // update 관련된 상태 관련 정보 저장.
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // 부작용에 대한 내용 저장.
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  // 우선순위 관련 처리
  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  // 해당 fiber 업데이트시 연관된 작업의 fiber(workInProgressFiber => currentFiber)
  this.alternate = null;
}
```

<br/>
<br/>

### Fiber **DoubleBuffer**

예를들어 canvas에서 화면을 그릴때 매프레임마다 ctx.clearRect로 이전 화면을 지운다.

새로 그리는 화면 컴퓨팅 시간이 많이 필요할 경우 흰색 화면만 보여주는 경우(Flickering)가 있다.

해당문제를 해결하기 위해서 메모리(cpu, gpu)에서 다음화면을 그릴때 까지 이전화면을 보여주고 화면이 완성된 후에 ctx.clearRect로 이전화면을 지우고 새화면을 교체해준다.

이와같이 메모리에서 구성하고 바로 교체 해주는 방식을 DoubleBuffer라고 한다.

current fiber ⇒ workInProgress fiber(alternate)

<br/>

### Root

fiberRoot(변하지 않음.) > rootFiber > App > div

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/07/25/20220725213905.png)
<br/>

### JSX to Fiber

JSX ⇒ BABEL ⇒ React.createElement ⇒ ReactElement ⇒ ReactDom.render ⇒ ReactDOM.legacyCreateRootFromDOMContainer ⇒ createFiberRoot

<br/>

### fiber 생성순서

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/07/25/20220725214257.png)

\*React 자식요소가 only textNode일 경우 별도 fiber생성 하지 않는다. (isDirectTextChild)

```html
<div><!-- 1 -->
  <header/><!-- 2 -->
    <h1><!-- 3 -->
      page Title<!-- 4 -->
      <span></span><!-- 5 -->
    </h1>
    <input /><!-- 6 -->
  </header>
  <div>contents</div><!-- 7 -->
  <footer><!-- 8 -->
    <div><!-- 9 -->
      <p>copyright</p><!-- 10 -->
      <p>email: aa@bb.com</p><!-- 11 -->
    </div>
    <p>footer</p><!-- 12 -->
  </footer>
</div>
```

<br/>

### 참고

- https://github.com/acdlite/react-fiber-architecture
- https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react
- https://www.youtube.com/watch?v=ZCuYPiUIONs



---
url: /note/react/sources/03.md
---

# Reconciler

### 역할

- Function또는 class컴포넌트의 render 함수를 실행해서 jsx를 vdom으로 변경
- 새로운 vdom과 기존 vdom을 비교한다.
- diff통해서 변화한 부분을 체크한다.
- renderer를 통해서 DOM을 화면에 뿌려준다.

<br />

### fiber관련 태그 설명.

- type
  - FunctionComponent ⇒ 함수자체
  - ClassComponent ⇒ 클래스
  - HostComponent ⇒ tagName
- tag
  - FunctionComponent
  - ClassComponent
  - HostComponent
- effectTag
  - Placement
  - Update
  - PlacementAndUpdate
  - Deletion
  - Passive
- effectList(firstEffect, nextEffect, lastEffect)
- stateNode => DOM객체 저장.

<br />

### 과정

- render
  - beginWork
  - completeWork
- commit
  - before Mutation
  - mutation
  - layout

<br />

## render단계

### beginWork

- (mount)fiber.tag에 따라 서로 다른 Fiber노드 생성.
- (update) 만약 current가 최적화 될수 있다면 current를 그대로 사용(Diff)
- fiber에 EffectTag생성

<br />

### completeWork

- (mount)fiber.stateNode에 관련된 DOM노드 생성
- (mount)children DOM노드를 생성된 fiber.stateNode DOM노드에 insert
- (mount) props 처리
- (update) fiber.updateQueue처리
- (update) props diff 처리후 fiber.pendingProps에 저장.
- effectTag 생성된 fiber에 대해서 effectList에 추가.

<br />

## commit

### commit start

~~effectList중 Passive 태그가 존재할 경우 flushPassiveEffects(Immediate) 실행.~~

<br />

### before mutation (commitBeforeMutationEffects)

- DOM노드 랜더/삭제후 focus, blur 관련 로직처리.
- getSnapshotBeforeUpdate(ClassComponent)
- ~~flashPassiveEffects (Normal)~~

<br />

### mutation (commitMutationEffects)

- effectTag에 따라 처리
  - Placement
  - Update
    - FunctionComponent
      - effectList에서 모든 useLayoutEffect의 destory 함수 실행.
    - HostComponent
      - fiber.updateQueue중 대응하는 내용 화면에 랜딩.
      - fiber.pendingProps내용 화면에 랜딩
  - Deletion

<br />

### layout (commitLayoutEffects)

- 라이프사이클 및 hook 실행
  - FunctionComponent
    - useLayoutEffect 콜백 함수 실행.(sync)
    - ~~useEffect destor 함수와 콜백함수 초기화(async)~~
  - classComponent
    - componentDidMount, componentDidUpdate
    - this.setState의 콜백함수 실행.
  - HostRoot
    - render fn 콜백함수 실행.
- DOM Instance에 따라 ref업데이트
- current Fiber 트리 변환

<br />

### layout After

- fushPassiveEffects 실행(useEffect destor 및 useEffect callback)
- flushSyncCallbackQueue 실행(예: useLayoutEffect 내부에 사용한 setState)

<br />

## hostConfig 외부 API(react-dom 빌드시 해당 부분 함께 빌드)

```js
import ReactReconciler from "react-reconciler";

const hostConfig = {
  now: Date.now,
  getRootHostContext: () => {},
  clearContainer: () => {},
  prepareForCommit: () => {},
  resetAfterCommit: () => {},
  getChildHostContext: () => {},
  shouldSetTextContent: () => {},
  createInstance: () => {},
  createTextInstance: () => {},
  appendInitialChild: () => {},
  appendChild: () => {},
  finalizeInitialChildren: () => {},
  supportsMutation: true,
  appendChildToContainer: () => {},
  prepareUpdate = () => {},
  commitUpdate = () => {},
  commitTextUpdate = () => {},
  removeChild = () => {},
}
const ReactReconcilerInst = ReactReconciler(hostConfig);

export const render = (reactElement, domElement, callback) => {

  if (!domElement._rootContainer) {
    console.log(ReactReconcilerInst);
    domElement._rootContainer = ReactReconcilerInst.createContainer(domElement);
  }
  // 컨테이너 업데이트
  return ReactReconcilerInst.updateContainer(reactElement, domElement._rootContainer, null, callback);
}

export default {
  render
}
// "react-reconciler": "0.26.2",
// "react": "17.0.2",
```

<br />

### effectList => subtreeFlags

- effectList인 경우

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/08/03/20220803212122.png)

- subtreeFlags

![](https://raw.githubusercontent.com/jl917/s/master/img/2022/08/03/20220803212256.png)

- B의 effect는 Passive이고 bubble을 통해서 A로 이동, A.subtreeFlags에 Passive포함.
- E의 effect는 Placement이고 bubble통해서 D로 이동, D.subtreeFlags에 Placement포함.
- D.subtreeFlags에 Placement가 bubble통해서 C로 이동
- C의 effect는 Update이고, C.subtreeFlags의 Placement가 bubble통해서 A로
- A.subtreeFlags는 Passive、Placement、Update를 포함.
- commit단계에서 모든 tree를 순회하면서 처리.

[https://gist.github.com/jl917/059c3c47a521914cb8ed8fa2b5ff8569](https://gist.github.com/jl917/059c3c47a521914cb8ed8fa2b5ff8569)

<br />

### 참고

- https://velog.io/@dev-mish-mash/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%A1%B0%ED%99%94Reconciliation-%EA%B3%BC%EC%A0%95-%EC%A0%95%EB%A6%AC
- https://beta-reactjs-org-git-effects-fbopensource.vercel.app/learn/render-and-commit
- https://agent-hunt.medium.com/hello-world-custom-react-renderer-9a95b7cd04bc



---
url: /note/react/sources/04.md
---

# Update

### Update 활성화

- ReactDOM.render
- this.setState
- this.forceUpdate
- useState
- useReducer

<br />

### Update 프로세스

this.update.enqueueSetState 통해서 Update를 생성하고 실행한다.

```sh
Update 활성화
    |
    v
shared.pending 생성
    |
    v
....
    |
    v
updateQueue 처리(completeWork)
    |
    v
...
```

<br />

### Update객체

```js
// ClassComponent, HostRoot
const update = {
  eventTime: "",
  lane: "",
  suspenseConfig: "",
  tag: UpdateState, // CaptureUpdate, ForceUpdate, ReplaceState, UpdateState
  payload: null, // ClassComponent this.setState args[0], HostRoot ReactDOM.render args[0]
  callback: null, // ClassComponent this.setState args[1], HostRoot ReactDOM.render args[2]
  next: null,
};

// FunctionComponent
const update = {
  eventTime: "",
  lane: "",
  suspenseConfig: "",
  action: "", // ????
  eagerReducer: null, // useState는 basicStateReducer사용.
  eagerState: null, // 리듀서를 통해 action의 결과값을 얻는다. basicStateReducer(baseState, action)
  next: null,
};

function basicStateReducer(state, action) {
  return typeof action === "function" ? action(state) : action;
}
```

<br />

### Update Queue

- baseState: 메모리에 임시 저장되는 값.
- memoizedState: 화면에 노출되는 값
- shared.pending: 업데이트 활성화시 임시 저장하고 우선순위에 적합한 Update만 firstBaseUpdate뒤에 추가.

```js
// ClassComponent
const Fiber = {
  updateQueue: {
    baseState: '',
    firstBaseUpdate: Update,
    lastBaseUpdate: Update,
    shared: {
      pending: Updates
    }
    effects: [] // update.callback 이 존재하는 경우만 배열에 추가
  }
  memoizedState: stateValue
}

// FunctionComponent
const Fiber = {
  memoizedState: { // Hook
    memoizedState: stateValue,
    baseState: '',
    baseQueue: Update,
    queue: Updates,
    next, // Hook list
  }
}
```

<br />

## update 종류별

### 단일 Task

```js
const App = () => {
  const [count, setCount] = useState(0);
  const onClick = () => setCount(count + 1);
  return <div onClick={onClick}>{count}</div>;
};
```

<br />

### batchUpdate

```js
const App = () => {
  const [count, setCount] = useState(0);
  const onClick1 = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
  };
  const onClick2 = () => {
    setCount((baseState) => baseState + 1);
    setCount((baseState) => baseState + 1);
    setCount(count + 1);
    setCount((baseState) => baseState + 1);
  };
  const onClick3 = () => {
    setTimeout(() => {
      // concurrent mode일 경우 배치됨, legacy mode일 경우 3번 랜딩됨.
      setCount(count + 1);
      setCount(count + 1);
      setCount(count + 1);
    }, 0);
  };
  return (
    <>
      <h1>{count}</h1>
      <div onClick={onClick1}>click1</div>
      <div onClick={onClick2}>click2</div>
      <div onClick={onClick3}>click3</div>
    </>
  );
};
```

### high priority task

```js
const arr = [];
arr.length = 6000;
arr.fill(0);

const App = () => {
  const btnRef = useRef(null);
  const [count, setCount] = useState(0);
  const onClick = () => {
    setCount((count) => count + 1);
  };

  useEffect(() => {
    // 레거시 모드에서는 10, 11로 화면에 노출
    // 동시성 모드에서는 1, 11로 화면에 노출(1차 우선순위 높은거 실행, 2차 순차적으로 실행.)
    // [10_2, x+1_1]
    setTimeout(() => {
      setCount(count + 10);
    }, 2000);
    setTimeout(() => {
      btnRef.current.click();
    }, 2000);
  }, []);
  return (
    <>
      <h1>{count}</h1>
      <div
        onClick={onClick}
        ref={btnRef}
      >
        click1
      </div>
      {arr.map(() => (
        <div>{count}</div>
      ))}
    </>
  );
};
```

### 복합적인 경우

```js
// For example:
//
//   Given a base state of '', and the following queue of updates
//
//     A1 - B2 - C1 - D2
//
//   where the number indicates the priority, and the update is applied to the
//   previous state by appending a letter, React will process these updates as
//   two separate renders, one per distinct priority level:
//
//   First render, at priority 1:
//     Base state: ''
//     Updates: [A1, C1]
//     Result state: 'AC'
//
//   Second render, at priority 2:
//     Base state: 'A'            <-  The base state does not include C1,
//                                    because B2 was skipped.
//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
//     Result state: 'ABCD'
```

<br />

### 참고

- https://wonism.github.io/react-updater/
- https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberClassUpdateQueue.old.js



---
url: /note/rust/001.md
---

# 기초문법

## 요약

#### hello world

```rust
fn main() {
    let s = "hello world";
    println!("{}", s); // println! macro   标准输出macro 可以完成编译器格式检查， 更加安全
}
```

#### 타입지정

```rust
fn Foo(input1: i32, input2: u32) -> i32 {
  ...
}
```

#### use

```rust
use std::prelude::*; // std rust에서 제공하는 standard 유틸
```

#### Format

```rust
fn main() {
    println!("{}", 1); // default
    println!("{:o}", 9); // 八进制
    println!("{:x}", 255); // 十六进制 小写
    println!("{:X}", 255); // 十六进制 大写
    println!("{:p}", &0); // pointer
    println!("{:b}", 15); // 二进制
    println!("{:e}", 10000f32); // 科学计数 小写
    println!("{:E}", 10000f32); // 科学计数 大写
    println!("{:?}", "test"); // debug
    println!("{:#?}", ("test1", "test2")); // 带换行和缩进的debug
    println!("{a} {b} {b}", a = "x", b = "y"); // 命名参数
}
```

#### 변수선언

```rust
let num: i32 = 100;
let num = 100i32;

let x = 5;
x = 10; // error

let mut x = 5;
x = 10;

let x:i32;
x = 1;

let (mut a, mut b) = (1,2);
let Point {x: ref a, y: ref b} = p;

static GLOBAL:i32 = 0;
```

#### 기본 데이터 유형

```rust
let empty: () = (); // unit type
let boolean: bool = true;
let t1: char = 'x';
// u8 ~ u128
let i1: i8 = -128; // -128~127
let i2: u8 = 255; // 0~255
// f32, f64
let f1: f32 = 123.0;
let f2 = 123.0f32;
```

#### 복합 데이 유형

```rust
// tuple
let a = (1i32, false);
let b = (a, (1i32, 2i32));
let a = (0,);
let b: i32 = (0); // 표현식, tuple 아님

// struct
struct Point {
  x: i32,
  y: i32,
}
let p = Point {x: 0, y: 0};
println!("point is at {} {}",p.x, p.y);

// struct: 생략 가능
let x = 10;
let y = 20;
let p = Point {x, y};

// struct: px, py alias로 바인딩 가능
let p = Point { x: 0, y: 1 };
let Point { x: px, y: py } = p;

// struct: destruct도 가능
let Point {x, y} = p;

// struct: 语法糖, default 지정 가능
struct Point3d {
  x: i32,
  y: i32,
  z: i32,
}
fn default() -> Point3d {
  Point3d { x: 0, y: 0, z: 0 }
}
let origin = Point3d { x: 4, ..default() };

// tuple struct
struct T(i32);
let v1 = T(1);
let v2 = T{0: 1};

// enum
enum Number {
    Int(i32),
    Float(f32),
}
// Number::Int로 enum구성원에 접근
fn read_num(num: &Number) {
    match num {
        &Number::Int(value) => println!("integer {}", value),
        &Number::Float(value) => println!("float {}", value),
    }
}
fn main() {
    let n: Number = Number::Int(10);
    read_num(&n);
}
// index
enum Animal {
    dog = 1, // 선언하지 않으면 0
    cat = 200,
    tiger,
}

let x = Animal::tiger as isize;
println!("{}", x) // 201
```

#### Expression

```rust
let x = 100;
let y = 10;
let t = true;
let f = false;

println!("{}", x + y);
println!("{}", x - y);
println!("{}", x * y);
println!("{}", x / y);
println!("{}", x % y);
println!("{}", x == y);
println!("{}", x != y);
println!("{}", x < y);
println!("{}", x > y);
println!("{}", x >= y);
println!("{}", x <= y);
println!("{}", t && f);
println!("{}", t || f);
println!("{}", !t);

let mut y1 = 40;
let mut y2 = 40;
let mut y3 = 40;
let mut y4 = 40;
let mut y5 = 40;
y1 += 10;
y2 -= 10;
y3 *= 10;
y4 /= 10;
y5 %= 10;
println!("{}", y1);
println!("{}", y2);
println!("{}", y3);
println!("{}", y4);
println!("{}", y5);
```

```rust
let x: () = {
    println!("hello x");
};
x;
let y: i32 = {
    println!("hello y");
    30
};
println!("{}", y);
```

#### if else

```rust
fn func(n: i32) -> bool {
    if n < 0 {
        println!("{} is negative", n);
    } else if n > 0 {
        println!("{} is positive", n);
    } else {
        println!("{} is zero", n);
    }
    return n > 0;
}
let x = func(-3);
println!("{}", x)
```

#### loop

```rust
let mut count = 0u32;

loop {
    count += 1;
    if count == 3 {
        println!("three");
        continue;
    }

    println!("{}", count);
    if count >= 5 {
        println!("OK");
        break;
    }
}
```

#### while

```rust
let mut count = 0u32;

while count < 101 {
    if count % 15 == 0 {
        println!("fizzbuzz");
    } else if count % 3 == 0 {
        println!("fizz");
    } else if count % 5 == 0 {
        println!("buzz");
    } else {
        println!("{}", count);
    }
    count += 1;
}
```

#### for

```rust
let array = &[1, 2, 3, 4, 5];
for i in array {
    println!("is {}", i);
}
```

#### 함수

```rust
// 일반
fn add(t: (i32, i32)) -> i32 {
    t.0 + t.1
}
fn add2((a, b): (i32, i32)) -> i32 {
    a + b
}
println!("{}", add((1, 2)));
println!("{}", add2((3, 4)))

// return이 없는 경우 unit ()
fn empty(a: i32) -> () {
    a+a;
}

// 함수에 값을 할당해서 사용(타입이 동일할 때에만 할당 가능)
// let mut f = add as fn((i32, i32)) -> i32;
let mut f: fn((i32, i32)) -> i32 = add;
f = add2;

println!("{}", f((1, 3)))

// main함수 args
fn main() {
    for arg in std::env::args() {
        println!("{}", arg);
    }
    std::process::exit(0);
}
// ./004 test1 opt2
// ./004
// test1
// opt2

// const 함수 컴파일 단계에서 실행하는 함수라서 제한이 많음,
// 제한이 있을수 있으니 조심해서 사용
const fn add(a: i32, b: i32) -> i32 {
    a + b
}

let total: i32 = add(1, 2);
let total2: i32 = add(3, 4);
println!("{}", total);
println!("{}", total2);

// 재귀 함수
// 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
// rust1.19 버전까지 trail call 최적화가 되지 않음.
fn fib(index: u32) -> u64 {
    if index == 1 || index == 2 { 1 } else { fib(index - 1) + fib(index - 2) }
}

let f8 = fib(8);
println!("{}", f8)
```

#### trait

```rust
// method
trait Shape {
    fn area(&self) -> f64;
}
struct Circle {
    radius: f64,
}

impl Shape for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

let c = Circle { radius: 2f64 };
println!("{}", c.area());

// static method
struct T(i32);
impl T {
    fn func(this: &Self) {
        println!("{}", this.0)
    }
}

let x = T(42);
T::func(&x);

// extend method
trait Double {
    fn double(&self) -> Self;
}
impl Double for i32 {
    fn double(&self) -> i32 {
        *self * 2
    }
}

let x: i32 = (10).double();
println!("{}", x)

// fully qualified syntax(universal function call syntax)
trait Cook {
    fn start(&self);
}
trait Wash {
    fn start(&self);
}
struct Chef;
impl Cook for Chef {
    fn start(&self) {
        println!("Cook::start");
    }
}
impl Wash for Chef {
    fn start(&self) {
        println!("Wash::start");
    }
}

let me = Chef;
<Cook>::start(&me);
<Chef as Wash>::start(&me);

// alias
pub trait Service {
    type Request;
    type Response;
    type Error;
    type Future: Future<Item=Self::Response, Error=Self::Error>;
    fn call(&self, req: Self::Request) -> Self::Future;
}

trait HttpService = Service<Request = http::Request, Response = http::Response, Error = http::Error>;
```

#### array

```rust
let v = [1,2,3];
// 크기 반드시 지정, 가변 크기는 std Vec/LinkedList 사용
let xs: [i32; 5] = [1, 2, 3, 4, 5];
println!("{:?}", xs)

// 기본값 으로 fill처리
let xs: [i32; 5] = [0; 5];
println!("{:?}", xs)

// 2depth
let v: [[i32;2];3 ] = [[0,0],[0,0],[0,0]]

// range
let r = 1..10;
for i in r {
    println!("{}", i);
}
```

#### string

```rust
let greeting: &str = "Hello";
let substr: &str = &greeting[2..];
println!("{}", greeting);
println!("{}", substr);

let mut s = String::from("Hello");
s.push(' ');
s.push_str("World");
println!("{}", s)
```

#### match

```rust
enum Direction {
    East,
    West,
    South,
    North,
}

fn print(x: Direction) {
    match x {
        Direction::East => {
            println!("East");
        }
        Direction::West => {
            println!("West");
        }
        Direction::South => {
            println!("South");
        }
        Direction::North => {
            println!("North");
        }
    }
}

fn print2(y: Direction) {
    match y {
        Direction::East => {
            println!("East");
        }
        _ => {
            println!("Other");
        }
    }
}

fn print3(x: Direction) {
    match x {
        Direction::East => 10
        Direction::West => 20
        Direction::South => 30
        Direction::North => 40
    }
}

let x = Direction::East;
let y = Direction::West;
print(x);
print2(y);
print3(x);
```

#### \_

```rust
struct P(i32, i32, i32);
fn calc(P(x, _, y): P) -> i32 {
    x * x + y * y
}
let t = P(1, 2, 3);
println!("{}", calc(t));
```



---
url: /note/rust/002.md
---

# 개념

#### &str String차이점

String유형은 메모리공간 관리가 가능하다.



---
url: /note/rust/003.md
---

# 유틸/팁

### plugin

- vscode plugin(rust-analyzer)

### 주의사항

- 시도해 보는 사고방식을 피하라
- 완전히 새로운 언어여서 어려움에 부딛힐 준비를 해라
- 책을 보고 깊게 공부하라
- Linked List, Graph로 연습하지 말아라
- 컴파일 오류를 잘 읽어보라
- 다른언어의 bp를 rust에 적용하지 말라

```rust
// str[n]으로 n번째 텍스트 가져오기
s.chars().nth(n);
```



---
url: /note/seo/index.md
---

# SEO

## HTML부분

- Meta Title 태그 최적화
- Meta description최적화
- Semantic 마크업
  - Heading 태그 구조 최적화
  - image alt 속성
  - anchor 텍스트를 작성
    - 외부링크일 경우 rel="nofollow" 추가
- 절대 경로 사용
- 불필요한 내용 제거.

## URL

- 최대한 짧고 간단하게
- 키워드 포함
- 소문자 사용
- 특수문자 및 공백 사용 금지 또는 인코딩 처리
- https사용

## 기타

- sitemap.xml 사이트맵 작성
- robots.txt에 의한 크롤링제어
- 검색엔진 수동 등록
- 사이트 랜더링 최적화


---
url: /note/svelte/01.md
---

# 基础

```html
// Text.svelte
<p>
  this is Text Component
</p>

// App.svelte
<script>
  import text from './Text.svelte'
  const name = 'google'
  const src = 'https://www.google.com/logos/doodles/2020/december-holidays-days-2-30-6753651837108830.3-law.gif'
  const htmlText = '<strong>html</strong> parsing sample'
</script>
<div>
  <h1 class="heading">
    hello {name}
  </h1>
  <div>
    <img src={src} alt="{name} logo" />
  </div>
  <p>
    {@html htmlText}
  </p>
  <Text />
</div>

<style>
  .heading{color:#ff0000}
</style>
```

```js
// index.js
import App from './App.svelte';

const app = new App({
	target: document.body,
	props: {
		// we'll learn about props later
		answer: 42
	}
});
```



#### 交互

```html
<script>
	let count = 0;
  $: doubled = count * 2;
	const handleClick = () => count += 1;
</script>
<button on:click={handleClick}>
	Click
</button>
<!-- 推荐， 重复使用该组建时很友好 -->
<p>
	{count} {doubled}
</p>
<!-- 不使用也可以 -->
<p>
	{count} {count * 2}
</p>
```

```html
<script>
	let count = 0;
	let count2 = 0;
  // 监听count更改时执行, 有声明就监听
	$: console.log(`the count is ${count}`);
  // 可以大括号打包
  $: {
    console.log(`the count is ${count}`);
  }
  // 也可以添加条件
  $: if(count > 10){
    console.log('count max')
    count = 9
  }

	function handleClick() {
		count += 1;
	}
	function handleClick2() {
		count2 += 1;
	}
</script>

<button on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<button on:click={handleClick2}>
	Clicked {count2} {count2 === 1 ? 'time' : 'times'}
</button>
```

```html
<script>
	let numbers = [1,2,3,4];
  $: length = numbers.length;
  const addNumber = () => {
    numbers = [...numbers, numbers.length + 1]
    // 直接push 他不会导致组建更新
    // nums.push(numbers.length + 1)
  }
</script>
<button @on:click={addNumber}>
  click {length}
</button>
```



#### Props

```html
<!-- App.svelte -->
<script>
	import People from './People.svelte';
  const p1 = {
    name: 'dao',
    age: 20,
  }
</script>
<People name="dao" age={20} />
<People {...p1} />

<!-- People.svelte -->
<script>
  export const name = 'lang'; // default value
  export const age;
</script>
<p>
  name: {name}<br/>
  age: {age}
</p>
```



#### Logic

```html
<script>
let isLogined = false;
const toggle = () => {
	isLogined = !isLogined;
}
const list = [
  {
    id: 'un01', name: 'dao', age: 12,
  },
  {
    id: 'un02', name: 'lang', age: 22,
  },
]
</script>
<button on:click={toggle}>
	{#if !isLogined}login{/if}
	{#if isLogined}logout{/if}
</button>
<button on:click={toggle}>
	{#if !isLogined}login
	{:else}logout{/if}
</button>
<ul>
  {#each list as item, i (item.id)} <!-- 相当于react key -->
  	<li>{i} - {item.name}, {item.age}</li>
  {/each}
</ul>
```



#### Promise

```html
<script>
	const getUser = async () => {
		const response = await fetch('https://randomuser.me/api/');
		if(response.status === 200){
			return response.json()
		}
	}
</script>

{#await getUser()}
	<div>loading...</div>
	{:then data}
	<div>
		{data.results[0].gender} - {data.results[0].name.first}, {data.results[0].name.last}
	</div>
	{:catch error}
	<div>
		{error.message}
	</div>
{/await}
```



#### Event

```html
<script>
	let count = 0;
	const setCount = () => {
		count += 1;
	}
</script>
<h1>
	{count}
</h1>
<button on:click|once={setCount}>
	click
</button>
<!-- 在某些框架中，出于性能原因，您可能会看到一些避免内联事件处理程序的建议，尤其是在循环内部。 该建议不适用于Svelte，无论您选择哪种形式，编译器都将始终做正确的事情。 -->
<button on:click={() => count += 1}>
	click
</button>
```



#### Event Modifiers

|                 |                                                              |
| --------------- | ------------------------------------------------------------ |
| preventDefault  | 运行处理程序之前调用event.preventDefault（）。 例如，对客户端表单处理有用。 |
| stopPropagation | 调用event.stopPropagation（），以防止事件到达下一个元素      |
| passive         | 改进了触摸/滚轮事件的滚动性能（Svelte会在安全的地方自动添加它） |
| nonpassive      | 显式设置为passive：false                                     |
| capture         | 在捕获阶段而不是冒泡阶段（）触发处理程序                     |
| once            | 首次运行处理程序后将其删除                                   |
| self            | 仅当event.target是元素本身时才触发处理程序                   |



#### Component Event

与DOM事件不同，组件事件不会冒泡。 如果要在某个深度嵌套的组件上侦听事件，则中间组件必须转发该事件。

```html
<!-- App.svelte -->
<script>
	import People from './People.svelte';
	let name = 'lang';
	let age = 5;
	const getName = (event) => {
		name = event.detail.name;
		age = event.detail.age;
	}
</script>
<People on:getName={getName} />
<PeopleOuter on:getName={getName} />
<div>
	{name} {age}
</div>

<!-- People.svelte -->
<script>
	import {createEventDispatcher} from 'svelte';
	const dispatch = createEventDispatcher();
	const setName = () => {
		dispatch('getName', {
			name: 'daolang',
			age: 12
		})
	}
</script>
<button on:click={setName}>
click
</button>

<!-- PeopleOuter.svelte -->
<script>
  import People from './People.svelte';
</script>
<People on:getName />

```



#### Form binding

```html
<script>
	let formObj = {
		username: '',
		age: 10,
		agree: false,
		gender: 'male',
		country: 'korea',
		message: '',
	}
</script>

<form>
	<h3>Input</h3>
	<label>username <input bind:value={formObj.username} /></label>
	<h3>Range</h3>
	<label>age <input bind:value={formObj.age} type="range" min={0} max={99} />{formObj.age}</label>
	<h3>Radio</h3>
	<label>male <input type="radio" bind:group={formObj.gender} value="male" /></label>
	<label>famale <input type="radio" bind:group={formObj.gender} value="female" /></label>
	<h3>Radio</h3>
	<select bind:value={formObj.country}>
		<option value="china">china</option>
		<option value="japan">japan</option>
		<option value="korea">korea</option>
	</select>
	<h3>Textarea</h3>
	<textarea bind:value={formObj.message} />
</form>
```



#### Component binding

```html
<!-- App.svelte -->
<script>
	import Pad from './Pad.svelte'
  let pin = ''
  $: view = pin || 'enter pin'
	
  const handleSubmit = () => {
    alert(`submit ${pin}`)
  }
</script>
<h1>{view}
</h1>
<Pad bind:value={pin} on:submit={handleSubmit} />
<!-- Pad.svelte -->
<script>
	import { createEventDispatcher } from 'svelte';
	export let value = ''
	const dispatch = createEventDispatcher();
	const clickNum = (e) => value += e.target.innerText;
	const clickClear = () => value = '';
	const clickSubmit = () => dispatch('submit')
</script>

<div>
	<button on:click={clickNum}>1</button>
	<button on:click={clickNum}>2</button>
	<button on:click={clickNum}>3</button>
	<button on:click={clickNum}>4</button>
	<button on:click={clickNum}>5</button>
	<button on:click={clickNum}>6</button>
	<button on:click={clickNum}>7</button>
	<button on:click={clickNum}>8</button>
	<button on:click={clickNum}>9</button>
	<button on:click={clickClear}>clear</button>
	<button on:click={clickNum}>0</button>
	<button on:click={clickSubmit}>submit</button>
</div>
```



#### Lifecycle

1. beforeUpdate
2. render
3. onMount
4. afterUpdate
5. onDestroy
6. unMount(onMount return function)

```html
<!-- App.svelte -->
<script>
	import Sub from './Sub.svelte';
	let isShow = true
	const toggle = () => isShow = !isShow;
</script>
<button on:click={toggle}>
	click
</button>
{#if isShow}
<Sub />
{/if}

<!-- Sub.svelte -->
<script>
	import { onMount, onDestroy, beforeUpdate, afterUpdate } from 'svelte';
	let status = 'sub page'
	onMount(() => {
		console.log('mount')
		return () => {
			console.log('unmount')
		}
	})
	// 销毁时运行 unmount 之前
	onDestroy(() => {	
		console.log('destroy')
	})
	// 数据更新前
	beforeUpdate(() => {
		console.log('before update')
	})
	// 数据更新后
	afterUpdate(() => {
		console.log('after update')
	})
	
	const setContents = () => {
		status = `sub page ${+new Date()}`
	}
</script>

<p>
	<span style="display: none">{console.log('render')}</span>
	{status}
</p>
<button on:click={setContents}>
	update page contents
</button>
```

在Svelte中更新组件状态时，它不会立即更新DOM。 而是等到下一个微任务，看是否还有其他需要应用的更改，包括其他组件。 这样做避免了不必要的工作，并使浏览器可以更有效地对事物进行批处理。


---
url: /note/svelte/02.md
---

# Stores

```html
<!-- App.svelte -->
<script>
import { count, count2 } from "./store.js";

const increment = () => {
  count.update((v) => v + 1);
};
const reset = () => {
  count.set(0);
};
</script>

<p>
	{$count} * 2 = {$count2}
</p>

<button on:click="{increment}">
	increment
</button>
<button on:click="{reset}">
	reset
</button>
```

```js
// store.js
import { writable } from "svelte/store";

export const count = writable(0);
export const count2 = derived(count, (value) => value * 2);
```

#### Custom

```html
<!-- App.svelte -->
<script>
import { count } from "./store.js";
</script>

<p>
	{$count}
</p>

<button on:click="{count.increment}">
	increment
</button>
<button on:click="{count.decrement}">
	increment
</button>
<button on:click="{count.reset}">
	reset
</button>
```

```js
import { writable } from "svelte/store";

function createCount() {
  const { subscribe, set, update } = writable(0);

  return {
    subscribe,
    increment: () => {},
    decrement: () => {},
    reset: () => {},
  };
}

export const count = createCount();
```

#### Slot

```html
<!-- App.svelte -->
<script>
import Box from "./Box.svelte";
import Box2 from "./Box2.svelte";
</script>

<!-- basic -->
<Box>slot</Box>
<!-- default -->
<Box />
<!-- name -->
<Box2>
	<span slot="heading">title</span>
</Box2>
<Box2>
	<span slot="content">div balabala</span>
</Box2>

<!-- Box.svelte -->
<div>
	<slot>
		<p>default value</p>
	</slot>
</div>

<!-- Box2.svelte -->
<div>
	<h1>
		<slot name="heading" />
	</h1>
	<p>
		<slot name="content" />
	</p>
</div>
```



---
url: /note/test/index.md
---

# 测试

## 测试种类

- 单元测试(Unit Test)

  每个模块或者函数进行测试

- 集成测试(Integration Testing)

  验证每个单元之间传递的正确性和实现性

- 用户验收测试(User Acceptance Test)

  根据环境来进行功能以及性能的测试

- 系统测试(System Testing)

  用户自己来测试是否达到需求

- 黑盒测试(数据驱动测试)

  不需要知道软件的具体代码， 数据的输入和输出

- 白盒测试(单元测试)

  程序员自己根据代码来写实现

## 测试工具

### Client/Server 自动化

- qtp
- winrunner(IBM)
- autoit

### 功能测试

- jest(vitest)
- Coverage
- Unit Test
- Integration Test (Module Integration Test)

### 界面测试

- cypress
- pupptter

### 兼容性

- 跨浏览器(包括手机端) **https://www.browserstack.com/**
- 软件环境(版本环境)
- 硬件环境
- 系统环境

### 性能测试

- loadrunner
- lighthouse **https://developers.google.com/web/tools/lighthouse/**
- pagespeed **https://developers.google.com/speed/pagespeed/insights/**

```sh
brew install wrk
wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html

npm install -g loadtest
loadtest http://localhost:8054/test -t 20 -c 100
```

### 接口测试

- Jmeter
- postman
- SoapUI

### 网络测试

- lxia
- wireshark
- tc
- iperf
- tcpping

### web 安全测试

- appscan
- Netsparker community Edition
- Websecurify
- Wapiti
- N-Stalker Free Version
- Scrawlr
- Watcher
- WebScrab
- 授权测试

### 抓包

- fiddler
- burpsuite
- reqable


## 其他
### 提升产品质量

- 编写测试用例并且加强对应的一个评审
- 加强对需求的理解
- 加强对问题的跟进
- 交叉测试

### Mock 的好处

1. 由于其他系统模块出错引起本模块的测试错误，我们可以采用 mock 隔离，避免干预；
2. 开发过程中，只要交互双方定义好接口，团队之间可以并行工作，进程互不影响；
3. 依赖系统无法响应，或者响应异常时，可以用 mock Object 代替，快速反应，不会影响测试进度；
4. 提前接入测试，提供测试效率，当接口定义好后，测试人员就可以创建 Mock，把接口添加到自动化测试环境，提前开始测试，起到测试驱动开发效果；
5. 可以有效的增加覆盖，接口涉及入参，或者业务逻辑复杂的情况，某些场景无法通过正常手段进行操作，可以通过 mock 虚拟模拟；

### 易用性 - Easy of Use

- 符合标准和规范
- 直观
- 一致
- 灵活
- 舒适
- 正确
- 实用



---
url: /note/test/jest.md
---

# Jest

### Install

```sh
npm i --save-dev jest
# 如果你在代码中使用了新的语法特性，而当前 Node 版本不支持，则需要使用 Babel 进行转义。
npm i --save-dev babel-jest @babel/core @babel/preset-env
npm i --save-dev identity-obj-proxy
npm i --save-dev react-test-renderer
npm i --save-dev enzyme enzyme-adapter-react-16 enzyme-to-json
npm i --save-dev @testing-library/react
```

### .babelrc.js

```js
const config = {
  presets: ["@babel/preset-env", "@babel/preset-react"],
  plugins: [],
};
if (process.env.NODE_ENV === "production") {
  config.presets.push([
    "minify",
    {
      removeConsole: true,
    },
  ]);
}
module.exports = config;
```

### jest.config.js

```js
module.exports = {
  testEnvironment: "node",
  transform: {
    "^.+\\.jsx?$": "babel-jest",
  },
  moduleNameMapper: {
    "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "./mocks/fileMock.js",
    "\\.(css|less|styl)$": "identity-obj-proxy",
  },
  snapshotSerializers: ["enzyme-to-json/serializer"],
  setupFiles: ["./setupTest.js"],
};
```

VScode - https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest

ts-jest - https://github.com/kulshekhar/ts-jest

### mocks/fileMock.js

```json
module.exports = '';
```

### setupTest.js

```js
import { configure } from "enzyme";
import Adapter from "enzyme-adapter-react-16";
configure({ adapter: new Adapter() });
```

### 基本用法

```js
import fn from "./someFunction";
describe("测试描述", () => {
  test("dao", () => {
    expect(fn("dao")).toEqual("daodao");
  });
  test("lang", () => {
    expect(fn("lang")).toEqual("langdao");
  });
});

// 异步
// .resolves
test("resolves to lemon", () => {
  // make sure to add a return statement
  return expect(Promise.resolve("lemon")).resolves.toBe("lemon");
});
// .rejects
test("rejects to octopus", () => {
  // make sure to add a return statement
  return expect(Promise.reject(new Error("octopus"))).rejects.toThrow("octopus");
});
```

### 比较

`toBe` 使用 [Object.is](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 判断是否严格相等。

`toEqual` 递归检查对象或数组的每个字段。

`toBeNull` 只匹配 `null`。

`toBeUndefined` 只匹配 `undefined`。

`toBeDefined` 只匹配非 `undefined`。

`toBeTruthy` 只匹配真。

`toBeFalsy` 只匹配假。

`toBeGreaterThan` 实际值大于期望。

`toBeGreaterThanOrEqual` 实际值大于或等于期望值

`toBeLessThan` 实际值小于期望值。

`toBeLessThanOrEqual` 实际值小于或等于期望值。

`toBeCloseTo` 比较浮点数的值，避免误差。

`toMatch` 正则匹配。

`toContain` 判断数组中是否包含指定项。

`.toHaveProperty(keyPath, value)` 判断对象中是否包含指定属性。

`toThrow` 判断是否抛出指定的异常。

`toBeInstanceOf` 判断对象是否是某个类的实例，底层使用 `instanceof`。

### extends sample

```js
const expect = require("expect");

const toMatchAllText = (props, textList) => {
  let isMatchText = true;
  let noMatchtextList = [];
  for (const text of textList) {
    try {
      props.getByText(text);
    } catch {
      isMatchText = false;
      noMatchtextList.push(text);
    }
  }
  if (isMatchText) {
    return {
      message: () => "success",
      pass: true,
    };
  }
  return {
    message: () => `not match some text "${noMatchtextList.join(", ")}"`,
    pass: false,
  };
};

expect.extend({ toMatchAllText: toMatchAllText });

// expect(props.getByTestId('01').innerHTML).toMatchAllText('헤딩 타이틀');
```



---
url: /note/test/react.md
---

# React Test Sample

### basic

```jsx
// Button.jsx
import React, { useState } from "react";
import s from "./style.styl";

const Button = ({ text = "버튼" }) => {
  const [isActive, setActive] = useState(false);
  return (
    <button
      type="button"
      className={isActive ? s.active : ""}
      onClick={() => setActive(!isActive)}
    >
      {text}
    </button>
  );
};

export default Button;

// Button.test.js
import React from "react";
import { shallow } from "enzyme";
import Button from "./";

describe("测试组件", () => {
  const component = shallow(<Button text="확인" />);

  test("default componet", () => {
    expect(component).toMatchSnapshot();
    expect(component.props().className).toEqual("");
  });
  test("component clicked", () => {
    expect(component).toMatchSnapshot();
    component.find("button").at(0).simulate("click");
    expect(component.props().className).toEqual("active");
  });
});
```

### redux

```jsx
// page1/redux.jsx
export const NEXT_COUNT = "NEXT_COUNT";
export const PREV_COUNT = "PREV_COUNT";

export const setCount = (type) => ({
  type: type === "next" ? NEXT_COUNT : PREV_COUNT,
});

export const countReducer = (state = 0, action) => {
  if (action.type === NEXT_COUNT) {
    return state + 1;
  }
  if (action.type === PREV_COUNT) {
    return state - 1;
  }
  return state;
};

// page1/redux.test.js
import { NEXT_COUNT, PREV_COUNT, setCount, countReducer } from "./redux";

describe("PAGE1 测试redux", () => {
  test("action creator test", () => {
    expect(setCount("next")).toEqual({ type: NEXT_COUNT });
    expect(setCount("prev")).toEqual({ type: PREV_COUNT });
  });

  test("reducer test", () => {
    expect(countReducer(0, { type: NEXT_COUNT })).toEqual(1);
    expect(countReducer(10, { type: NEXT_COUNT })).toEqual(11);
    expect(countReducer(-10, { type: NEXT_COUNT })).toEqual(-9);

    expect(countReducer(0, { type: PREV_COUNT })).toEqual(-1);
    expect(countReducer(10, { type: PREV_COUNT })).toEqual(9);
    expect(countReducer(-10, { type: PREV_COUNT })).toEqual(-11);
  });
});
```



---
url: /note/test/test.md
---

# 测试最佳实践(中文)

一段测试代码需要做到让人一眼就能看出其目的。

## 方法

- 3 个部分(测试什么/什么环境/期望结果)
- AAA 模式构造内容(Arrange/Act/Assert 准备/执行/断言)
- 描述期望(Bdd 形式断言) https://jestjs.io/docs/expect#expectextendmatchers
- TDD
- UI 与功能分离(AAA)
- 测试用例标签(npx jest -t=#dao)

## mock

- 优先使用真实数据， 特定情况下使用 mock
- mock 尽量与真实数据同步
- 工具
  - sinon
  - test double
  - https://www.npmjs.com/package/faker

## type

- 基于属性的测试， 测试输入的多种组合

## DOM Tip

- 使用不太容易改变的属性去查询 HTML 元素

## 避免

- 坚持 public 方法, 减少 private 方法
- 尽量使用最短的 Snapshot
- 尽量避免全局的 fixtures 和 seeds(每条测试需要在它自己的 DB 行中运行避免互相污染)
- 不要 catch 错误而是 expect
- 不要 sleep，使用框架内置的对 async 事件的支持。并且尝试提效。(https://testing-library.com/docs/guide-disappearance/)

## 手动道具

- lighthouse https://developers.google.com/web/tools/lighthouse/
- pagespeed https://developers.google.com/speed/pagespeed/insights/

## E2E (https://github.com/puppeteer/puppeteer)

- 写几个跨越整个系统的端到端测试
- 通过复用登录凭证提速 E2E 测试
- 创建一个 E2E 冒烟测试，仅仅走一遍网站地图

## 测试报告

- 将测试以实时协作文档的形式公开(Storybook) https://storybook.js.org/addons/@storybook/addon-jest
- 检查覆盖率报告，以发现未覆盖的区域和其他奇怪的地方(coverage)
- 使用「变异测试」度量逻辑覆盖率????
- 使用 Test linter 防止测试代码问题

## CI 以及其他

- 丰富你的 linter 并丢弃有 lint 问题的构建
- 通过本地的开发 CI 来缩短反馈循环(husky)
- 在真实的生产环境镜像中执行端到端测试
- 并行测试工作
- 使用许可证和抄袭检查避免法务问题 (https://www.npmjs.com/package/license-checker)
- 持续检查有漏洞的依赖
- 自动升级依赖????
- 使用多个 Node 版本执行同一个 CI 流程(质量检查是用于发现意外，你覆盖的部分越多，你就越可能尽早地发现问题。 在开发包或运行具有各种配置和 Node 版本的多客户生产环境时，CI 必须在所有配置的组合上运行测试管道。)



---
url: /note/test/test_kr.md
---

# 테스트 베스트 프래틱스

한구간 테스트 코드로 한눈에 목적을 이해할수 있게 해야한다.

## 방법

- 3개부분(무엇을 테스트 할것인가?/어떤 환경에서 진행되는가?/기대하는 결과는?)
- AAA구조로 내용 구성(Arrange/Act/Assert 준비/실행/주장)
- except 요약하기 (Bdd 형식의 expect) https://jestjs.io/docs/expect#expectextendmatchers
- TDD
- UI와 기능 분리(AAA)
- 테스트 케이스 태그(npx jest -t=#dao)

## mock

- 우선 real데이터를 사용, 특정경우에만 mock사용
- mock데이터는 real데이터와 일치
- 도구
  - sinon
  - test double
  - https://www.npmjs.com/package/faker

## type

- 속성 기반 테스트, 여러조합 입력

## DOM Tip

- static한 속성을 활용해서 HTML 요소에 접근

## 주의사항

- public fn에 대해서만 테스트 하고 private fn은 최소한 으로 진행
- Snapshot 요소는 작을수록 좋음.
- 전역에 사용되는 fixtures와seeds는 피하자(매개 테스트는 독립적인 환경에서 실행)
- 에러를 expect 권장, catch금지
- no sleep, 프레임워크내 async 적극활용,(https://testing-library.com/docs/guide-disappearance/)

## 수동도구

- lighthouse https://developers.google.com/web/tools/lighthouse/
- pagespeed https://developers.google.com/speed/pagespeed/insights/

## E2E (https://github.com/puppeteer/puppeteer)

- 몇개 크로스시스템 테스트 케이스 작성.
- 로그인 token을 중복 활용해서 E2E 진행
- E2E Smoke Test를 통해서 사이트맵 한번씩 접근.

## 테스트 보고서

- 테스트 결과를 실시간으로 확인할수 있는 시스템 구축(Storybook) https://storybook.js.org/addons/@storybook/addon-jest
- Coverage 결과를 기준으로 미확인 부분 및 이상한 부분 찾기
- 使用「变异测试」度量逻辑覆盖率???? 4.3
- test코드도 lint를 통해서 코드 품질 향상.



---
url: /note/test/vitest.md
---

# vitest

#### vite.config.js

```js
import { defineConfig } from "vite";
import path from "path";
import react from "@vitejs/plugin-react";

export default defineConfig({
  root: "./src",
  build: {
    outDir: "../dist",
    emptyOutDir: true,
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  plugins: [react()],
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: "./test/setup.ts",
    css: true,
  },
});
```

### package.json

```json
{
  "scripts": {
    "test": "vitest",
    "coverage": "vitest run --coverage"
  },
  "devDependencies": {
    "@testing-library/react": "^13.3.0",
    "@vitejs/plugin-react": "^1.1.4",
    "jsdom": "^20.0.0",
    "vite": "^2.7.13",
    "vitest": "^0.22.1"
  }
}
```

### src/test/setup.ts

```ts
import { expect } from "vitest";

const toMatchAllText = (props, textList) => {
  let isMatchText = true;
  let noMatchtextList = [];

  for (const text of textList) {
    if (!props.innerHTML.includes(text)) {
      isMatchText = false;
      noMatchtextList.push(text);
    }
  }
  if (isMatchText) {
    return {
      message: () => "success",
      pass: true,
    };
  }
  return {
    message: () => `not match some text "${noMatchtextList.join(", ")}"`,
    pass: false,
  };
};

expect.extend({ toMatchAllText });
```



---
url: /mark/escpos.md
---

# ESC/POS 프린터 명령어 문서

## 기본 제어 문자
- `LF (\x0a)`: 라인 피드 (줄바꿈)
- `FS (\x1c)`: 필드 구분자 
- `FF (\x0c)`: 폼 피드 (페이지 넘김)
- `GS (\x1d)`: 그룹 구분자
- `DLE (\x10)`: 데이터 링크 이스케이프
- `EOT (\x04)`: 전송 종료
- `NUL (\x00)`: Null 문자
- `ESC (\x1b)`: 이스케이프 시퀀스 시작
- `TAB (\x74)`: 탭
- `EOL (\n)`: 줄 끝

## 피드 제어 시퀀스
- `CTL_LF (\x0a)`: 인쇄 후 줄바꿈
- `CTL_GLF (\x4a\x00)`: 줄 간격 없이 인쇄 및 용지 공급
- `CTL_FF (\x0c)`: 폼 피드
- `CTL_CR (\x0d)`: 캐리지 리턴
- `CTL_HT (\x09)`: 수평 탭
- `CTL_VT (\x0b)`: 수직 탭

## 문자 간격
- `CS_DEFAULT (\x1b\x20\x00)`: 기본 문자 간격으로 설정
- `CS_SET (\x1b\x20)`: 문자 간격 설정

## 줄 간격
- `LS_DEFAULT (\x1b\x32)`: 기본 줄 간격으로 설정
- `LS_SET (\x1b\x33)`: 줄 간격 설정

## 하드웨어 제어
- `HW_INIT (\x1b\x40)`: 버퍼 데이터 삭제 및 모드 초기화
- `HW_SELECT (\x1b\x3d\x01)`: 프린터 선택
- `HW_RESET (\x1b\x3f\x0a\x00)`: 프린터 하드웨어 리셋

## 금전함 제어
- `CD_KICK_2 (\x1b\x70\x00\x19\x78)`: 2번 핀으로 펄스 신호 전송
- `CD_KICK_5 (\x1b\x70\x01\x19\x78)`: 5번 핀으로 펄스 신호 전송

## 여백 설정
- `BOTTOM (\x1b\x4f)`: 하단 여백 설정
- `LEFT (\x1b\x6c)`: 좌측 여백 설정
- `RIGHT (\x1b\x51)`: 우측 여백 설정

## 용지 컷팅
- `PAPER_FULL_CUT (\x1d\x56\x00)`: 용지 완전 절단
- `PAPER_PART_CUT (\x1d\x56\x01)`: 용지 부분 절단
- `PAPER_CUT_A (\x1d\x56\x41)`: A 타입 부분 절단
- `PAPER_CUT_B (\x1d\x56\x42)`: B 타입 부분 절단
- `STAR_FULL_CUT (\x1B\x64\x02)`: STAR 프린터용 완전 절단

## 텍스트 포맷
### 기본 포맷
- `TXT_NORMAL (\x1b\x21\x00)`: 일반 텍스트
- `TXT_2HEIGHT (\x1b\x21\x10)`: 2배 높이 텍스트
- `TXT_2WIDTH (\x1b\x21\x20)`: 2배 너비 텍스트
- `TXT_4SQUARE (\x1b\x21\x30)`: 2배 높이 및 너비 텍스트
- `STAR_TXT_EMPHASIZED (\x1B\x45)`: STAR 프린터용 강조 텍스트
- `STAR_CANCEL_TXT_EMPHASIZED (\x1B\x46)`: STAR 프린터용 강조 취소

### 텍스트 스타일
- `TXT_UNDERL_OFF (\x1b\x2d\x00)`: 밑줄 해제
- `TXT_UNDERL_ON (\x1b\x2d\x01)`: 1점 밑줄 설정
- `TXT_UNDERL2_ON (\x1b\x2d\x02)`: 2점 밑줄 설정
- `TXT_BOLD_OFF (\x1b\x45\x00)`: 굵은 글씨 해제
- `TXT_BOLD_ON (\x1b\x45\x01)`: 굵은 글씨 설정
- `TXT_ITALIC_OFF (\x1b\x35)`: 이탤릭체 해제
- `TXT_ITALIC_ON (\x1b\x34)`: 이탤릭체 설정

### 글꼴 설정
- `TXT_FONT_A (\x1b\x4d\x00)`: A 글꼴
- `TXT_FONT_B (\x1b\x4d\x01)`: B 글꼴
- `TXT_FONT_C (\x1b\x4d\x02)`: C 글꼴

### 정렬
- `TXT_ALIGN_LT (\x1b\x61\x00)`: 왼쪽 정렬
- `TXT_ALIGN_CT (\x1b\x61\x01)`: 가운데 정렬
- `TXT_ALIGN_RT (\x1b\x61\x02)`: 오른쪽 정렬

### STAR 프린터 정렬
- `STAR_TXT_ALIGN_LA (\x1B\x1D\x61\x00)`: 왼쪽 정렬
- `STAR_TXT_ALIGN_CA (\x1B\x1D\x61\x01)`: 가운데 정렬
- `STAR_TXT_ALIGN_RA (\x1B\x1D\x61\x02)`: 오른쪽 정렬

## 바코드 포맷
### 텍스트 위치
- `BARCODE_TXT_OFF (\x1d\x48\x00)`: HRI 문자 표시 안함
- `BARCODE_TXT_ABV (\x1d\x48\x01)`: HRI 문자 위쪽 표시
- `BARCODE_TXT_BLW (\x1d\x48\x02)`: HRI 문자 아래쪽 표시
- `BARCODE_TXT_BTH (\x1d\x48\x03)`: HRI 문자 위아래 표시

### 바코드 글꼴
- `BARCODE_FONT_A (\x1d\x66\x00)`: A 글꼴
- `BARCODE_FONT_B (\x1d\x66\x01)`: B 글꼴

### 바코드 타입
- `BARCODE_UPC_A (\x1d\x6b\x00)`: UPC-A
- `BARCODE_UPC_E (\x1d\x6b\x01)`: UPC-E
- `BARCODE_EAN13 (\x1d\x6b\x02)`: EAN13
- `BARCODE_EAN8 (\x1d\x6b\x03)`: EAN8
- `BARCODE_CODE39 (\x1d\x6b\x04)`: CODE39
- `BARCODE_ITF (\x1d\x6b\x05)`: ITF
- `BARCODE_NW7 (\x1d\x6b\x06)`: NW7
- `BARCODE_CODE93 (\x1d\x6b\x48)`: CODE93
- `BARCODE_CODE128 (\x1d\x6b\x49)`: CODE128

## 2D 코드 포맷
### 타입
- `TYPE_PDF417`: PDF417 바코드
- `TYPE_DATAMATRIX`: Data Matrix
- `TYPE_QR`: QR 코드

### QR 코드 오류 수정 레벨
- `QR_LEVEL_L`: 7% 오류 수정
- `QR_LEVEL_M`: 15% 오류 수정
- `QR_LEVEL_Q`: 25% 오류 수정
- `QR_LEVEL_H`: 30% 오류 수정

## 이미지 포맷
- `S_RASTER_N`: 일반 크기 래스터 이미지
- `S_RASTER_2W`: 2배 너비 래스터 이미지
- `S_RASTER_2H`: 2배 높이 래스터 이미지
- `S_RASTER_Q`: 4배 크기 래스터 이미지

## 비트맵 포맷
- `BITMAP_S8`: 8-bit 단일 밀도
- `BITMAP_D8`: 8-bit 이중 밀도
- `BITMAP_S24`: 24-bit 단일 밀도
- `BITMAP_D24`: 24-bit 이중 밀도

## 색상 설정
- `0 (\x1b\x72\x00)`: 검정색
- `1 (\x1b\x72\x01)`: 빨간색
- `REVERSE (\x1dB1)`: 색상 반전 (흰색 텍스트, 검은 배경)
- `UNREVERSE (\x1dB0)`: 색상 반전 해제 (검은 텍스트, 흰색 배경)




---
url: /mark/guideline/commits.md
---

# Conventional Commits

### 참고

- https://www.conventionalcommits.org/en/v1.0.0/


#### 컨벤션 스타일

- @commitlint/config-angular
- @commitlint/config-conventional
- @commitlint/config-lerna-scopes
- @commitlint/config-nx-scopes
- @commitlint/config-patternplate
- conventional-changelog-lint-config-atom
- conventional-changelog-lint-config-canonical
- commitlint-config-jira


---
url: /mark/guideline/frontend-checklist.md
---

# Front-End Checklist

### 참고

- https://github.com/thedaviddias/Front-End-Checklist



---
url: /mark/guideline/node.md
---

# Nodejs Best Practices

### 참고

- https://github.com/goldbergyoni/nodebestpractices/tree/master



---
url: /mark/guideline/project.md
---

# Project Guidelines 

### 참고

- https://github.com/elsewhencode/project-guidelines



---
url: /mark/guideline/review.md
---

# Code Review(js/ts)
- 새로운 종속성 검토
- 라이브러리 중복 방지
- 가져오기 관행 검증
- 번역 검증(새로 추가된 영역이 제대로 지역화되었는지 확인)
- 적절한 타이핑 적용
- 명명 규칙 확인
- 부울 접두사 사용(부울 의도를 명확히 하기 위해 is, are 또는 should 사용)
- 함수 이름은 함수가 수행하거나 반환하는 내용을 설명해야 합니다.
- 지나치게 복잡한 로직 주의
- 장황한 코드 간소화
- 모호한 코드에 대한 문의
- 하드코딩된 값 사용 금지(경로, 이름, 값을 상수 또는 구성으로 이동)
- 이전 버전과의 호환성 유지
- 반복적인 로직 제거
- 폼 유효성 검사 확인
- 누락되었거나 처리되지 않은 try/catch 블록 확인
- 비동기 작업이 효율적이고 올바르게 처리되는지 확인
- 이전 개발 경험을 활용하여 코드 개선 방향 제시


---
url: /mark/guideline/semver.md
---

# Semantic Versioning

### 참고

- https://semver.org/



---
url: /mark/guideline/test.md
---

# Javascript Testing Best Practices

### 참고

- https://github.com/goldbergyoni/javascript-testing-best-practices



---
url: /mark/guideline/wcag.md
---

# Web Content Accessibility Guidelines

### 참고

- http://www.kwacc.or.kr/WAI/wcag21/



---
url: /mark/index.md
---

# Mark

- [得物商家客服从 Electron 迁移到 Tauri 的技术实践](https://mp.weixin.qq.com/s/UxmJxU4-fv9GeRxl2fzOGw)
- [RFC: JSON Merge](https://datatracker.ietf.org/doc/html/rfc7396)
- [Web 3D 引擎 galacean](https://galacean.antgroup.com/engine)
- [Deeper Dive Into React](https://jser.pro/)
- [source-map](https://github.com/mozilla/source-map)
- [source-map 설명](https://web.dev/articles/source-maps?hl=ko)
- [source-map-visualization](https://sokra.github.io/source-map-visualization/)
- [WHATWG-Standards](https://spec.whatwg.org/)
- [Google Style Guides(html, css, js, ts ...)](https://google.github.io/styleguide/)
- [AngularJS Git Commit Message Conventions](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit?tab=t.0#heading=h.uyo6cb12dt6w)
- [贡献者公约 Contributor Covenant Translations](https://www.contributor-covenant.org/translations/)
- [Github Community Guidelines](https://docs.github.com/en/site-policy/github-terms/github-community-guidelines)
- [JavaScript Standard Style](https://standardjs.com/)
- [Fake Images](https://fakeimg.pl/)
- [Dynamic DummyImage Generator](https://dummyimage.com/)
- [JavaScript Patterns](https://www.dofactory.com/javascript/design-patterns)
- [creativecommons](https://creativecommons.org/publicdomain/zero/1.0/deed.ko)
- [Test your front-end against a real API](https://reqres.in/)
- [JSON Schema Validator](https://www.jsonschemavalidator.net/)
- [Emmet](https://emmet.io/)
- [ColorSpace](https://mycolor.space/?hex=%23573491&sub=1)
- [Google SEO](https://developers.google.com/search/docs?hl=zh-cn)
- [Web Platform Incubator Community Group](https://wicg.io/)
- [The HTTP Archive Tracks How the Web is Built](https://httparchive.org/)
- [Tauri VS Electron 启动性能 PK](https://zhuanlan.zhihu.com/p/704967001)

# Education

- [fullstackopen](https://fullstackopen.com/zh/about/)
- [Rust Course](https://course.rs/)
- [Rusty Book](https://rusty.course.rs/)

# React core

- https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkzMjIxNTcyMA==&action=getalbum&album_id=1783121402896678912&subscene=159&subscene=&scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUC022AC-O506ueFykZyWbQ&nolastread=1#wechat_redirect
- https://react.iamkasong.com/
- https://www.qinguanghui.com/

# npm packages

- https://www.npmjs.com/package/jsbarcode
- https://www.npmjs.com/package/qrcode
- https://www.npmjs.com/package/dexie
- https://www.npmjs.com/package/localforage
- https://www.npmjs.com/search?q=node-schedule
- https://www.npmjs.com/package/numeral
- https://www.npmjs.com/package/currency.js
- https://www.npmjs.com/package/print-js
- https://www.npmjs.com/package/jsonpath-plus
- https://www.npmjs.com/package/jimp
- https://www.npmjs.com/package/mitt
- https://www.npmjs.com/package/realm
- https://www.npmjs.com/package/lozad
- https://www.npmjs.com/package/zeromq
- https://www.npmjs.com/package/gcoord
- https://jsrepo.dev/
- https://github.com/DavidHDev/react-bits
- https://www.npmjs.com/package/fs-extra
- https://www.npmjs.com/package/keytar
- https://www.npmjs.com/package/archiver
- https://www.npmjs.com/package/wcwidth



---
url: /mark/word.md
---

# 编程词汇

## A

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| a block of pointers | 一块指针 | 一组指针 |     |
| abbreviation | 缩略语 |     |     |
| abstract | 抽象的 |     |     |
| abstract syntax tree, AST | 抽象语法树 |     |     |
| abstraction | 抽象  |     |     |
| abstraction barrier | 抽象屏障 | 抽象阻碍 |     |
| abstraction of function calls | 函数调用抽象 |     |     |
| access | 访问  | 存取  |     |
| access function | 访问函数 | 存取函数 |     |
| accumulator | 累加器 |     |     |
| activate | 激活  |     |     |
| ad hoc | 专设  |     |     |
| adapter | 适配器 |     |     |
| address | 地址  |     |     |
| algebraic data type | 代数数据类型 |     |     |
| algorithm | 算法  |     |     |
| alias | 别名  |     |     |
| allocate | 分配  | 配置  |     |
| alternative | 备选  |     |     |
| amortized analysis | 平摊分析 |     |     |
| anaphoric | 指代  |     |     |
| annotation | 注解  |     |     |
| anonymous function | 匿名函数 |     |     |
| antecedent | 前提  | 前件  | 先决条件 |
| append | 追加  | 拼接  |     |
| application | 应用  | 应用程序 |     |
| application framework | 应用框架 |     |     |
| application program interface, API | 应用程序编程接口 |     |     |
| application service provider, ASP | 应用程序服务提供商 |     |     |
| applicative | 应用序 |     |     |
| argument | 参数  | 自变量 | 实际参数/实参 |
| arithmetic | 算术  |     |     |
| array | 数组  |     |     |
| artificial intelligence, AI | 人工智能 |     |     |
| assemble | 组合  |     |     |
| assembly | 汇编  |     |     |
| assignment | 赋值  |     |     |
| assignment operator | 赋值操作符 |     |     |
| associated | 关联的 |     |     |
| association list, alist | 关联列表 |     |     |
| atom | 原子  |     |     |
| atomic | 原子的 |     |     |
| atomic value | 原子型值 |     |     |
| attribute | 属性  | 特性  |     |
| augmented | 扩充  |     |     |
| automatic memory management | 自动内存管理 |     |     |
| automatically infer | 自动推导 |     |     |
| autometa theory | 自动机理论 |     |     |
| auxiliary | 辅助  |     |     |

## B

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| backquote | 反引用 |     |     |
| backtrace | 回溯  |     |     |
| backward compatible | 向下兼容 |     |     |
| bandwidth | 带宽  |     |     |
| base case | 基本情形 |     |     |
| base class | 基类  |     |     |
| Bayes' theorem | 贝叶斯定理 |     |     |
| best viable function | 最佳可行函式 | 最佳可行函数 |     |
| Bezier curve | 贝塞尔曲线 |     |     |
| bignum | 大数  |     |     |
| binary operator | 二元操作符 |     |     |
| binary search | 二分查找 | 二分搜索 | 二叉搜索 |
| binary search tree | 二叉搜索树 |     |     |
| binary tree | 二叉树 |     |     |
| binding | 绑定  |     |     |
| binding vector | 绑定向量 |     |     |
| bit | 位   | 比特  |     |
| bit manipulation | 位操作 |     |     |
| black box abstraction | 黑箱抽象 |     |     |
| block | 块   | 区块  |     |
| block structure | 块结构 | 区块结构 |     |
| block name | 代码块名字 |     |     |
| Blub paradox | Blub 困境 |     |     |
| body | 体   | 主体  |     |
| boilerplate | 公式化 | 样板  |     |
| bookkeeping | 簿记  |     |     |
| boolean | 布尔  |     |     |
| border | 边框  |     |     |
| bottom-up design | 自底向上的设计 |     |     |
| bottom-up programming | 自底向上编程 |     |     |
| bound | 边界  |     |     |
| bounds checking | 边界检查 |     |     |
| box notation | 箱子表示法 |     |     |
| brace | 花括弧 | 花括号 |     |
| bracket | 方括弧 | 方括号 |     |
| branch | 分支  | 跳转  |     |
| breadth-first | 广度优先 |     |     |
| breadth-first search, BFS | 广度优先搜索 |     |     |
| breakpoint | 断点  |     |     |
| brevity | 简洁  |     |     |
| buffer | 缓冲区 |     |     |
| buffer overflow attack | 缓冲区溢出攻击 |     |     |
| bug | 臭虫  |     |     |
| building | 创建  |     |     |
| built-in | 内置  |     |     |
| byte | 字节  |     |     |
| bytecode | 字节码 |     |     |

## C

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| cache | 缓存  |     |     |
| call | 调用  |     |     |
| callback | 回调  |     |     |
| CamelCase | 驼峰式大小写 |     |     |
| candidate function | 候选函数 |     |     |
| capture | 捕捉  |     |     |
| case | 分支  |     |     |
| character | 字符  |     |     |
| checksum | 校验和 |     |     |
| child class | 子类  |     |     |
| choke point | 滞塞点 |     |     |
| chunk | 块   |     |     |
| circular definition | 循环定义 |     |     |
| clarity | 清晰  |     |     |
| class | 类   | 类别  |     |
| class declaration | 类声明 |     |     |
| class library | 类库  |     |     |
| client | 客户  | 客户端 |     |
| clipboard | 剪贴板 |     |     |
| clone | 克隆  |     |     |
| closed world assumption | 封闭世界假定 |     |     |
| closure | 闭包  |     |     |
| clutter | 杂乱  |     |     |
| code | 代码  |     |     |
| code bloat | 代码膨胀 |     |     |
| collection | 收集器 | 复合类型 |     |
| column | 行   | 栏   |     |
| column-major order | 行主序 |     |     |
| comma | 逗号  |     |     |
| command-line | 命令行 |     |     |
| command-line interface, CLI | 命令行界面 |     |     |
| Common Lisp Object System, CLOS | Common Lisp 对象系统 |     |     |
| Common Gateway Interface, CGI | 通用网关接口 |     |     |
| compatible | 兼容  |     |     |
| compilation | 编译  |     |     |
| compilation parameter | 编译参数 |     |     |
| compile | 编译  |     |     |
| compile inline | 内联编译 |     |     |
| compile time | 编译期 |     |     |
| compiled form | 编译后的形式 |     |     |
| compiler | 编译器 |     |     |
| complex | 复杂  |     |     |
| complexity | 复杂度 |     |     |
| compliment | 补集  |     |     |
| component | 组件  |     |     |
| composability | 可组合性 |     |     |
| composition | 组合  | 组合函数 |     |
| compound value | 复合数据 | 复合值 |     |
| compression | 压缩  |     |     |
| computation | 计算  |     |     |
| computer | 计算机 |     |     |
| concatenation | 串接  |     |     |
| concept | 概念  |     |     |
| concrete | 具体  |     |     |
| concurrency | 并发  |     |     |
| concurrent | 并发  |     |     |
| conditional | 条件式 |     |     |
| conditional variable | 条件变量 |     |     |
| configuration | 配置  |     |     |
| connection | 连接  |     |     |
| cons | 构造  |     |     |
| cons cell | 构元  | cons 单元 |     |
| consequent | 结果  | 推论  |     |
| consistent | 一致性 |     |     |
| constant | 常量  |     |     |
| constraint | 约束  |     |     |
| constraint programming | 约束式编程 |     |     |
| container | 容器  |     |     |
| content-based filtering | 基于内容的过滤 |     |     |
| context | 上下文 | 语境  | 环境  |
| continuation | 延续性 |     |     |
| continuous integration, CI | 持续集成 |     |     |
| control | 控件  |     |     |
| cooperative multitasking | 协作式多任务 |     |     |
| copy | 拷贝  |     |     |
| corollary | 推论  |     |     |
| coroutine | 协程  |     |     |
| corruption | 程序崩溃 |     |     |
| crash | 崩溃  |     |     |
| create | 创建  |     |     |
| crystallize | 固化  |     |     |
| curly | 括弧状的 |     |     |
| curried | 柯里的 |     |     |
| currying | 柯里化 |     |     |
| cursor | 光标  |     |     |
| curvy | 卷曲的 |     |     |
| cycle | 周期  |     |     |

## D

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| dangling pointer | 迷途指针 | 野指针 |     |
| Defense Advanced Research Projects Agency, DARPA | 美国国防部高级研究计划局 |     |     |
| data | 数据  |     |     |
| data structure | 数据结构 |     |     |
| data type | 数据类型 |     |     |
| data-driven | 数据驱动 |     |     |
| database | 数据库 |     |     |
| database schema | 数据库模式 |     |     |
| datagram | 数据报文 |     |     |
| dead lock | 死锁  |     |     |
| debug | 调试  |     |     |
| debugger | 调试器 |     |     |
| debugging | 调试  |     |     |
| declaration | 声明  |     |     |
| declaration forms | 声明形式 |     |     |
| declarative | 声明式 | 说明式 |     |
| declarative knowledge | 声明式知识 | 说明式知识 |     |
| declarative programming | 声明式编程 | 说明式编程 |     |
| declarativeness | 可声明性 |     |     |
| declaring | 声明  |     |     |
| deconstruction | 解构  |     |     |
| deduction | 推导  | 推断  |     |
| default | 缺省  | 默认  |     |
| defer | 推迟  |     |     |
| deficiency | 缺陷  | 不足  |     |
| define | 定义  |     |     |
| definition | 定义  |     |     |
| delegate | 委托  |     |     |
| delegation |     |     |     |
| dellocate | 释放  |     |     |
| demarshal | 散集  |     |     |
| deprecated | 废弃  |     |     |
| depth-first | 深度优先 |     |     |
| depth-first search, DFS | 深度优先搜索 |     |     |
| derived | 派生  |     |     |
| derived class | 派生类 |     |     |
| design pattern | 设计模式 |     |     |
| designator | 指示符 |     |     |
| destructive | 破坏性的 |     |     |
| destructive function | 破坏性函数 |     |     |
| destructuring | 解构  |     |     |
| device driver | 硬件驱动程序 |     |     |
| dimensions | 维度  |     |     |
| directive | 指令  |     |     |
| directive | 指示符 |     |     |
| directory | 目录  |     |     |
| disk | 盘   |     |     |
| dispatch | 分派  | 派发  |     |
| distributed computing | 分布式计算 |     |     |
| DLL hell | DLL 地狱 |     |     |
| document | 文档  |     |     |
| dotted list | 点状列表 |     |     |
| dotted-pair notation | 带点尾部表示法 | 带点尾部记法 |     |
| duplicate | 复本  |     |     |
| dynamic binding | 动态绑定 |     |     |
| dynamic extent | 动态范围 |     |     |
| dynamic languages | 动态语言 |     |     |
| dynamic scope | 动态作用域 |     |     |
| dynamic type | 动态类型 |     |     |

## E

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| effect | 效果  |     |     |
| efficiency | 效率  |     |     |
| efficient | 高效  |     |     |
| elaborate |     |     |     |
| elucidating |     |     |     |
| embedded language | 嵌入式语言 |     |     |
| emulate | 仿真  |     |     |
| encapsulation | 封装  |     |     |
| enum | 枚举  |     |     |
| enumeration type | 枚举类型 |     |     |
| enumrators | 枚举器 |     |     |
| environment | 环境  |     |     |
| equal | 相等  |     |     |
| equality | 相等性 |     |     |
| equation | 方程  |     |     |
| equivalence | 等价性 |     |     |
| error message | 错误信息 |     |     |
| error-checking | 错误检查 |     |     |
| escaped | 逃脱  | 溢出  |     |
| escape character | 转义字符 |     |     |
| evaluate | 求值  | 评估  |     |
| evaluation | 求值  |     |     |
| event | 事件  |     |     |
| event driven | 事件驱动 |     |     |
| exception | 异常  |     |     |
| exception handling | 异常处理 |     |     |
| exception specification | 异常规范 |     |     |
| exit | 退出  |     |     |
| expendable | 可扩展的 |     |     |
| explicit | 显式  |     |     |
| exploratory programming | 探索式编程 |     |     |
| export | 导出  | 引出  |     |
| expression | 表达式 |     |     |
| expressive power | 表达能力 |     |     |
| extensibility | 可扩展性 |     |     |
| extent | 范围  | 程度  |     |
| external representation | 外部表示法 |     |     |
| extreme programming | 极限编程 |     |     |

## F

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| factorial | 阶乘  |     |     |
| family | （类型的）系 |     |     |
| feasible | 可行的 |     |     |
| feature | 特色  |     |     |
| field | 字段  | 栏位  |     |
| file | 文件  |     |     |
| file handle | 文件句柄 |     |     |
| fill pointer | 填充指针 |     |     |
| fineo-grained | 细粒度 |     |     |
| firmware | 固件  |     |     |
| first-class | 第一类的 | 第一级的 | 一等的 |
| first-class function | 第一级函数 | 第一类函数 | 一等函数 |
| first-class object | 第一类的对象 | 第一级的对象 | 一等公民 |
| fixed-point | 不动点 |     |     |
| fixnum | 定长数 | 定点数 |     |
| flag | 标记  |     |     |
| flash | 闪存  |     |     |
| flexibility | 灵活性 |     |     |
| floating-point | 浮点数 |     |     |
| floating-point notation | 浮点数表示法 |     |     |
| flush | 刷新  |     |     |
| fold | 折叠  |     |     |
| font | 字体  |     |     |
| force | 迫使  |     |     |
| form | 形式  |     |     |
| form | 表单  |     |     |
| formal parameter | 形参  |     |     |
| formal relation | 形式关系 |     |     |
| forward | 转发  |     |     |
| forward references |     |     |     |
| fractal | 分形  |     |     |
| fractions | 派系  |     |     |
| framework | 框架  |     |     |
| freeware | 自由软件 |     |     |
| function | 函数  |     |     |
| function literal | 函数字面常量 |     |     |
| function object | 函数对象 |     |     |
| functional arguments | 函数型参数 |     |     |
| functional programming | 函数式编程 |     |     |
| functionality | 功能性 |     |     |

## G

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| game | 游戏  |     |     |
| garbage | 垃圾  |     |     |
| garbage collection | 垃圾回收 |     |     |
| garbage collector | 垃圾回收器 |     |     |
| generalized | 泛化  |     |     |
| generalized variable | 广义变量 |     |     |
| generate | 生成  |     |     |
| generator | 生成器 |     |     |
| generic | 通用的 | 泛化的 |     |
| generic algorithm | 通用算法 | 泛型算法 |     |
| generic function | 通用函数 |     |     |
| generic programming | 通用编程 | 泛型编程 |     |
| genrative programming | 生产式编程 |     |     |
| global | 全局的 |     |     |
| global declaration | 全局声明 |     |     |
| glue program | 胶水程序 |     |     |
| goto | 跳转  |     |     |
| graphical user interface, GUI | 图形用户界面 |     |     |
| greatest common divisor | 最大公因数 |     |     |
| Greenspun's tenth rule | 格林斯潘第十定律 |     |     |

## H

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| hack | 破解  |     |     |
| hacker | 黑客  |     |     |
| handle | 处理器 | 处理程序 | 句柄  |
| hard disk | 硬盘  |     |     |
| hard-wire |     |     |     |
| hardware | 硬件  |     |     |
| hash tables | 哈希表 | 散列表 |     |
| header | 头部  |     |     |
| header file | 头文件 |     |     |
| heap | 堆   |     |     |
| helper | 辅助函数 | 辅助方法 |     |
| heuristic | 启发式 |     |     |
| high-order | 高阶  |     |     |
| higher-order function | 高阶函数 |     |     |
| higher-order procedure | 高阶过程 |     |     |
| hyperlink | 超链接 |     |     |
| HyperText Markup Language, HTML | 超文本标记语言 |     |     |
| HyperText Transfer Protocol, HTTP | 超文本传输协议 |     |     |

## I

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| identical | 一致  |     |     |
| identifier | 标识符 |     |     |
| identity | 同一性 |     |     |
| ill type | 类型不正确 |     |     |
| illusion | 错觉  |     |     |
| imperative | 命令式 |     |     |
| imperative programming | 命令式编程 |     |     |
| implement | 实现  |     |     |
| implementation | 实现  |     |     |
| implicit | 隐式  |     |     |
| import | 导入  |     |     |
| incremental testing | 增量测试 |     |     |
| indent | 缩排  | 缩进  |     |
| indentation | 缩排  | 缩进  |     |
| indented | 缩排  | 缩进  |     |
| indention | 缩排  | 缩进  |     |
| infer | 推导  |     |     |
| infinite loop | 无限循环 |     |     |
| infinite recursion | 无限递归 |     |     |
| infinite precision | 无限精度 |     |     |
| infix | 中序  |     |     |
| information | 信息  |     |     |
| information technology, IT | 信息技术 |     |     |
| inheritance | 继承  |     |     |
| initialization | 初始化 |     |     |
| initialize | 初始化 |     |     |
| inline | 内联  |     |     |
| inline expansion | 内联展开 |     |     |
| inner class | 内嵌类 |     |     |
| inner loop | 内层循环 |     |     |
| input | 输入  |     |     |
| instances | 实例  |     |     |
| instantiate | 实例化 |     |     |
| instructive | 教学性的 |     |     |
| instrument | 记录仪 |     |     |
| integer | 整数  |     |     |
| integrate | 集成  |     |     |
| interactive language | 交互式语言 |     |     |
| interactive programming environment | 交互式编程环境 |     |     |
| interactive testing | 交互式测试 |     |     |
| interacts | 交互  |     |     |
| interface | 接口  |     |     |
| intermediate form | 过渡形式 | 中间形式 |     |
| internal | 内部  |     |     |
| internet | 互联网 | 因特网 |     |
| interpolation | 插值  |     |     |
| interpret | 解释  |     |     |
| interpreter | 解释器 |     |     |
| interrupt | 中止  | 中断  |     |
| intersection | 交集  |     |     |
| inter-process communication, IPC | 进程间通信 |     |     |
| invariants | 约束条件 |     |     |
| invoke | 调用  |     |     |
| item | 项   |     |     |
| iterate | 迭代  |     |     |
| iteration | 迭代的 |     |     |
| iterative | 迭代的 |     |     |
| iterator | 迭代器 |     |     |

## J

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| jagged | 锯齿状的 |     |     |
| job control language, JCL | 作业控制语言 |     |     |
| judicious | 明智的 |     |     |

## K

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| kernel | 核心  |     |     |
| kernel language | 核心语言 |     |     |
| keyword argument | 关键字参数 |     |     |
| keywords | 关键字 |     |     |
| kludge | 蹩脚  |     |     |

## L

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| lambda calculus | lambda 演算 |     |     |
| larval startup | 雏形创业公司 |     |     |
| laser | 激光  |     |     |
| latitude |     |     |     |
| layout | 版型  |     |     |
| lazy | 惰性  |     |     |
| lazy evaluation | 惰性求值 |     |     |
| legacy software | 历史遗留软件 |     |     |
| leverage | 杠杆  | (动词)利用 |     |
| lexical | 词法的 |     |     |
| lexical analysis | 词法分析 |     |     |
| lexical closure | 词法闭包 |     |     |
| lexical scope | 词法作用域 |     |     |
| Language For Smart People, LFSP | 聪明人的语言 |     |     |
| library | 库   | 函数库 | 函式库 |
| lifetime | 生命期 |     |     |
| linear iteration | 线性迭代 |     |     |
| linear recursion | 线性递归 |     |     |
| link | 链接  | 连接  |     |
| linker | 连接器 |     |     |
| list | 列表  |     |     |
| list operation | 列表操作 |     |     |
| literal | 字面  |     |     |
| literal constant | 字面常量 |     |     |
| literal representation | 字面量 |     |     |
| load | 装载  | 加载  |     |
| loader | 装载器 | 加载器 |     |
| local | 局部的 | 局域的 |     |
| local declarations | 局部声明 |     |     |
| local function | 局部函数 | 局域函数 |     |
| local variable | 局部变量 | 局域变量 |     |
| locality | 局部性 |     |     |
| loop | 循环  |     |     |
| lvalue | 左值  |     |     |

## M

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| machine instruction | 机器指令 |     |     |
| machine language | 机器语言 |     |     |
| machine language code | 机器语言代码 |     |     |
| machine learning | 机器学习 |     |     |
| macro | 宏   |     |     |
| mailing list | 邮件列表 |     |     |
| mainframes | 大型机 |     |     |
| maintain | 维护  |     |     |
| manifest typing | 显式类型 |     |     |
| manipulator | 操纵器 |     |     |
| mapping | 映射  |     |     |
| mapping functions | 映射函数 |     |     |
| marshal | 列集  |     |     |
| math envy | 对数学家的妒忌 |     |     |
| member | 成员  |     |     |
| memorizing | 记忆化 |     |     |
| memory | 内存  |     |     |
| memory allocation | 内存分配 |     |     |
| memory leaks | 内存泄漏 |     |     |
| menu | 菜单  |     |     |
| message | 消息  |     |     |
| message-passing | 消息传递 |     |     |
| meta- | 元-  |     |     |
| meta-programming | 元编程 |     |     |
| metacircular | 元循环 |     |     |
| method | 方法  |     |     |
| method combination | 方法组合 | 方法组合机制 |     |
| micro | 微   |     |     |
| middleware | 中间件 |     |     |
| migration | （数据库）迁移 |     |     |
| minimal network | 最小网络 |     |     |
| mirror | 镜射  |     |     |
| mismatch type | 类型不匹配 |     |     |
| model | 模型  |     |     |
| modem | 调制解调器 |     |     |
| modifier | 修饰符 |     |     |
| modularity | 模块性 |     |     |
| module | 模块  |     |     |
| monad | 单子  |     |     |
| monkey patch | 猴子补丁 |     |     |
| monomorphic type language | 单型语言 |     |     |
| Moore's law | 摩尔定律 |     |     |
| mouse | 鼠标  |     |     |
| multi-task | 多任务 |     |     |
| multiple values | 多值  |     |     |
| mutable | 可变的 |     |     |
| mutex | 互斥锁 |     |     |
| Multiple Virtual Storage, MVS | 多重虚拟存储 |     |     |

## N

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| namespace | 命名空间 |     |     |
| native | 本地的 |     |     |
| native code | 本地码 |     |     |
| natural language | 自然语言 |     |     |
| natural language processing | 自然语言处理 |     |     |
| nested | 嵌套  |     |     |
| nested class | 嵌套类 |     |     |
| network | 网络  |     |     |
| newline | 换行  | 新行  |     |
| non-deterministic choice | 非确定性选择 |     |     |
| non-strict | 非严格 |     |     |
| non-strict evaluation | 非严格求值 |     |     |
| nondeclarative |     |     |     |
| nondestructive version | 非破坏性的版本 |     |     |
| number crunching | 数字密集运算 |     |     |

## O

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| object | 对象  |     |     |
| object code | 目标代码 |     |     |
| object-oriented | 面向对象 |     |     |
| object-oriented programming | 面向对象编程 |     |     |
| Occam's razor | 奥卡姆剃刀原则 |     |     |
| on the fly | 运行中 | 执行时 |     |
| online | 在线  |     |     |
| open source | 开放源码 |     |     |
| operand | 操作对象 |     |     |
| operating system, OS | 操作系统 |     |     |
| operation | 操作  |     |     |
| operator | 操作符 |     |     |
| optimization | 优化  |     |     |
| optimization of tail calls | 尾调用优化 |     |     |
| option | 选项  |     |     |
| optional | 可选的 | 选择性的 |     |
| optional argument | 选择性参数 |     |     |
| ordinary | 常规的 |     |     |
| orthogonality | 正交性 |     |     |
| overflow | 溢出  |     |     |
| overhead | 额外开销 |     |     |
| overload | 重载  |     |     |
| override | 覆写  |     |     |

## P

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| package | 包   |     |     |
| pair | 点对  |     |     |
| palindrome | 回文  |     |     |
| paradigm | 范式  |     |     |
| parallel | 并行  |     |     |
| parallel computer | 并行计算机 |     |     |
| param | 参数  |     |     |
| parameter | 参数  | 形式参数/形参 |     |
| paren-matching | 括号匹配 |     |     |
| parent class | 父类  |     |     |
| parentheses | 括号  |     |     |
| Parkinson's law | 帕金森法则 |     |     |
| parse | 解析  |     |     |
| parse tree | 解析树 | 分析树 |     |
| parser | 解析器 |     |     |
| partial application | 部分应用 |     |     |
| partial applied | 分步代入的 |     |     |
| partial function application | 部分函数应用 |     |     |
| particular ordering | 部分有序 |     |     |
| pass by adress | 按址传递 | 传址  |     |
| pass by reference | 按引用传递 | 传引用 |     |
| pass by value | 按值传递 | 传值  |     |
| path | 路径  |     |     |
| pattern | 模式  |     |     |
| pattern match | 模式匹配 |     |     |
| perform | 执行  |     |     |
| performance | 性能  |     |     |
| performance-critical |     |     |     |
| persistence | 持久性 |     |     |
| phrenology | 相面  |     |     |
| physical | 物理的 |     |     |
| pipe | 管道  |     |     |
| pixel | 像素  |     |     |
| placeholder | 占位符 |     |     |
| planning | 计划  |     |     |
| platform | 平台  |     |     |
| pointer | 指针  |     |     |
| pointer arithmetic | 指针运算 |     |     |
| poll | 轮询  |     |     |
| polymorphic | 多态  |     |     |
| polymorphism | 多态  |     |     |
| polynomial | 多项式的 |     |     |
| pool | 池   |     |     |
| port | 端口  |     |     |
| portable | 可移植性 |     |     |
| portal | 门户  |     |     |
| positional parameters | 位置参数 |     |     |
| postfix | 后序  |     |     |
| precedence | 优先级 |     |     |
| precedence list | 优先级列表 |     |     |
| preceding | 前述的 |     |     |
| predicate | 判断式 | 谓词  |     |
| preemptive multitasking | 抢占式多任务 |     |     |
| premature design | 过早设计 |     |     |
| preprocessor | 预处理器 |     |     |
| prescribe | 规定  |     |     |
| prime | 素数  |     |     |
| primitive | 原语  |     |     |
| primitive recursive | 主递归 |     |     |
| primitive type | 原生类型 |     |     |
| principal type | 主要类型 |     |     |
| print | 打印  |     |     |
| printed representation | 打印表示法 |     |     |
| printer | 打印机 |     |     |
| priority | 优先级 |     |     |
| procedure | 过程  |     |     |
| procedurual | 过程化的 |     |     |
| procedurual knowledge | 过程式知识 |     |     |
| process | 进程  |     |     |
| process priority | 进程优先级 |     |     |
| productivity | 生产力 |     |     |
| profile | 评测  |     |     |
| profiler | 评测器 | 性能分析器 |     |
| programmer | 程序员 |     |     |
| programming | 编程  |     |     |
| programming language | 编程语言 |     |     |
| project | 项目  |     |     |
| prompt | 提示符 |     |     |
| proper list | 正规列表 |     |     |
| property | 属性  |     |     |
| property list | 属性列表 |     |     |
| protocol | 协议  |     |     |
| prototype | 原型  |     |     |
| pseudo code | 伪码  |     |     |
| pseudo instruction | 伪指令 |     |     |
| purely functional language | 纯函数式语言 |     |     |
| pushdown stack | 下推栈 |     |     |

## Q

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| qualified | 修饰的 | 带前缀的 |     |
| qualifier | 修饰符 |     |     |
| quality | 质量  |     |     |
| quality assurance, QA | 质量保证 |     |     |
| query | 查询  |     |     |
| query language | 查询语言 |     |     |
| queue | 队列  |     |     |
| quote | 引用  |     |     |
| quoted form | 引用形式 |     |     |

## R

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| race condition | 条件竞争 | 竞态条件 |     |
| radian | 弧度  |     |     |
| Redundant Array of Independent Disks, RAID | 冗余独立磁盘阵列 |     |     |
| raise | 引起  |     |     |
| random number | 随机数 |     |     |
| range | 范围  | 区间  |     |
| rank | （矩阵）秩 | 排名  |     |
| rapid prototyping | 快速原型开发 |     |     |
| rational database | 关系数据库 |     |     |
| raw | 未经处理的 |     |     |
| read | 读取  |     |     |
| read-evaluate-print loop, REPL | 读取-求值-打印循环 |     |     |
| read-macro | 读取宏 |     |     |
| record | 记录  |     |     |
| recursion | 递归  |     |     |
| recursive | 递归的 |     |     |
| recursive case | 递归情形 |     |     |
| refactor | 重构  |     |     |
| refer | 参考  |     |     |
| reference | 引用  | 参考  |     |
| referential transparency | 引用透明 |     |     |
| refine | 精化  |     |     |
| reflection | 反射  | 映像  |     |
| register | 寄存器 |     |     |
| registry creep | 注册表蠕变 |     |     |
| regular expression | 正则表达式 |     |     |
| represent | 表现  |     |     |
| request | 请求  |     |     |
| resolution | 解析度 |     |     |
| resolve | 解析  |     |     |
| rest parameter | 剩余参数 |     |     |
| return | 返回  | 回车  |     |
| return value | 返回值 |     |     |
| reuse of software | 代码重用 |     |     |
| right associative | 右结合 |     |     |
| Reduced Instruction Set Computer, RISC | 精简指令系统计算机 |     |     |
| robust | 健壮  |     |     |
| robustness | 健壮性 | 鲁棒性 |     |
| routine | 例程  |     |     |
| routing | 路由  |     |     |
| row-major order | 列主序 |     |     |
| remote procedure call, RPC | 远程过程调用 |     |     |
| run-length encoding | 游程编码 |     |     |
| run-time typing | 运行期类型 |     |     |
| runtime | 运行期 |     |     |
| rvalue | 右值  |     |     |

## S

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| S-expression | S-表达式 |     |     |
| save | 储存  |     |     |
| Secure Sockets Layer, SSL | 安全套接字层 |     |     |
| scaffold | 脚手架 | 鹰架  |     |
| scalar type | 标量  |     |     |
| scan | 扫描  |     |     |
| schedule | 调度  |     |     |
| scheduler | 调度程序 |     |     |
| scope | 作用域 |     |     |
| SCREAMING\_SNAKE\_CASE | 尖叫式蛇底大写 |     |     |
| screen | 屏幕  |     |     |
| scripting language | 脚本语言 |     |     |
| search | 查找  | 搜寻  |     |
| segment of instructions | 指令片段 |     |     |
| semantics | 语义  |     |     |
| semaphore | 信号量 |     |     |
| semicolon | 分号  |     |     |
| sequence | 序列  |     |     |
| sequential | 循序的 | 顺序的 |     |
| sequential collection literals |     |     |     |
| serial | 串行  |     |     |
| serialization | 序列化 |     |     |
| series | 串行  | 级数  |     |
| server | 服务器 |     |     |
| shadowing | 隐蔽了 |     |     |
| sharp | 犀利的 |     |     |
| sharp-quote | 升引号 |     |     |
| shortest path | 最短路径 |     |     |
| SICP | 《计算机程序的构造与解释》 |     |     |
| side effect | 副作用 |     |     |
| signature | 签名  |     |     |
| simple vector | 简单向量 |     |     |
| simulate | 模拟  |     |     |
| Single Point of Truth, SPOT | 真理的单点性 |     |     |
| single-segment | 单段的 |     |     |
| sketch | 草图  | 初步框架 |     |
| slash | 斜线  |     |     |
| slot | 槽   |     |     |
| smart pointer | 智能指针 |     |     |
| snake\_case | 蛇底式小写 |     |     |
| snapshot | 屏幕截图 |     |     |
| socket | 套接字 |     |     |
| software | 软件  |     |     |
| solution | 方案  |     |     |
| source code | 源代码 |     |     |
| space leak | 内存泄漏 |     |     |
| spaghetti | 面条式代码 | 意面式代码 |     |
| spaghetti stack | 意面式栈 | 面条式栈 |     |
| spam | 垃圾邮件 |     |     |
| spec | 规格  |     |     |
| special form | 特殊形式 |     |     |
| special variable | 特殊变量 |     |     |
| specialization | 特化  |     |     |
| specialize | 特化  |     |     |
| specialized array | 特化数组 |     |     |
| specification | 规格说明 | 规范  |     |
| splitter | 切分窗口 |     |     |
| sprite | 精灵图 |     |     |
| square | 平方  |     |     |
| square root | 平方根 |     |     |
| squash | 碰撞  |     |     |
| stack | 栈   |     |     |
| stack frame | 栈帧  |     |     |
| stakeholder |     |     |     |
| standard library | 标准函式库 |     |     |
| state machine | 状态机 |     |     |
| statement | 陈述  | 语句  |     |
| static type | 静态类型 |     |     |
| static type system | 静态类型系统 |     |     |
| status | 状态  |     |     |
| store | 保存  |     |     |
| stream | 流   |     |     |
| strict | 严格  |     |     |
| strict evaluation | 严格求值 |     |     |
| string | 字串  | 字符串 |     |
| string template | 字串模版 |     |     |
| strong type | 强类型 |     |     |
| structural recursion | 结构递归 |     |     |
| structured values | 结构型值 |     |     |
| subroutine | 子程序 |     |     |
| subset | 子集  |     |     |
| substitution | 代换  |     |     |
| substitution model | 代换模型 |     |     |
| subtype | 子类型 |     |     |
| superclass | 基类  |     |     |
| superfluous | 多余的 |     |     |
| supertype | 超集  |     |     |
| support | 支持  |     |     |
| suspend | 挂起  |     |     |
| swapping values | 交换变量的值 |     |     |
| symbol | 符号  |     |     |
| symbolic computation | 符号计算 |     |     |
| syntax | 语法  |     |     |
| system administrator | 系统管理员 |     |     |
| system administrator disease | 系统管理员综合症 |     |     |
| System Network Architecture, SNA | 系统网络体系 |     |     |

## T

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| (database)table | 数据表 |     |     |
| table | 表格  |     |     |
| tag | 标签  | 标记  |     |
| tail-recursion | 尾递归 |     |     |
| tail-recursive | 尾递归的 |     |     |
| TAOCP | 《计算机程序设计艺术》 |     |     |
| target | 目标  |     |     |
| taxable operators | 需节制使用的操作符 |     |     |
| taxonomy | 分类法 |     |     |
| template | 模版  |     |     |
| temporary object | 临时对象 |     |     |
| testing | 测试  |     |     |
| text | 文本  |     |     |
| text file | 文本文件 |     |     |
| thread | 线程  |     |     |
| thread safe | 线程安全 |     |     |
| three-valued logic | 三值逻辑 |     |     |
| throw | 抛出  | 丢掷  | 引发  |
| throwaway program | 一次性程序 |     |     |
| timestamp | 时间戳 |     |     |
| token | 词法记号 | 语义单位 | 语元  |
| top-down design | 自顶向下的设计 |     |     |
| top-level | 顶层  |     |     |
| trace | 追踪  |     |     |
| trailing space | 行尾空白 |     |     |
| transaction | 事务  |     |     |
| transition network | 转移网络 |     |     |
| transparent | 透明的 |     |     |
| traverse | 遍历  |     |     |
| tree | 树   |     |     |
| tree recursion | 树形递归 |     |     |
| trigger | 触发器 |     |     |
| tuple | 元组  |     |     |
| Turing machine | 图灵机 |     |     |
| Turing complete | 图灵完备 |     |     |
| typable | 类型合法 |     |     |
| type | 类型  |     |     |
| type constructor | 类构造器 |     |     |
| type declaration | 类型声明 |     |     |
| type hierarchy | 类型层级 |     |     |
| type inference | 类型推导 |     |     |
| type name | 类型名 |     |     |
| type safe | 类型安全 |     |     |
| type signature | 类型签名 |     |     |
| type synonym | 类型别名 |     |     |
| type variable | 类型变量 |     |     |
| typing | 类型指派 | 输入  |     |

## U

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| user interface, UI | 用户界面 |     |     |
| unary | 一元的 |     |     |
| underflow | 下溢  |     |     |
| unification | 合一  | 统一  |     |
| union | 并集  |     |     |
| universally quantify | 全局量化 |     |     |
| unqualfied | 未修饰的 |     |     |
| unwinding |     |     |     |
| uptime | 运行时间 |     |     |
| Uniform Resource Locator, URL | 统一资源定位符 |     |     |
| user | 用户  |     |     |
| utilities | 实用函数 |     |     |

## V

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| validate | 验证  |     |     |
| validator | 验证器 |     |     |
| value constructor | 值构造器 |     |     |
| vaporware | 朦胧件 |     |     |
| variable | 变量  |     |     |
| variable capture | 变量捕捉 |     |     |
| variadic input | 可变输入 |     |     |
| variant | 变种  |     |     |
| venture capitalist, VC | 风险投资商 |     |     |
| vector | 向量  |     |     |
| viable function | 可行函数 |     |     |
| video | 视频  |     |     |
| view | 视图  |     |     |
| virtual function | 虚函数 |     |     |
| virtual machine | 虚拟机 |     |     |
| virtual memory | 虚内存 |     |     |
| volatile | 挥发  |     |     |
| vowel | 元音  |     |     |

## W

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| warning message | 警告信息 |     |     |
| web server | 网络服务器 |     |     |
| weight | 权值  | 权重  |     |
| well type | 类型正确 |     |     |
| wildcard | 通配符 |     |     |
| window | 窗口  |     |     |
| word | 单词  | 字   |     |
| wrapper | 包装器 | 包装  |     |
| What You See Is What You Get, WYSIWYG | 所见即所得 |     |     |
| What You See Is What You Want, WYSIWYW | 所见即所想 |     |     |

## X

## Y

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| Y combinator | Y组合子 |     |     |

## Z

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| Z-expression | Z-表达式 |     |     |
| zero-indexed | 零索引的 |     |     |

## 专业名词

| **英文** | **译法 1** | 译法 2 | 译法 3 |
| --- | --- | --- | --- |
| The Paradox of Choice | 选择谬论 |     |     |

> 文章来源：https://github.com/JuanitoFatas/Computer-Science-Glossary/blob/master/dict.textile



---
url: /tools/git.md
---

# Git

### revert

```sh
git revert OLDER_COMMIT^..NEWER_COMMIT
git revert -n xxx^..yyy -m 1

git revert --quit
```

### 커밋 취소

```sh
git reset --soft HEAD^
```

### 대소문자 이슈

```sh
git config core.ignorecase false
```

### 커밋 날짜 변경

```sh
# 최근 커밋을 어제의 현재 시간으로 변경하기
git commit --amend --date "1 day ago" -m "커밋 메시지"
```

### conmit rule

https://github.com/conventional-changelog/conventional-changelog/tree/master/packages

- angular
- atom
- codemirror
- ember
- eslint
- express
- jquery
- jshint
- conventionalcommits



---
url: /tools/npm.md
---

# Npm

### install 팁

install 시 https://registry.npmjs.org/jnpkg 여기서 다운로드

### 동일패키지 여러 버전 공존

```sh
npm install --save lodash-v1@npm:lodash@1.0.0

import a from 'lodash-v1';
import b from 'lodash';
```

### 기본설치된 package 리스트

```sh
npm list --depth=0
npm list --depth=0 -global
```

### 배포된 패키지 제거하기

```sh
npm unpublish dzmtest@1.0.1 --force # 특정 버정만 제거
npm unpublish dzmtest --force # 패지지 제거
npm unpublish --force # package.json에 지정된 패키지 제거
```

### pnpm 명령어

| 카테고리         | 명령어                                 | 설명                            |
| ---------------- | -------------------------------------- | ------------------------------- |
| **기본**         | `pnpm --version`                       | 버전 확인                       |
|                  | `pnpm init`                            | 프로젝트 초기화                 |
| **설치**         | `pnpm install` (`pnpm i`)              | 의존성 설치                     |
|                  | `pnpm add <패키지>`                    | 패키지 설치                     |
|                  | `pnpm add <패키지> -D`                 | 개발 의존성 설치                |
|                  | `pnpm add <패키지> -g`                 | 전역 설치                       |
|                  | `pnpm update`                          | 의존성 업데이트                 |
| **제거**         | `pnpm remove <패키지>`                 | 패키지 삭제                     |
| **실행**         | `pnpm run <script>`                    | 스크립트 실행                   |
|                  | `pnpm exec <명령어>`                   | 로컬 바이너리 실행              |
| **관리**         | `pnpm list` (`pnpm ls`)                | 패키지 목록                     |
|                  | `pnpm outdated`                        | 업데이트 확인                   |
|                  | `pnpm prune`                           | 불필요한 패키지 제거            |
|                  | `pnpm audit`                           | 보안 점검                       |
|                  | `pnpm why <패키지>`                    | 설치 이유 확인                  |
| **워크스페이스** | `pnpm init -w`                         | 워크스페이스 초기화             |
|                  | `pnpm add <패키지> -w`                 | 전체 워크스페이스에 추가        |
|                  | `pnpm recursive install` (`pnpm i -r`) | 모든 워크스페이스 설치          |
|                  | `pnpm recursive run <script>`          | 모든 워크스페이스 스크립트 실행 |
| **전역**         | `pnpm add -g <패키지>`                 | 전역 설치                       |
|                  | `pnpm remove -g <패키지>`              | 전역 제거                       |
|                  | `pnpm list -g`                         | 전역 패키지 목록                |
| **캐시/설정**    | `pnpm store path`                      | 캐시 저장소 경로                |
|                  | `pnpm store prune`                     | 캐시 정리                       |
|                  | `pnpm config get <key>`                | 설정 값 확인                    |
|                  | `pnpm config set <key> <value>`        | 설정 값 변경                    |

### yarn 명령어

| 카테고리         | 명령어                         | 설명                            |
| ---------------- | ------------------------------ | ------------------------------- |
| **기본**         | `yarn --version`               | 버전 확인                       |
|                  | `yarn init`                    | 새 프로젝트 초기화              |
|                  | `yarn init -y`                 | 기본 설정으로 초기화            |
| **설치**         | `yarn install` (`yarn`)        | 의존성 설치                     |
|                  | `yarn add <패키지>`            | 패키지 설치                     |
|                  | `yarn add <패키지> --dev`      | 개발 의존성 설치                |
|                  | `yarn global add <패키지>`     | 전역 설치                       |
|                  | `yarn upgrade`                 | 의존성 업데이트                 |
| **제거**         | `yarn remove <패키지>`         | 패키지 삭제                     |
| **실행**         | `yarn run <script>`            | 스크립트 실행                   |
|                  | `yarn <script>` (단축)         | `run` 생략 가능                 |
| **관리**         | `yarn list`                    | 설치된 패키지 목록              |
|                  | `yarn outdated`                | 업데이트 가능 패키지 확인       |
|                  | `yarn cache clean`             | 캐시 삭제                       |
|                  | `yarn why <패키지>`            | 특정 패키지 설치 이유 확인      |
| **워크스페이스** | `yarn workspaces info`         | 워크스페이스 정보 출력          |
|                  | `yarn workspace <이름> <명령>` | 특정 워크스페이스에서 명령 실행 |
| **전역**         | `yarn global add <패키지>`     | 전역 설치                       |
|                  | `yarn global remove <패키지>`  | 전역 제거                       |
|                  | `yarn global list`             | 전역 패키지 목록                |



---
url: /tools/plugins/babel.md
---

# babel

#### sample code

```js
export default `function square(n) {
  return n * n;
}`;
```

### parser

babel-parser(旧 Babylon) 是 Babel 的解析器。最初是 从 Acorn 项目 fork 出来的。Acorn 非常快，易于使用，并且针对非标准特性(以及那些未来的标准特性) 设计了一个基于插件的架构。

```javascript
import { parse } from "@babel/parser";
import code from "./code";

const ast = parse(code);
console.log(JSON.stringify(ast, null, 2));
```

### traverse

Babel Traverse（遍历）模块维护了整棵树的状态，并且负责替换、移除和添加节点。

```js
import { parse } from "@babel/parser";
import traverse from "@babel/traverse";
import code from "./code";

const ast = parse(code);
traverse(ast, {
  enter(path) {
    if (path.node.type === "Identifier" && path.node.name === "n") {
      path.node.name = "x";
    }
  },
});

console.log(JSON.stringify(ast, null, 2));
```

### types

Babel Types 模块是一个用于 AST 节点的 Lodash 式工具库（译注：Lodash 是一个 JavaScript 函数工具库，提供了基于函数式编程风格的众多工具函数）， 它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用。

```js
import { parse } from "@babel/parser";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import code from "./code";

const ast = parse(code);
traverse(ast, {
  enter(path) {
    if (t.isIdentifier(path.node, { name: "n" })) {
      path.node.name = "x";
    }
  },
});
console.log(JSON.stringify(ast, null, 2));
```

### generator

Babel Traverse（遍历）模块维护了整棵树的状态，并且负责替换、移除和添加节点。

```js
import { parse } from "@babel/parser";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import generate from "@babel/generator";
import code from "./code";

const ast = parse(code);
traverse(ast, {
  enter(path) {
    if (t.isIdentifier(path.node, { name: "n" })) {
      path.node.name = "x";
    }
  },
});
console.log(generate(ast).code);
```

### template

它能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST 的时候。 在计算机科学中，这种能力被称为准引用（quasiquotes）。

```js
import template from "@babel/template";
import generate from "@babel/generator";
import * as t from "@babel/types";

const buildRequire = template(`
  var IMPORT_NAME = require(SOURCE);
`);
const ast = buildRequire({
  IMPORT_NAME: t.identifier("myModule"),
  SOURCE: t.stringLiteral("my-module"),
});
console.log(generate(ast).code);
```

### types-vistor

```js
// types
const EXPRESSION_TYPES = [];
const BINARY_TYPES = [];
const SCOPABLE_TYPES = [];
const BLOCKPARENT_TYPES = [];
const BLOCK_TYPES = [];
const STATEMENT_TYPES = [];
const TERMINATORLESS_TYPES = [];
const COMPLETIONSTATEMENT_TYPES = [];
const CONDITIONAL_TYPES = [];
const LOOP_TYPES = [];
const WHILE_TYPES = [];
const EXPRESSIONWRAPPER_TYPES = [];
const FOR_TYPES = [];
const FORXSTATEMENT_TYPES = [];
const FUNCTION_TYPES = [];
const FUNCTIONPARENT_TYPES = [];
const PUREISH_TYPES = [];
const DECLARATION_TYPES = [];
const PATTERNLIKE_TYPES = [];
const LVAL_TYPES = [];
const TSENTITYNAME_TYPES = [];
const LITERAL_TYPES = [];
const IMMUTABLE_TYPES = [];
const USERWHITESPACABLE_TYPES = [];
const METHOD_TYPES = [];
const OBJECTMEMBER_TYPES = [];
const PROPERTY_TYPES = [];
const UNARYLIKE_TYPES = [];
const PATTERN_TYPES = [];
const CLASS_TYPES = [];
const MODULEDECLARATION_TYPES = [];
const EXPORTDECLARATION_TYPES = [];
const MODULESPECIFIER_TYPES = [];
const PRIVATE_TYPES = [];
const FLOW_TYPES = [];
const FLOWTYPE_TYPES = [];
const FLOWBASEANNOTATION_TYPES = [];
const FLOWDECLARATION_TYPES = [];
const FLOWPREDICATE_TYPES = [];
const ENUMBODY_TYPES = [];
const ENUMMEMBER_TYPES = [];
const JSX_TYPES = [];
const TSTYPEELEMENT_TYPES = [];
const TSTYPE_TYPES = [];
const TSBASETYPE_TYPES = [];

// operator
const LOGICAL_OPERATORS = [];
const UPDATE_OPERATORS = [];
const BOOLEAN_NUMBER_BINARY_OPERATORS = [];
const EQUALITY_BINARY_OPERATORS = [];
const COMPARISON_BINARY_OPERATORS = [];
const BOOLEAN_BINARY_OPERATORS = [];
const NUMBER_BINARY_OPERATORS = [];
const BINARY_OPERATORS = [];
const ASSIGNMENT_OPERATORS = [];
const BOOLEAN_UNARY_OPERATORS = [];
const NUMBER_UNARY_OPERATORS = [];
const STRING_UNARY_OPERATORS = [];
const UNARY_OPERATORS = [];
```



---
url: /tools/plugins/eslint.md
---

# eslint

1. code
2. parser(esprima, @babel/eslint-parser, @typescript-eslint/parser)
3. AST
4. plugin(report or fix)

### build option

```js
// build.js
require("esbuild")
  .build({
    entryPoints: ["./src/index.js"],
    bundle: true,
    minify: true,
    platform: "node",
    outfile: "./lib/index.js",
    watch: true,
  })
  .then(() => console.log("빌드완료"))
  .catch(() => process.exit(1));
```

```js
// ./src/index.js
// module.exports = {
//   rules: {......},
//   configs: {......},
// }
import maxParams from "./rules/max-params";

export const rules = {
  "max-params": maxParams,
};

export const configs = {
  recommended: {
    plugins: ["jl"],
    rules: {
      "jl/max-params": ["warn", { max: 3 }],
    },
  },
};

// ./src/rules/max-params.js
// https://astexplorer.net/
export default {
  meta: {
    docs: {
      description: "enforce a maximum number of parameters in function definitions",
      category: "Stylistic Issues", // https://cn.eslint.org/docs/rules/
      recommended: false,
    },
  },
  create: (context) => {
    // https://eslint.org/docs/developer-guide/working-with-rules#the-context-object
    // context: {
    //   report,
    //   id, // jl/max-params
    //   options, // [{max: 3}, ......]
    //   ......
    // }
    const fn = (node) => {
      if (node.params.length > 3) {
        // https://eslint.org/docs/developer-guide/working-with-rules
        context.report({
          node,
          message: "파라미터는 3개 이상 초과 할수 없습니다." + context.options[0].max,
        });
      }
    };
    // https://esprima.readthedocs.io/en/latest/syntax-tree-format.html#expressions-and-patterns
    return {
      FunctionDeclaration: fn,
      ArrowFunctionExpression: fn,
      FunctionExpression: fn,
    };
  },
};
```

### use plugin

```js
// .eslintrc.json
{
  "plugins": [
    "jl"
  ],
  "extends": [
    "plugin:jl/recommended"
  ],
  "rules": {
    "jl/max-params": "off", // off, warn, error, 0, 1,2
    "jl/max-params": ["warn", {"max": 3}],
  }
}
```



---
url: /tools/plugins/swc.md
---

# swc

### Visitor

```tsx
// https://swc.rs/docs/usage/core
import { CallExpression, parseSync, transformSync } from "@swc/core";
// https://github.com/swc-project/swc/blob/main/node-swc/src/Visitor.ts
import { Visitor } from "@swc/core/Visitor";

interface ITransformResult {
  code: string;
  map?: string;
}
class PluginName extends Visitor {
  // run visitor
  visitCallExpression(n: CallExpression) {
    // any work
    return super.visitCallExpression(n);
  }
}

new PluginName().visitProgram(program);

const transform = (src, id) => {
  // default 값 지정 필요.
  let result: ITransformResult = { code: src };

  // 코드 변환
  result = transformSync(src, {
    plugin,
    sourceMaps: true,
    jsc: {
      parser: {
        syntax: "ecmascript",
        jsx: true,
      },
    },
  });
  return result;
};
```



---
url: /tools/plugins/typescript.md
---

https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin


---
url: /tools/plugins/vite.md
---

# vite

### sample code

```js
export default function myPlugin() {
  return {
    name: "my-plugin", // 插件名称
    enforce: "pre", //调整插件被执行顺序
    apply: "build | serve", // 指定插件应用情景
    options(options) {},
    buildStart(options) {},
    resolveId(id) {},
    load(id) {},
    transform(src, id) {},
    buildEnd(error) {},
    closeBundle() {},
    config(config, env) {},
    configResolved(config) {},
    configureServer(server) {},
    transformIndexHtml(html, ctx) {},
    handleHotUpdate(ctx) {},
  };
}
```



---
url: /artificialIntelligence/ollama.md
---

# ollama

### 명령어

| 명령어                  | 기능 요약                        |
| ----------------------- | -------------------------------- |
| `ollama --help`         | 전체 명령어 및 옵션 확인         |
| `ollama --version`      | 버전 정보 확인                   |
| `ollama serve`          | Ollama 서버 시작                 |
| `ollama pull <모델>`    | 모델 다운로드만 수행             |
| `ollama run <모델>`     | 모델 다운로드 + 실행 (대화 세션) |
| `ollama list`           | 로컬 모델 목록 출력              |
| `ollama ps`             | 현재 실행 중인 모델 목록 확인    |
| `ollama stop <모델>`    | 실행 중 모델 종료                |
| `ollama rm <모델>`      | 모델 삭제                        |
| `ollama show <모델>`    | 모델 메타 데이터 보기            |
| `ollama cp <src> <dst>` | 모델 복제                        |
| `ollama push <모델>`    | 모델을 레지스트리로 업로드       |



---
url: /index.md
---



