"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["5667"],{9966:function(e,n,l){l.r(n),l.d(n,{default:()=>r});var i=l(5893),t=l(65);function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h4:"h4",pre:"pre",code:"code",ol:"ol",li:"li",ul:"ul",del:"del",h3:"h3",strong:"strong"},(0,t.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"react성능-최적화",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react성능-최적화",children:"#"}),"React성능 최적화"]}),"\n",(0,i.jsxs)(n.h2,{id:"diff-algorithm-vdom",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#diff-algorithm-vdom",children:"#"}),"Diff Algorithm (VDOM)"]}),"\n",(0,i.jsxs)(n.h4,{id:"1-tree-diff-동일레벨depth-요소끼리-비교",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-tree-diff-동일레벨depth-요소끼리-비교",children:"#"}),"1. Tree diff 동일레벨(depth) 요소끼리 비교"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// 전부 교체\n<section>\n	<div className="content">hello</div>\n</section>\n<div className="content">hello</div>\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"2-component-비교",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-component-비교",children:"#"}),"2. component 비교"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// 전부 교체\nconst About = () => <div>About</div>;\nconst Main = () => <div>About</div>;\n\nvisible ? <About /> : <Main />;\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"3-element-type-비교",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-element-type-비교",children:"#"}),"3. Element Type 비교"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// 전부 교체\n<section>\n	<div className="content">hello</div>\n</section>\n<div>\n	<div className="content">hello</div>\n</div>\n\n// Element가 동일하니 다음 단계로 pass\n<div>\n	<section className="content">hello</section>\n</div>\n<div>\n	<div className="content">hello</div>\n</div>\n\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"4-element-props-비교",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-element-props-비교",children:"#"}),"4. Element Props 비교"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Element가 동일할 경우 props 변경된 부분만 교체, 순서 중요하지 않음. 스타일 obj도 마찬가지.\n<div style={{width: 40}} id="a">\n	<div className="content">hello</div>\n</div>\n<div style={{width: 70, height: 30}} id="b">\n	<div className="content">hello</div>\n</div>\n\n// style값이 동일하더라도 변경은 없지만 내부적으로 변화를 비교함\n<div style={{width: 40}}>\n	<div className="content">hello</div>\n</div>\n<div style={{width: 40}}>\n	<div className="content">hello</div>\n</div>\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"5-key우선순위-제일-높음",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-key우선순위-제일-높음",children:"#"}),"5. key(우선순위 제일 높음.)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// key설정 하지 않으면 null로 처리.\n<div></div>\n<div id="a"></div>\n\n// key 다르면 판단하지 않고 교체.\n<div key="1">123</div>\n<div key="2">123</div>\n\n// key & type(component, element포함)이 동일한 경우 vdom(fiber) 노드를 그대로 사용. (업데이트와 생성의 차이))\n// 전부 교체.\n<div key="1">123</div>\n<p key="1">123</p>\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"6-멀티노드-비교",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-멀티노드-비교",children:"#"}),"6. 멀티노드 비교"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"1단계(비교)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// newChildNode, oldChildNode 동시 끝나는 경우(Update 처리)\n// old\n<ul>\n<li key="0" className="normal">0</li>\n<li key="1" className="normal">1</li>\n<li key="2" className="normal">2</li>\n</ul>\n// new\n<ul>\n<li key="0" className="bold">0</li>\n<li key="1" className="bold">1</li>\n<li key="2" className="bold">2</li>\n</ul>\n//\n// newChildNode 순회가 먼저 끝나는 경우(Vdom Delection 처리)\n// old\n<ul>\n<li key="0">0</li>\n<li key="1">1</li>\n<li key="2">2</li> \x3c!-- Delection 처리 --\x3e\n</ul>\n// new\n<ul>\n<li key="0">0</li>\n<li key="1">1</li>\n</ul>\n//\n// oldChildNode 순회가 먼저 끝나는 경우(Vdom Placement 처리)\n// old\n<ul>\n<li key="0">0</li>\n<li key="1">1</li>\n</ul>\n// new\n<ul>\n<li key="0">0</li>\n<li key="1">1</li>\n<li key="2">2</li> \x3c!-- Placement 처리 --\x3e\n</ul>\n//\n// key가 동일하고 type이 다를 경우 oldChildNode Deletion처리.\n// old\n<ul>\n<li key="0">0</li>\n<li key="1">1</li> \x3c!-- Delection 처리 --\x3e\n<li key="2">2</li>\n</ul>\n// new\n<ul>\n<li key="0">0</li>\n<div key="1">1</div>\n<li key="2">2</li>\n</ul>\n//\n// oldChildNode, newChildNode모두 남아 있는 경우(key가 다른 부분이 있으면 바로 다음단계.)\n// old\n<ul>\n<li key="0">0</li>\n<li key="1">1</li>\n<li key="2">2</li>\n</ul>\n// new\n<ul>\n<li key="0">0</li>\n<li key="2">2</li>\n<li key="1">1</li>\n</ul>\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"2단계(교체)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'- 빠른 처리를 위해서 남아있는 oldChildNode를 map객체에 [key]: fiber(vdom) 추가한다.\n- placeChild 실행\n    1. lastPlacedIndex = 0\n    2. oldIndex ≥ lastPlaceIndex 일때 이동하지 않고 lastPlaceIndex = oldIndex로 설정.\n    3. oldIndex < lastPlaceIndex 일때 맨 뒤로 이동.\n    4. map객체에 관련된 데이터가 없을 경우 Placement\n    5. oldChildNode순회후 newChildNode랑 매핑되지 않는 부분은 Deletion 처리\n\n// old\n<ul>\n<li key="a">a</li>\n<li key="b">b</li>\n<li key="c">c</li>\n<li key="d">d</li>\n</ul>\n// new\n<ul>\n<li key="d">d</li>\n<li key="a">a</li>\n<li key="b">b</li>\n<li key="c">c</li>\n</ul>\n// lastPlacedIndex = 0;\n// D가 oldChildNode에서의 index가 3임\n// 3 >= lastPlaceIndex 이므로 이동이 필요 없음. lastPlaceIndex = 3으로 지정\n// A가 oldChildNode에서의 index가 0임\n// 1 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.\n// B가 oldChildNode에서의 index가 1임\n// 2 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.\n// C가 oldChildNode에서의 index가 2임\n// 2 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.\n'})}),"\n","\n",(0,i.jsxs)(n.h2,{id:"react-render하는-조건bailout조건",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-render하는-조건bailout조건",children:"#"}),"React render하는 조건(bailout조건)"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"oldProps === newProps"}),"\n",(0,i.jsx)(n.li,{children:"context 값의 변화가 있는지?"}),"\n",(0,i.jsx)(n.li,{children:"workInProgress.type === current.type (only Dev mode, live-reload)"}),"\n",(0,i.jsxs)(n.li,{children:["state변화가 있는지 ?? ",(0,i.jsx)(n.del,{children:"업데이트 EffectTag가 존재한지, 존재하면 이번 priority 업데이트 task에 포함 되는건지 ?"})]}),"\n"]}),"\n","\n",(0,i.jsxs)(n.h2,{id:"최적화-유형",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#최적화-유형",children:"#"}),"최적화 유형"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.del,{children:"PureComponent,shouldComponentUpdate"})}),"\n",(0,i.jsx)(n.li,{children:"React.memo로 캐시(PureComponent로 만들고 싶을때 사용.)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// React는 기본적으로 state변경시 해당 컴포넌트 및 자식 컴포넌트 전부 rerender한다.\n// bailout로직중 newProps === oldProps 여야만 컴포넌트를 랜딩하지 않는다.\n// 하위 컴포넌트에 React.memo 적용시 알고리즘을 실행해서 랭딩한다.\n// 자주 변하는 값은 필요없지만 업데이트가 적거나 static한 컴포넌트는 필요하다.\n// 컴포넌트 자체에서 props, state, context변화가 없고 부모의 부모의 .....  key값이 변화가 없는데 rerender된다.\n\nimport React, { useState, useMemo } from "react";\n\nconst EffectComponent = () => {\n  console.log("render effect Component");\n  return <>effect Component</>;\n};\n\n// const a = <EffectComponent />\n\n// const diff = (prevProps, nextProps) => {\n//   console.log(prevProps === nextProps);\n//   return prevProps === nextProps;\n// }\n\n// const MemoEffectComponent = React.memo(EffectComponent, diff);\n\nconst App = () => {\n  const [count, setCount] = useState(0); // state또는 context를 건드렸기 때문.\n  const onChange = (e) => {\n    setCount(count + 1);\n  };\n\n  // const b = useMemo(() => <EffectComponent />, [])\n\n  return (\n    <>\n      <h2>Register</h2>\n      <input onChange={onChange} />\n      <p>{count}</p>\n      <EffectComponent />\n      {/* {a} */}\n      {/* <MemoEffectComponent /> */}\n    </>\n  );\n};\n\nexport default App;\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"useMemo, useCallback로 캐시"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { useCallback, useState } from "react";\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  const handleCount = useCallback(() => {\n    setCount((count) => count + 1);\n  }, []);\n\n  const handleCount2 = useCallback(() => {\n    setCount(count + 1);\n  }, []);\n\n  return (\n    <div className="App">\n      <h1>{count}</h1>\n      <button onClick={handleCount}>+1</button>\n      <button onClick={handleCount2}>+1</button>\n    </div>\n  );\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"inlineObject 사용금지"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// bad\n<div style={{width: 200}}></div>\n// good\nconst style = {width:200}\n<div style={style}></div>\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"익명함수 사용금지."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// bad\n<button onClick={() => {...}}>123</button>\n\n// good\nconst onClick = () => {...};\n<button onClick={onClick}>123</button>\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"6",children:["\n",(0,i.jsx)(n.li,{children:"key활용"}),"\n",(0,i.jsx)(n.li,{children:"React.Fragment사용"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// bad\n<div>\n  <p>1</p>\n  <p>2</p>\n</div>\n\n// good\n<React.Fragment>\n  <p>1</p>\n  <p>2</p>\n<React.Fragment/>\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"8",children:["\n",(0,i.jsx)(n.li,{children:"lazyload(suspense) with webpack"}),"\n",(0,i.jsx)(n.li,{children:"transtion(react18)"}),"\n",(0,i.jsx)(n.li,{children:"immer 사용(구조공유)"}),"\n",(0,i.jsx)(n.li,{children:"useLayoutEffect, useInsertionEffect에 오래 실행되는 스크립트 사용하지 말것.(useEffect와 달리 sync로 실행됨.)"}),"\n"]}),"\n","\n",(0,i.jsxs)(n.h2,{id:"react-design",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-design",children:"#"}),"React Design"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"변화(props, state, context)랑 불변을 분리해서 처리."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const App = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      {/* Title 컴포넌트 분리 */}\n      <h1>h1</h1>\n\n      {/* 이부분 분리 필요 */}\n      <p>{count}</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      {/* 이부분 분리 필요 */}\n    </>\n  );\n};\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"자주 랜더되는 컴포넌트를 찾고 그 parent노드를 찾아 가면서 최적화."}),"\n"]}),"\n","\n",(0,i.jsxs)(n.h3,{id:"시험단계",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#시험단계",children:"#"}),"시험단계"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"React forget(React without memo)"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offscreen API"})," ",(0,i.jsx)(n.a,{href:"https://vuejs.org/guide/built-ins/keep-alive.html#include-exclude",rel:"noopener noreferrer",target:"_blank",children:"https://vuejs.org/guide/built-ins/keep-alive.html#include-exclude"})]}),"\n"]}),"\n","\n",(0,i.jsxs)(n.h3,{id:"참고링크",children:[(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#참고링크",children:"#"}),"참고링크"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://ko.reactjs.org/docs/reconciliation.html#the-diffing-algorithm",rel:"noopener noreferrer",target:"_blank",children:"https://ko.reactjs.org/docs/reconciliation.html#the-diffing-algorithm"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/facebook/react/blob/bd081376665f5f081dcf4bf72f06b7e563c8046d/packages/react-reconciler/src/ReactChildFiber.old.js#L736",rel:"noopener noreferrer",target:"_blank",children:"https://github.com/facebook/react/blob/bd081376665f5f081dcf4bf72f06b7e563c8046d/packages/react-reconciler/src/ReactChildFiber.old.js#L736"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/20346379",rel:"noopener noreferrer",target:"_blank",children:"https://zhuanlan.zhihu.com/p/20346379"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://react.iamkasong.com/diff/multi.html",rel:"noopener noreferrer",target:"_blank",children:"https://react.iamkasong.com/diff/multi.html"})}),"\n"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(d,e)})):d(e)}let r=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["note%2Freact%2Fperformance.md"]={toc:[{id:"diff-algorithm-vdom",text:"Diff Algorithm (VDOM)",depth:2},{id:"1-tree-diff-동일레벨depth-요소끼리-비교",text:"1. Tree diff 동일레벨(depth) 요소끼리 비교",depth:4},{id:"2-component-비교",text:"2. component 비교",depth:4},{id:"3-element-type-비교",text:"3. Element Type 비교",depth:4},{id:"4-element-props-비교",text:"4. Element Props 비교",depth:4},{id:"5-key우선순위-제일-높음",text:"5. key(우선순위 제일 높음.)",depth:4},{id:"6-멀티노드-비교",text:"6. 멀티노드 비교",depth:4},{id:"react-render하는-조건bailout조건",text:"React render하는 조건(bailout조건)",depth:2},{id:"최적화-유형",text:"최적화 유형",depth:2},{id:"react-design",text:"React Design",depth:2},{id:"시험단계",text:"시험단계",depth:3},{id:"참고링크",text:"참고링크",depth:3}],title:"React성능 최적화",headingTitle:"React성능 최적화",frontmatter:{}}}}]);