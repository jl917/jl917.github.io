"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["1613"],{4401:function(n,e,t){t.r(e),t.d(e,{default:()=>s});var r=t(5893),i=t(65);function l(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",h4:"h4",pre:"pre",code:"code"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"기초문법",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#기초문법",children:"#"}),"기초문법"]}),"\n",(0,r.jsxs)(e.h2,{id:"요약",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#요약",children:"#"}),"요약"]}),"\n",(0,r.jsxs)(e.h4,{id:"hello-world",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#hello-world",children:"#"}),"hello world"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s = "hello world";\n    println!("{}", s); // println! macro   标准输出macro 可以完成编译器格式检查， 更加安全\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"타입지정",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#타입지정",children:"#"}),"타입지정"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"fn Foo(input1: i32, input2: u32) -> i32 {\n  ...\n}\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"use",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#use",children:"#"}),"use"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"use std::prelude::*; // std rust에서 제공하는 standard 유틸\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"format",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#format",children:"#"}),"Format"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    println!("{}", 1); // default\n    println!("{:o}", 9); // 八进制\n    println!("{:x}", 255); // 十六进制 小写\n    println!("{:X}", 255); // 十六进制 大写\n    println!("{:p}", &0); // pointer\n    println!("{:b}", 15); // 二进制\n    println!("{:e}", 10000f32); // 科学计数 小写\n    println!("{:E}", 10000f32); // 科学计数 大写\n    println!("{:?}", "test"); // debug\n    println!("{:#?}", ("test1", "test2")); // 带换行和缩进的debug\n    println!("{a} {b} {b}", a = "x", b = "y"); // 命名参数\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"변수선언",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#변수선언",children:"#"}),"변수선언"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"let num: i32 = 100;\nlet num = 100i32;\n\nlet x = 5;\nx = 10; // error\n\nlet mut x = 5;\nx = 10;\n\nlet x:i32;\nx = 1;\n\nlet (mut a, mut b) = (1,2);\nlet Point {x: ref a, y: ref b} = p;\n\nstatic GLOBAL:i32 = 0;\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"기본-데이터-유형",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#기본-데이터-유형",children:"#"}),"기본 데이터 유형"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"let empty: () = (); // unit type\nlet boolean: bool = true;\nlet t1: char = 'x';\n// u8 ~ u128\nlet i1: i8 = -128; // -128~127\nlet i2: u8 = 255; // 0~255\n// f32, f64\nlet f1: f32 = 123.0;\nlet f2 = 123.0f32;\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"복합-데이-유형",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#복합-데이-유형",children:"#"}),"복합 데이 유형"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// tuple\nlet a = (1i32, false);\nlet b = (a, (1i32, 2i32));\nlet a = (0,);\nlet b: i32 = (0); // 표현식, tuple 아님\n\n// struct\nstruct Point {\n  x: i32,\n  y: i32,\n}\nlet p = Point {x: 0, y: 0};\nprintln!("point is at {} {}",p.x, p.y);\n\n// struct: 생략 가능\nlet x = 10;\nlet y = 20;\nlet p = Point {x, y};\n\n// struct: px, py alias로 바인딩 가능\nlet p = Point { x: 0, y: 1 };\nlet Point { x: px, y: py } = p;\n\n// struct: destruct도 가능\nlet Point {x, y} = p;\n\n// struct: 语法糖, default 지정 가능\nstruct Point3d {\n  x: i32,\n  y: i32,\n  z: i32,\n}\nfn default() -> Point3d {\n  Point3d { x: 0, y: 0, z: 0 }\n}\nlet origin = Point3d { x: 4, ..default() };\n\n// tuple struct\nstruct T(i32);\nlet v1 = T(1);\nlet v2 = T{0: 1};\n\n// enum\nenum Number {\n    Int(i32),\n    Float(f32),\n}\n// Number::Int로 enum구성원에 접근\nfn read_num(num: &Number) {\n    match num {\n        &Number::Int(value) => println!("integer {}", value),\n        &Number::Float(value) => println!("float {}", value),\n    }\n}\nfn main() {\n    let n: Number = Number::Int(10);\n    read_num(&n);\n}\n// index\nenum Animal {\n    dog = 1, // 선언하지 않으면 0\n    cat = 200,\n    tiger,\n}\n\nlet x = Animal::tiger as isize;\nprintln!("{}", x) // 201\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"expression",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#expression",children:"#"}),"Expression"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let x = 100;\nlet y = 10;\nlet t = true;\nlet f = false;\n\nprintln!("{}", x + y);\nprintln!("{}", x - y);\nprintln!("{}", x * y);\nprintln!("{}", x / y);\nprintln!("{}", x % y);\nprintln!("{}", x == y);\nprintln!("{}", x != y);\nprintln!("{}", x < y);\nprintln!("{}", x > y);\nprintln!("{}", x >= y);\nprintln!("{}", x <= y);\nprintln!("{}", t && f);\nprintln!("{}", t || f);\nprintln!("{}", !t);\n\nlet mut y1 = 40;\nlet mut y2 = 40;\nlet mut y3 = 40;\nlet mut y4 = 40;\nlet mut y5 = 40;\ny1 += 10;\ny2 -= 10;\ny3 *= 10;\ny4 /= 10;\ny5 %= 10;\nprintln!("{}", y1);\nprintln!("{}", y2);\nprintln!("{}", y3);\nprintln!("{}", y4);\nprintln!("{}", y5);\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let x: () = {\n    println!("hello x");\n};\nx;\nlet y: i32 = {\n    println!("hello y");\n    30\n};\nprintln!("{}", y);\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"if-else",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#if-else",children:"#"}),"if else"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'fn func(n: i32) -> bool {\n    if n < 0 {\n        println!("{} is negative", n);\n    } else if n > 0 {\n        println!("{} is positive", n);\n    } else {\n        println!("{} is zero", n);\n    }\n    return n > 0;\n}\nlet x = func(-3);\nprintln!("{}", x)\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"loop",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#loop",children:"#"}),"loop"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let mut count = 0u32;\n\nloop {\n    count += 1;\n    if count == 3 {\n        println!("three");\n        continue;\n    }\n\n    println!("{}", count);\n    if count >= 5 {\n        println!("OK");\n        break;\n    }\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"while",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#while",children:"#"}),"while"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let mut count = 0u32;\n\nwhile count < 101 {\n    if count % 15 == 0 {\n        println!("fizzbuzz");\n    } else if count % 3 == 0 {\n        println!("fizz");\n    } else if count % 5 == 0 {\n        println!("buzz");\n    } else {\n        println!("{}", count);\n    }\n    count += 1;\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"for",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#for",children:"#"}),"for"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let array = &[1, 2, 3, 4, 5];\nfor i in array {\n    println!("is {}", i);\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"함수",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#함수",children:"#"}),"함수"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// 일반\nfn add(t: (i32, i32)) -> i32 {\n    t.0 + t.1\n}\nfn add2((a, b): (i32, i32)) -> i32 {\n    a + b\n}\nprintln!("{}", add((1, 2)));\nprintln!("{}", add2((3, 4)))\n\n// return이 없는 경우 unit ()\nfn empty(a: i32) -> () {\n    a+a;\n}\n\n// 함수에 값을 할당해서 사용(타입이 동일할 때에만 할당 가능)\n// let mut f = add as fn((i32, i32)) -> i32;\nlet mut f: fn((i32, i32)) -> i32 = add;\nf = add2;\n\nprintln!("{}", f((1, 3)))\n\n// main함수 args\nfn main() {\n    for arg in std::env::args() {\n        println!("{}", arg);\n    }\n    std::process::exit(0);\n}\n// ./004 test1 opt2\n// ./004\n// test1\n// opt2\n\n// const 함수 컴파일 단계에서 실행하는 함수라서 제한이 많음,\n// 제한이 있을수 있으니 조심해서 사용\nconst fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nlet total: i32 = add(1, 2);\nlet total2: i32 = add(3, 4);\nprintln!("{}", total);\nprintln!("{}", total2);\n\n// 재귀 함수\n// 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n// rust1.19 버전까지 trail call 최적화가 되지 않음.\nfn fib(index: u32) -> u64 {\n    if index == 1 || index == 2 { 1 } else { fib(index - 1) + fib(index - 2) }\n}\n\nlet f8 = fib(8);\nprintln!("{}", f8)\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"trait",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#trait",children:"#"}),"trait"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// method\ntrait Shape {\n    fn area(&self) -> f64;\n}\nstruct Circle {\n    radius: f64,\n}\n\nimpl Shape for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * self.radius * self.radius\n    }\n}\n\nlet c = Circle { radius: 2f64 };\nprintln!("{}", c.area());\n\n// static method\nstruct T(i32);\nimpl T {\n    fn func(this: &Self) {\n        println!("{}", this.0)\n    }\n}\n\nlet x = T(42);\nT::func(&x);\n\n// extend method\ntrait Double {\n    fn double(&self) -> Self;\n}\nimpl Double for i32 {\n    fn double(&self) -> i32 {\n        *self * 2\n    }\n}\n\nlet x: i32 = (10).double();\nprintln!("{}", x)\n\n// fully qualified syntax(universal function call syntax)\ntrait Cook {\n    fn start(&self);\n}\ntrait Wash {\n    fn start(&self);\n}\nstruct Chef;\nimpl Cook for Chef {\n    fn start(&self) {\n        println!("Cook::start");\n    }\n}\nimpl Wash for Chef {\n    fn start(&self) {\n        println!("Wash::start");\n    }\n}\n\nlet me = Chef;\n<Cook>::start(&me);\n<Chef as Wash>::start(&me);\n\n// alias\npub trait Service {\n    type Request;\n    type Response;\n    type Error;\n    type Future: Future<Item=Self::Response, Error=Self::Error>;\n    fn call(&self, req: Self::Request) -> Self::Future;\n}\n\ntrait HttpService = Service<Request = http::Request, Response = http::Response, Error = http::Error>;\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"array",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#array",children:"#"}),"array"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let v = [1,2,3];\n// 크기 반드시 지정, 가변 크기는 std Vec/LinkedList 사용\nlet xs: [i32; 5] = [1, 2, 3, 4, 5];\nprintln!("{:?}", xs)\n\n// 기본값 으로 fill처리\nlet xs: [i32; 5] = [0; 5];\nprintln!("{:?}", xs)\n\n// 2depth\nlet v: [[i32;2];3 ] = [[0,0],[0,0],[0,0]]\n\n// range\nlet r = 1..10;\nfor i in r {\n    println!("{}", i);\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"string",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#string",children:"#"}),"string"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'let greeting: &str = "Hello";\nlet substr: &str = &greeting[2..];\nprintln!("{}", greeting);\nprintln!("{}", substr);\n\nlet mut s = String::from("Hello");\ns.push(\' \');\ns.push_str("World");\nprintln!("{}", s)\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"match",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#match",children:"#"}),"match"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'enum Direction {\n    East,\n    West,\n    South,\n    North,\n}\n\nfn print(x: Direction) {\n    match x {\n        Direction::East => {\n            println!("East");\n        }\n        Direction::West => {\n            println!("West");\n        }\n        Direction::South => {\n            println!("South");\n        }\n        Direction::North => {\n            println!("North");\n        }\n    }\n}\n\nfn print2(y: Direction) {\n    match y {\n        Direction::East => {\n            println!("East");\n        }\n        _ => {\n            println!("Other");\n        }\n    }\n}\n\nfn print3(x: Direction) {\n    match x {\n        Direction::East => 10\n        Direction::West => 20\n        Direction::South => 30\n        Direction::North => 40\n    }\n}\n\nlet x = Direction::East;\nlet y = Direction::West;\nprint(x);\nprint2(y);\nprint3(x);\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"_",children:[(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#_",children:"#"}),"_"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'struct P(i32, i32, i32);\nfn calc(P(x, _, y): P) -> i32 {\n    x * x + y * y\n}\nlet t = P(1, 2, 3);\nprintln!("{}", calc(t));\n'})})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(l,n)})):l(n)}let s=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["note%2Frust%2F001.md"]={toc:[{id:"요약",text:"요약",depth:2},{id:"hello-world",text:"hello world",depth:4},{id:"타입지정",text:"타입지정",depth:4},{id:"use",text:"use",depth:4},{id:"format",text:"Format",depth:4},{id:"변수선언",text:"변수선언",depth:4},{id:"기본-데이터-유형",text:"기본 데이터 유형",depth:4},{id:"복합-데이-유형",text:"복합 데이 유형",depth:4},{id:"expression",text:"Expression",depth:4},{id:"if-else",text:"if else",depth:4},{id:"loop",text:"loop",depth:4},{id:"while",text:"while",depth:4},{id:"for",text:"for",depth:4},{id:"함수",text:"함수",depth:4},{id:"trait",text:"trait",depth:4},{id:"array",text:"array",depth:4},{id:"string",text:"string",depth:4},{id:"match",text:"match",depth:4},{id:"_",text:"_",depth:4}],title:"기초문법",headingTitle:"기초문법",frontmatter:{}}}}]);