"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["3851"],{9052:function(e,n,t){t.r(n),t.d(n,{default:()=>u});var r=t(5893),i=t(65);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",pre:"pre",code:"code"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"structures",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#structures",children:"#"}),"Structures"]}),"\n",(0,r.jsxs)(n.h2,{id:"stack",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#stack",children:"#"}),"Stack"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function Stack() {\n  let items = [];\n  // 添加元素\n  this.push = (element) => (items = [...items, element]);\n  // 删除元素\n  this.pop = () => items.pop();\n  // 返回顶元素\n  this.peek = () => items[items.length - 1];\n  // 是否为空\n  this.isEmpty = () => items.length === 0;\n  // 清空\n  this.clear = () => (items = []);\n  // 元素个数\n  this.size = () => items.length;\n  // 打印\n  this.print = () => items;\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"queue",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#queue",children:"#"}),"Queue"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function Queue() {\n  let items = [];\n  // 添加元素\n  this.enqueue = (element) => (items = [...items, element]);\n  // 删除元素\n  this.dequeue = () => items.shift();\n  // 第一个元素\n  this.front = () => items[0];\n  // 是否为空\n  this.isEmpty = () => items.length === 0;\n  // 元素个数\n  this.size = () => items.length;\n  // 打印\n  this.print = () => items;\n}\n\nfunction PriorityQueue() {\n  let items = [];\n  // 添加元素\n  this.enqueue = (element, priority) => {\n    const obj = { element, priority };\n    for (let i = 0; i < items.length; i++) {\n      // 根据重要度插入到特定位置\n      if (priority > items[i].priority) {\n        return (items = [...items.slice(0, i), obj, ...items.slice(i)]);\n      }\n    }\n    return (items = [...items, obj]);\n    // 速度慢\n    // items = [...items, obj].sort((a,b) => b.priority - a.priority)\n  };\n  // 删除元素\n  this.dequeue = () => items.shift();\n  // 第一个元素\n  this.front = () => items[0];\n  // 是否为空\n  this.isEmpty = () => items.length === 0;\n  // 元素个数\n  this.size = () => items.length;\n  // 打印\n  this.print = () => items;\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"linkedlist",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#linkedlist",children:"#"}),"LinkedList"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function LinkedList() {\n  function Node(element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head;\n\n  // 尾部添加\n  this.append = (value) => {\n    const element = new Node(value);\n    if (head) {\n      let current = head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = element;\n    } else {\n      head = element;\n    }\n    length++;\n  };\n\n  // 特定位置插入\n  this.insert = (position, value) => {\n    const element = new Node(value);\n    let index = 1;\n    let current = head;\n    let tmp;\n\n    while (index < position) {\n      current = current.next;\n      index++;\n    }\n    length++;\n    if (position === 0) {\n      element.next = current;\n      head = element;\n    } else {\n      tmp = current.next;\n      current.next = element;\n      current.next.next = tmp;\n    }\n  };\n\n  // 特定位置移除一项\n  this.removeAt = (position) => {\n    let index = 0;\n    let previos;\n    let current = head;\n\n    while (index < position) {\n      previos = current;\n      current = current.next;\n      index++;\n    }\n    previos.next = current.next;\n\n    length--;\n  };\n\n  // 移除一项\n  this.remove = (value) => {\n    let previos;\n    let current = head;\n    while (current.element !== value) {\n      previos = current;\n      current = current.next;\n    }\n    previos.next = current.next;\n    length--;\n  };\n\n  // 返回索引\n  this.indexOf = (value) => {\n    let index = 0;\n    let current = head;\n    while (current.element !== value) {\n      current = current.next;\n      index++;\n    }\n    return index;\n  };\n\n  // 是否为空\n  this.isEmpty = () => length === 0;\n\n  // 元素个数\n  this.size = () => length;\n\n  // 获取链头\n  this.getHead = () => head.element;\n\n  // 打印\n  this.print = () => head;\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"set",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"}),"Set"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function NS_Set(a, b) {\n  // 并集\n  this.union = () => [...new Set(a.concat(b))];\n\n  // 交集\n  this.intersection = () => a.filter((e) => b.includes(e));\n\n  // 差集\n  this.difference = () => a.filter((e) => !b.includes(e));\n\n  // 子集\n  this.subset = () => b.every((e) => a.includes(e));\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"tree",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tree",children:"#"}),"Tree"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function BinarySearchTree() {\n  function Node(element) {\n    this.element = element;\n    this.left = null;\n    this.right = null;\n  }\n  let root;\n\n  // 添加值\n  this.insert = (element) => {\n    const node = new Node(element);\n    let current = root;\n\n    if (!root) {\n      return (root = node);\n    }\n\n    while (current.element !== node.element) {\n      if (current.element > node.element) {\n        current.left ? (current = current.left) : (current.left = node);\n      }\n\n      if (current.element < node.element) {\n        current.right ? (current = current.right) : (current.right = node);\n      }\n    }\n    return ''\n  };\n\n  // 搜索\n  this.search = (element) => {\n    let current = root;\n\n    while (current) {\n      if (current.element === element) {\n        return true;\n      }\n      current = current[current.element > element ? 'left' : 'right'];\n    }\n\n    return false;\n  };\n\n  // 最小值\n  this.min = (current = root) => {\n    while (current.left) {\n      current = current.left;\n    }\n    return current.element;\n  };\n\n  // 最大值\n  this.max = (current = root) => {\n    while (current.right) {\n      current = current.right;\n    }\n    return current.element;\n  };\n\n  // 删除元素\n  this.remove = (element, isAll = true) => {\n    let current = root;\n    let previos = {\n      node: root,\n      type: 'left',\n    };\n\n    if (root.element === element) {\n      return console.log('root无法删除');\n    }\n\n    while (current) {\n      if (current.element === element) {\n        // 删除整个节点或者无子元素\n        if (isAll || (current.left === null && current.right === null)) {\n          return (previos.node[previos.type] = null);\n        }\n\n        if (current.left !== null && current.right !== null) {\n          // 两个子节点\n          // 替换为右侧节点中最小值并保持原先的lr\n          // const value = this.min(current.right)\n          // 替换为左侧节点中最大值并保持原先的lr\n          const value = this.max(current.left);\n          this.remove(value, true);\n          previos.node[previos.type].element = value;\n        } else {\n          // 一个子节点\n          previos.node[previos.type] = current[current.left || current.right];\n        }\n        return '';\n        //\n      }\n      previos = {\n        node: current,\n        type: current.element > element ? 'left' : 'right',\n      };\n      current = current[current.element > element ? 'left' : 'right'];\n    }\n\n    return false;\n  };\n\n  // 中序遍历\n  this.inOrderTraverse = () => {\n    function fn(node) {\n      if (node.left) {\n        fn(node.left);\n      }\n      console.log(node.element);\n      if (node.right) {\n        fn(node.right);\n      }\n    }\n    fn(root);\n  };\n  // 先序遍历\n  this.preOrderTraverse = () => {\n    function fn(node) {\n      console.log(node.element);\n      if (node.left) {\n        fn(node.left);\n      }\n\n      if (node.right) {\n        fn(node.right);\n      }\n    }\n    fn(root);\n  };\n  // 后序遍历7\n  this.postOrderTraverse = () => {\n    function fn(node) {\n      if (node.left) {\n        fn(node.left);\n      }\n      if (node.right) {\n        fn(node.right);\n      }\n      console.log(node.element);\n    }\n    fn(root);\n  };\n\n  this.print = () => console.log(JSON.stringify(root, null, 2));\n}\n"})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(s,e)})):s(e)}let u=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["algorithm%2Fstructures.md"]={toc:[{id:"stack",text:"Stack",depth:2},{id:"queue",text:"Queue",depth:2},{id:"linkedlist",text:"LinkedList",depth:2},{id:"set",text:"Set",depth:2},{id:"tree",text:"Tree",depth:2}],title:"Structures",headingTitle:"Structures",frontmatter:{}}}}]);