[{"title":"抽象工厂模式(Abstract Factory)","content":"#\n\n抽象工厂模式（Abstract Factory\nPattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\nclass Employee {\n  constructor(name) {\n    this.name = name;\n  }\n  say() {\n    console.log(`I am ${this.name}`);\n  }\n}\n\nclass EmployeeFactory {\n  constructor() {}\n  create(name) {\n    return new Employee(name);\n  }\n}\n\nexport { EmployeeFactory };\n\n\nconst employeeFactory = new EmployeeFactory();\nconst dao = employeeFactory.create(\"DaoLang\");\ndao.say();\n","routePath":"/algorithm/pattern/01","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"构建者模式(Builder)","content":"#\n\n将对象构造与其表示分开\n\nclass Starbucks {\n  constructor() {}\n  create(builder) {\n    builder.step1();\n    builder.step2();\n    builder.step3();\n    return builder.get();\n  }\n}\n\nclass Americano {\n  constructor() {\n    this.water = null;\n    this.coffee = null;\n  }\n  addCoffee() {\n    this.coffee = \"20g\";\n  }\n  addWater() {\n    this.water = \"400ml\";\n  }\n}\n\nclass AmericanoBuilder {\n  constructor() {\n    this.drink = null;\n  }\n  step1() {\n    this.drink = new Americano();\n  }\n  step2() {\n    this.drink.addCoffee();\n  }\n  step3() {\n    this.drink.addWater();\n  }\n  get() {\n    return this.drink;\n  }\n}\n\nexport { Starbucks, AmericanoBuilder };\n\n\nlet starbucks = new Starbucks();\nlet americanoBuilder = new AmericanoBuilder();\nstarbucks.create(americanoBuilder);\n","routePath":"/algorithm/pattern/02","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"工厂方法模式(Factory Method)","content":"#\n\n创建多个派生类的实例\n\nclass Apple {\n  constructor(model) {\n    this.model = model;\n  }\n  get() {\n    return this.model;\n  }\n}\n\nclass AppleCreate {\n  constructor() {}\n  create(model) {\n    return new Apple(model);\n  }\n}\n\nexport default AppleCreate;\n\n\nlet appleCreate = new AppleCreate();\nappleCreate.create(\"iphone 7\");\n","routePath":"/algorithm/pattern/03","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"原型模式(Prototype)","content":"#\n\n原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\nclass CustomerPrototype {\n  constructor(proto) {\n    this.proto = proto;\n  }\n  clone() {\n    const customer = new Customer();\n    customer.first = proto.first;\n    customer.last = protp.last;\n    customer.status = proto.status;\n    return customer;\n  }\n}\n\nclass Customer {\n  constructor(first, last, status) {\n    this.first = fisrt;\n    this.last = last;\n    this.status = status;\n  }\n  say() {\n    console.log(`name: ${this.first} ${this.last}, status: ${this.status}`);\n  }\n}\n\n\nconst proto = new Customer(\"n/a\", \"n/a\", \"pending\");\nconst prototype = new CustomerPrototype(proto);\nconst customer = prototype.clone();\ncustomer.say();\n","routePath":"/algorithm/pattern/04","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"单例模式(Singleton)","content":"#\n\n确保一个类只有一个实例，并提供一个全局访问点。\n\n//普通单体\nlet Singleton1 = {\n  name: \"Apple\",\n  get() {\n    return this.name;\n  },\n};\n\n//有局部变量的单体\nlet Singleton2 = () => {\n  let _name = \"apple\";\n  let _color = \"red\";\n  return {\n    name: _name,\n    color: _color,\n  };\n};\n\nexport { Singleton1, Singleton2 };\n\n\nSingleton1.get();\nSingleton2();\n","routePath":"/algorithm/pattern/05","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"适配器模式(Adapter)","content":"#\n\n匹配不同类的接口\n\n// old api\nclass Mart {\n  constructor() {\n    this.cola = 3;\n    this.bread = 5;\n  }\n  getPrice(type, num) {\n    return this[type] * Math.floor(num);\n  }\n}\n\n// new api\nclass NewMart {\n  constructor() {\n    this.cola = 3;\n    this.bread = 5;\n  }\n  getTotalPrice(...rest) {\n    let _result = 0;\n    rest.forEach((e) => {\n      _result += this[e.type] * e.length;\n    });\n    return _result;\n  }\n}\n\n//adapter\nclass MartAdapter {\n  constructor() {}\n\n  getPrice(type, num) {\n    return new Mart().getPrice(type, num);\n  }\n\n  getTotalPrice(...rest) {\n    return new NewMart().getTotalPrice(...rest);\n  }\n}\n\nexport { Mart, NewMart, MartAdapter };\n\n\nlet martAdapter = new MartAdapter();\n//old\nmartAdapter.getPrice(\"cola\", 5);\n//new\nmartAdapter.getTotalPrice({ type: \"cola\", length: 3 }, { type: \"bread\", length: 2 });\n","routePath":"/algorithm/pattern/06","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"桥接模式(Bridge)","content":"#\n\n将抽象与其实现分离，以便两者可以独立变化。\n\n// input device\nclass Mouse {\n  constructor(output) {\n    this.output = output;\n  }\n  click() {\n    this.output.click();\n  }\n  move() {\n    this.output.move();\n  }\n}\n\n// output device\nclass Screen {\n  construcotr() {}\n  click() {\n    console.log(\"screen click\");\n  }\n  move() {\n    console.log(\"screen move\");\n  }\n}\nexport { Mouse, Screen };\n\n\nconst screen = new Screen();\nconst mouse = new Mouse(screen);\nmouse.click();\nmouse.move();\n","routePath":"/algorithm/pattern/07","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"组合模式(Composite Pattern)","content":"#\n\n又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了\n对象组的树形结构。","routePath":"/algorithm/pattern/08","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"装饰者模式(Decorator)","content":"#\n\n动态地将附加职责附加到对象。 装饰器为子类化提供了灵活的替代扩展功能。\n\nclass User {\n  constructor(name, password) {\n    this.name = name;\n    this.password = password;\n  }\n}\nclass DecoratorUser {\n  constructor(user, email, tel) {\n    this.name = user.name;\n    this.password = user.password;\n    this.email = email;\n    this.tel = tel;\n  }\n  get() {\n    return this;\n  }\n}\n\nexport { User, DecoratorUser };\n\n\nlet user = new User(\"dao\", \"1234\");\nlet decUser = new DecoratorUser(user, \"julong1988@naver.com\", \"15526719999\");\ndecUser.get();\n","routePath":"/algorithm/pattern/09","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"外观模式(Facade)","content":"#\n\n为子系统中的一组接口提供统一接口。 Façade 定义了一个更高级别的接口，使子系统更易于使用。\n\nclass s1 {\n  constructor() {}\n  get(name, score) {\n    return name == \"julong\" || score == 100;\n  }\n}\n\nclass s2 {\n  constructor() {}\n  get(score) {\n    return score >= 80;\n  }\n}\n\nclass s3 {\n  constructor() {}\n  get(score) {\n    return score >= 60;\n  }\n}\n\nclass Student {\n  constructor(name, score) {\n    this.name = name;\n    this.score = score;\n  }\n}\nclass CheckScore {\n  constructor(student) {\n    this.name = student.name;\n    this.score = student.score;\n    this.message = \"\";\n  }\n  result() {\n    if (new s1().get(this.name, this.score)) {\n      this.message = \"全球旅游\";\n    } else if (new s2().get(this.score)) {\n      this.message = \"挨打50大板\";\n    } else if (new s3().get(this.score)) {\n      this.message = \"强制移民去印度\";\n    } else {\n      this.message = \"死刑\";\n    }\n    return this;\n  }\n}\n\nexport { Student, CheckScore };\n\n\nlet s01 = new Student(\"julong\", 50);\nlet s01Check = new CheckScore(s01);\ns01Check.result();\n","routePath":"/algorithm/pattern/10","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"享元模式(Flyweight Pattern)","content":"#\n\n主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。\n\nlet textCount = 0;\nlet textAttrCount = 0;\n\nclass Text {\n  constructor() {\n    this.text = \"\";\n  }\n  add(text) {\n    this.text = text;\n    textCount++;\n  }\n}\n\nclass TextAttr {\n  constructor() {}\n  add(color, size) {\n    this.color = color;\n    this.size = size;\n    textAttrCount++;\n  }\n}\n\nclass TextFactory {\n  constructor() {\n    this.textObj = new Text();\n    this.resultText = [];\n  }\n  create(text, color, size) {\n    if (this.textObj.text != text) {\n      this.textObj = new Text();\n      this.textObj.add(text);\n    }\n    let textAttr = new TextAttr();\n    textAttr.add(color, size);\n    this.resultText.push({\n      id: this.textObj.text + textAttr.color + textAttr.size,\n      text: this.textObj.text,\n      color: textAttr.color,\n      size: textAttr.size,\n    });\n  }\n\n  get() {\n    return this.resultText;\n  }\n\n  getCount() {\n    return {\n      textCount,\n      textAttrCount,\n    };\n  }\n}\n\nexport default TextFactory;\n\n\nlet text01 = new TextFactory();\ntext01.create(\"hello world\", \"red\", 14);\ntext01.create(\"hello world\", \"blue\", 16);\ntext01.create(\"hello world\", \"green\", 15);\ntext01.create(\"what the fuck~\", \"gray\", 30);\ntext01.get();\ntext01.getCount();\n","routePath":"/algorithm/pattern/11","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"代理模式(Proxy)","content":"#\n\n为另一个对象提供代理或占位符以控制对它的访问。\n\nclass Cola {\n  constructor() {\n    this.length = 0;\n  }\n  buy(length) {\n    this.length = this.length + length;\n  }\n  get() {\n    return this.length;\n  }\n}\n\nclass ColaProxy {\n  constructor() {\n    this.buyCola = new Cola();\n    this.count = 0;\n  }\n  buy(length) {\n    this.buyCola.buy(length);\n    this.count++;\n  }\n  get() {\n    return this.buyCola.get();\n  }\n  getCount() {\n    return this.count;\n  }\n}\n\nexport { Cola, ColaProxy };\n","routePath":"/algorithm/pattern/12","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"职责链模式(Chain of Responsibility)","content":"#\n\n通过为多个对象提供处理请求的机会，避免将请求的发送者耦合到其接收者。 链接接收对象并沿链传递请求，直到对象处理它。\n\nclass Request {\n  constructor(amount) {\n    this.amount = amount;\n    console.log(\"Requested: $\" + amount + \"\\n\");\n  }\n\n  get(bill) {\n    const count = Math.floor(this.amount / bill);\n    this.amount -= count * bill;\n    console.log(\"Dispense \" + count + \" $\" + bill + \" bills\");\n    return this;\n  }\n}\n\n\nconst request = new Request(378);\nrequest.get(100).get(50).get(20).get(10).get(5).get(1);\n","routePath":"/algorithm/pattern/13","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"命令模式(Command)","content":"#\n\n请求以命令的形式包裹在对象中\n\nlet add = (...rest) => rest.reduce((total, num) => total + num);\nlet sub = (a, b) => a - b;\nlet mul = (a, b) => a * b;\nlet div = (a, b) => a / b;\n\nclass Calculator {\n  constructor() {}\n  add(...rest) {\n    return add(...rest);\n  }\n  sub(a, b) {\n    return sub(a, b);\n  }\n  mul(a, b) {\n    return mul(a, b);\n  }\n  div(a, b) {\n    return div(a, b);\n  }\n}\n\nexport default Calculator;\n\n\ncalculator.add(2, 4, 5);\ncalculator.sub(22, 13);\ncalculator.mul(3, 7);\ncalculator.div(9, 3);\n","routePath":"/algorithm/pattern/14","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"解释器模式(Interpreter)","content":"#\n\n一种在程序中包含语言元素的方法","routePath":"/algorithm/pattern/15","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"迭代器模式(Iterator)","content":"#\n\n提供一种顺序访问聚合对象元素的方法，而不会暴露其基础表示。\n\nclass Iterator {\n  constructor(items) {\n    this.index = 0;\n    this.items = items;\n  }\n  first() {\n    this.index = 0;\n    return this.items[0];\n  }\n  next() {\n    this.index++;\n    return this.items[this.index];\n  }\n  hasNext() {\n    return this.items.length - 1 > this.index;\n  }\n  reset() {\n    this.index = 0;\n  }\n  each(callback) {\n    for (let i = 0; i < this.items.length; i++) {\n      callback(this.items[i]);\n    }\n  }\n}\n\n\nconst items = [\"one\", 2, \"circle\", true, \"Applepie\"];\nconst iter = new Iterator(items);\n\nconsole.log(iter.first());\nconsole.log(iter.next());\nconsole.log(iter.next());\nconsole.log(iter.next());\nconsole.log(iter.hasNext());\nconsole.log(iter.next());\n\niter.each(function (e) {\n  console.log(e);\n});\n","routePath":"/algorithm/pattern/16","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"中介者模式(Mediator)","content":"#\n\n定义类之间的简化通信\n\nclass User {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  sendMessage(target, message) {\n    target.addMessage(this.name, message);\n  }\n}\n\nclass ChatRoom {\n  constructor(crname) {\n    this.crname = crname;\n    this.message = [];\n  }\n  addMessage(name, message) {\n    this.message.unshift({ name, message });\n  }\n  showMessage() {\n    return this.message;\n  }\n}\nexport { User, ChatRoom };\n\n\nlet user1 = new User(\"julong\", \"23\");\nlet user2 = new User(\"dao\", \"32\");\nlet devRoom = new ChatRoom(\"devroom\");\nuser1.sendMessage(devRoom, \"hello\");\nuser1.sendMessage(devRoom, \"hi~  what\");\nuser2.sendMessage(devRoom, \"halou ju long \");\ndevRoom.showMessage();\n","routePath":"/algorithm/pattern/17","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"备忘录模式(Memento)","content":"#\n\n可以使用此模式的一个例子是将物件回复到其先前的状态\n\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  hydrate() {\n    return { ...this };\n  }\n\n  deydreate({ name, age }) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\nclass Store {\n  constructor() {\n    this.store = {};\n  }\n\n  add(key, value) {\n    this.store[key] = value;\n  }\n  get(key) {\n    return this.store[key];\n  }\n}\n\n\nconst dao = new Person(\"dao\", 12);\nconst lang = new Person(\"lang\", 30);\nconst store = new Store();\n\nstore.add(1, dao.hydrate());\nstore.add(2, lang.hydrate());\n\ndao.name = \"newdao\";\nlang.name = \"newlang\";\n\nconsole.log(dao);\nconsole.log(lang);\n\ndao.deydreate(store.get(1));\nlang.deydreate(store.get(2));\nconsole.log(dao);\nconsole.log(lang);\n","routePath":"/algorithm/pattern/18","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"观察者模式(Observer)","content":"#\n\n定义对象之间的一对多依赖关系，以便当一个对象更改状态时，将自动通知和更新其所有依赖项。\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n  sendPrice(target, price) {\n    target.addPrice(price);\n  }\n  getPrice(target) {\n    return target.getPrice();\n  }\n}\n\nclass Auction {\n  constructor() {\n    this.price = 0;\n    this.sellState = true;\n  }\n  addPrice(price) {\n    this.sellState ? (price > this.price ? (this.price = price) : \"\") : \"\";\n  }\n  getPrice() {\n    return this.price;\n  }\n  closeSell() {\n    this.sellState = false;\n  }\n}\n\nexport { User, Auction };\n\n\nlet user1 = new User(\"julong\");\nlet user2 = new User(\"dao\");\nlet auction = new Auction();\nuser1.sendPrice(auction, 12);\nuser2.sendPrice(auction, 32);\nuser1.getPrice(auction);\nauction.closeSell();\nuser2.sendPrice(auction, 36);\nuser1.getPrice(auction);\n","routePath":"/algorithm/pattern/19","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"状态模式(State)","content":"#\n\n在状态发生变化时改变对象的行为\n\n/*\nstate\n0 销售中\n1 订单成功\n2 商品转到物流\n3 物流发送\n*/\nclass System {\n  constructor() {\n    this.state = 0;\n  }\n  setState(state) {\n    this.state = state;\n  }\n}\n\nclass Sales {\n  constructor() {}\n  confirmOrder(target) {\n    target.state == 1 ? target.setState(2) : \"\";\n  }\n}\n\nclass Logistics {\n  constructor() {}\n  complet(target) {\n    target.state == 2 ? target.setState(3) : \"\";\n  }\n}\n\nclass Client {\n  constructor() {}\n  buy(target) {\n    target.state == 0 ? target.setState(1) : \"\";\n  }\n}\n\nexport { System, Sales, Logistics, Client };\n\n\nlet system = new System();\nlet client = new Client(\"julong\");\nlet sales = new Sales(\"sale1\");\nlet logistics = new Logistics(\"l1\");\nclient.buy(system);\nsales.confirmOrder(system);\nlogistics.complet(system);\n","routePath":"/algorithm/pattern/20","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"策略模式(Strategy)","content":"#\n\n将算法封装在类中\n\nclass Market1 {\n  constructor() {\n    this.products = {\n      cola: {\n        price: 3,\n        length: 20,\n      },\n    };\n  }\n\n  caculate(obj) {\n    return this.products[obj.name].price * obj.length;\n  }\n}\n\nclass Market2 {\n  constructor() {\n    this.products = {\n      cola: {\n        price: 2.5,\n        length: 20,\n      },\n    };\n  }\n\n  caculate(obj) {\n    return this.products[obj.name].price * obj.length;\n  }\n}\n\nclass Shop {\n  constructor(market) {\n    this.market = market;\n  }\n\n  caculate(obj) {\n    return this.market.caculate(obj);\n  }\n}\n\nexport { Shop, Market1, Market2 };\n\n\nlet market1 = new Shop(new Market1());\nlet market2 = new Shop(new Market2());\nmarket1.caculate({ name: \"cola\", length: 3 });\nmarket2.caculate({ name: \"cola\", length: 3 });\n","routePath":"/algorithm/pattern/21","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"模板方法模式(Template Method)","content":"#","routePath":"/algorithm/pattern/22","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"访问者模式(Visitor)","content":"#","routePath":"/algorithm/pattern/23","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"Structures","content":"#\n\n\nStack#\n\nfunction Stack() {\n  let items = [];\n  // 添加元素\n  this.push = (element) => (items = [...items, element]);\n  // 删除元素\n  this.pop = () => items.pop();\n  // 返回顶元素\n  this.peek = () => items[items.length - 1];\n  // 是否为空\n  this.isEmpty = () => items.length === 0;\n  // 清空\n  this.clear = () => (items = []);\n  // 元素个数\n  this.size = () => items.length;\n  // 打印\n  this.print = () => items;\n}\n\n\n\nQueue#\n\nfunction Queue() {\n  let items = [];\n  // 添加元素\n  this.enqueue = (element) => (items = [...items, element]);\n  // 删除元素\n  this.dequeue = () => items.shift();\n  // 第一个元素\n  this.front = () => items[0];\n  // 是否为空\n  this.isEmpty = () => items.length === 0;\n  // 元素个数\n  this.size = () => items.length;\n  // 打印\n  this.print = () => items;\n}\n\nfunction PriorityQueue() {\n  let items = [];\n  // 添加元素\n  this.enqueue = (element, priority) => {\n    const obj = { element, priority };\n    for (let i = 0; i < items.length; i++) {\n      // 根据重要度插入到特定位置\n      if (priority > items[i].priority) {\n        return (items = [...items.slice(0, i), obj, ...items.slice(i)]);\n      }\n    }\n    return (items = [...items, obj]);\n    // 速度慢\n    // items = [...items, obj].sort((a,b) => b.priority - a.priority)\n  };\n  // 删除元素\n  this.dequeue = () => items.shift();\n  // 第一个元素\n  this.front = () => items[0];\n  // 是否为空\n  this.isEmpty = () => items.length === 0;\n  // 元素个数\n  this.size = () => items.length;\n  // 打印\n  this.print = () => items;\n}\n\n\n\nLinkedList#\n\nfunction LinkedList() {\n  function Node(element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head;\n\n  // 尾部添加\n  this.append = (value) => {\n    const element = new Node(value);\n    if (head) {\n      let current = head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = element;\n    } else {\n      head = element;\n    }\n    length++;\n  };\n\n  // 特定位置插入\n  this.insert = (position, value) => {\n    const element = new Node(value);\n    let index = 1;\n    let current = head;\n    let tmp;\n\n    while (index < position) {\n      current = current.next;\n      index++;\n    }\n    length++;\n    if (position === 0) {\n      element.next = current;\n      head = element;\n    } else {\n      tmp = current.next;\n      current.next = element;\n      current.next.next = tmp;\n    }\n  };\n\n  // 特定位置移除一项\n  this.removeAt = (position) => {\n    let index = 0;\n    let previos;\n    let current = head;\n\n    while (index < position) {\n      previos = current;\n      current = current.next;\n      index++;\n    }\n    previos.next = current.next;\n\n    length--;\n  };\n\n  // 移除一项\n  this.remove = (value) => {\n    let previos;\n    let current = head;\n    while (current.element !== value) {\n      previos = current;\n      current = current.next;\n    }\n    previos.next = current.next;\n    length--;\n  };\n\n  // 返回索引\n  this.indexOf = (value) => {\n    let index = 0;\n    let current = head;\n    while (current.element !== value) {\n      current = current.next;\n      index++;\n    }\n    return index;\n  };\n\n  // 是否为空\n  this.isEmpty = () => length === 0;\n\n  // 元素个数\n  this.size = () => length;\n\n  // 获取链头\n  this.getHead = () => head.element;\n\n  // 打印\n  this.print = () => head;\n}\n\n\n\nSet#\n\nfunction NS_Set(a, b) {\n  // 并集\n  this.union = () => [...new Set(a.concat(b))];\n\n  // 交集\n  this.intersection = () => a.filter((e) => b.includes(e));\n\n  // 差集\n  this.difference = () => a.filter((e) => !b.includes(e));\n\n  // 子集\n  this.subset = () => b.every((e) => a.includes(e));\n}\n\n\n\nTree#\n\nfunction BinarySearchTree() {\n  function Node(element) {\n    this.element = element;\n    this.left = null;\n    this.right = null;\n  }\n  let root;\n\n  // 添加值\n  this.insert = (element) => {\n    const node = new Node(element);\n    let current = root;\n\n    if (!root) {\n      return (root = node);\n    }\n\n    while (current.element !== node.element) {\n      if (current.element > node.element) {\n        current.left ? (current = current.left) : (current.left = node);\n      }\n\n      if (current.element < node.element) {\n        current.right ? (current = current.right) : (current.right = node);\n      }\n    }\n    return ''\n  };\n\n  // 搜索\n  this.search = (element) => {\n    let current = root;\n\n    while (current) {\n      if (current.element === element) {\n        return true;\n      }\n      current = current[current.element > element ? 'left' : 'right'];\n    }\n\n    return false;\n  };\n\n  // 最小值\n  this.min = (current = root) => {\n    while (current.left) {\n      current = current.left;\n    }\n    return current.element;\n  };\n\n  // 最大值\n  this.max = (current = root) => {\n    while (current.right) {\n      current = current.right;\n    }\n    return current.element;\n  };\n\n  // 删除元素\n  this.remove = (element, isAll = true) => {\n    let current = root;\n    let previos = {\n      node: root,\n      type: 'left',\n    };\n\n    if (root.element === element) {\n      return console.log('root无法删除');\n    }\n\n    while (current) {\n      if (current.element === element) {\n        // 删除整个节点或者无子元素\n        if (isAll || (current.left === null && current.right === null)) {\n          return (previos.node[previos.type] = null);\n        }\n\n        if (current.left !== null && current.right !== null) {\n          // 两个子节点\n          // 替换为右侧节点中最小值并保持原先的lr\n          // const value = this.min(current.right)\n          // 替换为左侧节点中最大值并保持原先的lr\n          const value = this.max(current.left);\n          this.remove(value, true);\n          previos.node[previos.type].element = value;\n        } else {\n          // 一个子节点\n          previos.node[previos.type] = current[current.left || current.right];\n        }\n        return '';\n        //\n      }\n      previos = {\n        node: current,\n        type: current.element > element ? 'left' : 'right',\n      };\n      current = current[current.element > element ? 'left' : 'right'];\n    }\n\n    return false;\n  };\n\n  // 中序遍历\n  this.inOrderTraverse = () => {\n    function fn(node) {\n      if (node.left) {\n        fn(node.left);\n      }\n      console.log(node.element);\n      if (node.right) {\n        fn(node.right);\n      }\n    }\n    fn(root);\n  };\n  // 先序遍历\n  this.preOrderTraverse = () => {\n    function fn(node) {\n      console.log(node.element);\n      if (node.left) {\n        fn(node.left);\n      }\n\n      if (node.right) {\n        fn(node.right);\n      }\n    }\n    fn(root);\n  };\n  // 后序遍历7\n  this.postOrderTraverse = () => {\n    function fn(node) {\n      if (node.left) {\n        fn(node.left);\n      }\n      if (node.right) {\n        fn(node.right);\n      }\n      console.log(node.element);\n    }\n    fn(root);\n  };\n\n  this.print = () => console.log(JSON.stringify(root, null, 2));\n}\n","routePath":"/algorithm/structures","lang":"","toc":[{"text":"Stack","id":"stack","depth":2,"charIndex":3},{"text":"Queue","id":"queue","depth":2,"charIndex":395},{"text":"LinkedList","id":"linkedlist","depth":2,"charIndex":1421},{"text":"Set","id":"set","depth":2,"charIndex":3156},{"text":"Tree","id":"tree","depth":2,"charIndex":3446}],"frontmatter":{},"version":""},{"title":"AI 总结","content":"#\n\n\n如何成长#\n\n * 了解 AI 的模型和技术应用知识\n * 熟练使用 AI 开发工具\n * 构建 AI 驱动的原型 需要将概念转化为实际应用\n * AI 社区获取信息\n * 不断学习和多做实战项目\n\n\n需要技术#\n\n\nPrompt 提示词工程#\n\n * 要求\n   * 指令具体\n   * 信息丰富\n   * 尽量少歧义\n * 角色\n   * 你是一个专业的金融投资研究助手 你非常严谨\n\n\nContext Engineering#\n\n컨텍스트 엔지니어링이란 모델이 작업을 수행하는데 필요한 모든 정보, 도구, 환경을 체계적으로 설계하고 구성하는 접근 방식입니다. 컨텍스트는\n사용자의 요청에 맞춰서 동적으로 변화되어야 하고 모델이 중요한 정보를 놓치지 않도록 돕는 것입니다.\n\n\n\n\nRAG Retrieval-Augmented Generation#\n\n * 通过外部资源或数据库中纳入相关信息来实现\n\n\nFunction Calling#\n\n * 与外部函数或 api 交互的能力\n * 询问用户 补全信息\n * 基于 LLM 的语言理解能力 通过理解语义 自主决策使用某项工具 并结构化调用\n\n\nAgent 智能体#\n\n- LLM Based Agent\n    - 概念\n        - 无状态\n        - 有状态\n        - 连续\n        - 离散\n    - 目标\n        - 将无状态输出的大模型变成了有状态输出的逻辑大脑目标也是工业化\n        - 用好Agent关键是思考那些东西值得被离散化，状态化\n        - 不断测试大模型能力并研究如何提高状态判断的准确度\n- Multi-Agent Model\n\n\n\nFine tuning 微调#\n\n\nRAG vs Function Calling#\n\n能力维度    RAG             FUNCTION CALLING\n数据时效性   依赖索引更新（可能有延迟）   实时或近时（直接调用接口）\n实现复杂度   需构建检索逻辑         需定义清晰的接口和参数\n适用场景    静态知识（文档、FAQ）    动态交互（订单查询、天气）\n\n\nfine-tuning VS embedding#\n\n判断好坏是很看情境的，通常需要对业务比较熟悉的人来判断 (例如客服的场景需要资深客服判断)。 fine-tuning\n是提升模型的可控性，让模型可以更偏向某个你偏好的语气； embedding 则是让你可以不断即时加入新的资料。\n\n\nagent与workflow的区别是什么?#\n\n在 Anthropic 的《Building effective\nagents》一文中，有对两者清楚的区别。文中谈到，所谓的workflow，是设定既定的路径，然后让 AI\n在既定的路径中去执行不同任务。目前在社群中可以看到像是 n8n 或者 Zappier 这类工具，都偏向工作流这一个分类。\n\nAI Agent不需要事先设定好的流程，只需要目标，就会自行完成指定的任务，所以这种既定的流程，还不能算是agent，而只能被称为工作流。","routePath":"/artificialIntelligence/10-summary","lang":"","toc":[{"text":"如何成长","id":"如何成长","depth":2,"charIndex":3},{"text":"需要技术","id":"需要技术","depth":2,"charIndex":104},{"text":"Prompt 提示词工程","id":"prompt-提示词工程","depth":3,"charIndex":112},{"text":"Context Engineering","id":"context-engineering","depth":3,"charIndex":199},{"text":"RAG Retrieval-Augmented Generation","id":"rag-retrieval-augmented-generation","depth":3,"charIndex":359},{"text":"Function Calling","id":"function-calling","depth":3,"charIndex":422},{"text":"Agent 智能体","id":"agent-智能体","depth":3,"charIndex":519},{"text":"Fine tuning 微调","id":"fine-tuning-微调","depth":3,"charIndex":757},{"text":"RAG vs Function Calling","id":"rag-vs-function-calling","depth":3,"charIndex":775},{"text":"fine-tuning VS embedding","id":"fine-tuning-vs-embedding","depth":3,"charIndex":956},{"text":"agent与workflow的区别是什么?","id":"agent与workflow的区别是什么","depth":3,"charIndex":1100}],"frontmatter":{},"version":""},{"title":"평가","content":"#\n\n\n평가 지표기준#\n\n * 신뢰성\n * 답변 관련성: 사용자의 질문 의도와 주제에 맞는지\n * 프롬프트 Alignment: 프롬프트 템플릿에서 제시한 지침을 얼마나 준수했는지\n * 정확성: 답변이 사실에 기반하고 오류가 없는지\n * 환각: 허위 정보나 근거 없는 내용이 포함되어 있는지\n * 문맥 관련성: 참고 자료가 사용자의 질문과 관련성이 높은지\n * 책임 메트릭: 편향적이거나 유해한 내용이 포함되어 있는지\n * 작업완료 시간: 답변을 생성하는 데 걸리는 시간\n * 효율성: 답변을 생성하는 데 사용하는 컴퓨팅 자원의 양\n * 사용자 만족도: 사용자가 답변에 얼마나 만족하는지\n\n\n자체 벤치마크 구현이 필요#\n\n * 목적과 범위를 정의\n * 시나리오와 태스크를 설계\n * 질문 데잍터와 정답을 수집\n * 평가 지표와 방법론을 선택\n * 평가를 실행하고 결과를 분석\n * 결과를 개선하기 위한 조치\n\n\n평가 도구#\n\n * https://github.com/vibrantlabsai/ragas\n * https://github.com/confident-ai/deepeval\n * https://github.com/truera/trulens\n\n\n한국어 성능 평가를 위한 데이터셋#\n\n * KorNAT\n * KMMLU\n * KMMLU-HARD\n * HAE-RAE Bench","routePath":"/artificialIntelligence/100-Evaluation","lang":"","toc":[{"text":"평가 지표기준","id":"평가-지표기준","depth":3,"charIndex":3},{"text":"자체 벤치마크 구현이 필요","id":"자체-벤치마크-구현이-필요","depth":3,"charIndex":329},{"text":"평가 도구","id":"평가-도구","depth":3,"charIndex":452},{"text":"한국어 성능 평가를 위한 데이터셋","id":"한국어-성능-평가를-위한-데이터셋","depth":3,"charIndex":585}],"frontmatter":{},"version":""},{"title":"Embodied Intelligence","content":"#\n\n\n介绍#\n\n具身智能（Embodied\nIntelligence）是指智能体通过与环境的物理交互来学习和适应的能力。这种智能不仅依赖于计算能力，还依赖于感知、运动和环境反馈的综合作用。具身智能强调了身\n体在认知过程中的重要性，认为智能不仅仅是大脑的产物，而是整个身体与环境互动的结果。\n\n\n视觉模型以及数据集#\n\n * PaLM-E：Google开发的多模态模型，能够处理文本和图像输入，适用于各种任务，如视觉问答、图像描述和视觉推理。\n * RT-X\n * Open X-Embodiment -\n   https://github.com/google-deepmind/open_x_embodiment?tab=readme-ov-file","routePath":"/artificialIntelligence/110-Embodied","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"视觉模型以及数据集","id":"视觉模型以及数据集","depth":3,"charIndex":147}],"frontmatter":{},"version":""},{"title":"Large Language Model 大模型","content":"#\n\n大型语言模型，也称为 LLM，是基于大量数据进行预训练的超大型深度学习模型\n\n\n架构#\n\n * transfomer\n\n\ntoken#\n\n * tokenization是将文本分解成更小的单元（tokens）的过程，通常是单词、子词或字符。\n * 常用的分词算法\n   * BPE(Byte Pair Encoding)：通过迭代地合并最频繁的字节对来创建子词单元。\n   * WordPiece：类似于BPE，但在合并过程中考虑了词频和语言模型的性能。\\\n   * ULM(Unigram Language Model)：基于概率模型的分词方法，选择最可能的子词单元。\n   * SentencePiece：Google开发的一种分词工具，支持多种分词算法，并且能够处理未登录词。\n\n\n模型区分方法#\n\n * 结构划分\n   * decoder-only模型：如GPT系列，主要用于文本生成任务。\n   * encoder-only模型：如BERT系列，主要用于文本理解任务。\n   * encoder-decoder模型：如T5系列，既可以用于文本生成，也可以用于文本理解任务。\n * 规模划分\n   * 小型模型：参数量在数百万到数亿之间，适用于资源受限的环境。\n   * 大型模型：参数量在数十亿到数百亿之间，适用于需要高性能的应用。\n   * 超大型模型：参数量超过数百亿，适用于需要极高性能的应用，如GPT-4等。\n * 模态划分\n   * 单模态模型：仅处理一种类型的数据，如文本。\n   * 多模态模型：能够处理多种类型的数据，如文本、图像、音频等。\n * 微调方式划分\n   * 未经过微调的基础模型\n   * 经过指令微调的大模型\n   * 经过人类反馈强化学习微调的大模型\n\n\n大模型开发流程#\n\n 1. 确定目标和需求\n 2. 数据收集和预处理\n 3. 模型选择和架构设计\n 4. 训练模型 - 预训练和微调\n 5. 模型评估和优化\n 6. 部署和应用\n 7. 监控和维护\n\n\n추론모델 vs 비추론모델#\n\n항목         추론모델                   비추론모델\n문제 해결 방식   단계적 사고                 즉시 응답\n강한 영역      수학, 논리, 계획, 복잡한 의사결정   일반 대화, 요약, 글쓰기\n속도         느릴 수 있음                빠름\n비용(연산량)    높음                     낮음\n실수 패턴      느리지만 논리적               빠르지만 피상적\n긴 문제 처리    매우 강함                  중간에 논리 점프 발생 가능\n\n\n训练种类#\n\n * 迁移学习(Transfer learning)：基础模型在一个领域预训练，然后迁移到另一个领域进行微调。\n * 零样本学习(Zero-shot learning)：Base LLM 无需明确训练即可响应各种请求，通常是通过提示，但是答案的准确性各不相同。\n * 少量样本学习(Few-shot learning)：通过提供一些相关的训练示例，基础模型在该特定领域的表现显著提升。\n * 持续学习(Continual learning)：模型在不断接收新数据的同时，保持对先前学到的知识的记忆和应用能力。\n * 多任务学习(Multi-task learning)：模型同时在多个相关任务上进行训练，以提高其泛化能力和性能。\n * 强化学习(Reinforcement learning)：模型通过与环境交互并根据奖励信号进行学习，以优化其行为策略。\n * 微调(Fine-tuning)：这是少量样本学习的扩展，其中数据科学家训练基础模型，使模型使用与特定应用相关的其他数据来调整其参数。\n\n\n训练过程#\n\n * 预训练（Pretrain）\n * 监督微调（Supervised Fine-Tuning, SFT）\n * 人类反馈强化学习（Reinforcement Learning with Human Feedback, RLHF）\n\n\n特点#\n\n * 规模和参数量大\n * 适应性和灵活性强\n * 广泛数据集预训练\n * 计算资源需求大\n\n\n分类#\n\n * 大语言模型 LLM\n   * GPT-3, GPT-4\n   * Bard\n   * 通义千问\n   * Deepseek\n * 多模态模型\n   * 计算机视觉模型\n   * 音频处理模型\n   * ….\n\n\n工作流程#\n\n * 分词化(Tokenization)与词表映射\n   * 词粒度(Word-Level Tokenization)\n   * 字符力度(Character-Level)\n   * 子词粒度(Subword-Level)\n\n\n参数设置#\n\n * temperature\n   \n   * temperature 값이 낮을수록 항상 가장 확률이 높은 토큰(말뭉치의 최소 단위)이 선택되기 때문에 더 결정론적인 결과를 낳습니다.\n     temperature 값을 높였을 때 모델이 선택하는 토큰의 무작위성이 증가하여 보다 다양하고 창조적인 결과를 촉진합니다. 이는 다른\n     가능한 토큰의 가중치를 증가시키는 것과 같습니다. 애플리케이션의 경우, 사실을 기반으로 하는 질의응답과 같은 작업에는 낮은\n     temperature 값을 사용하여 보다 사실적이고 간결한 응답을 얻을 수 있습니다. 시를 생성하는 등 다른 창의적인 작업의 경우에는\n     temperature 값을 높이는 것이 도움이 될 수 있습니다.\n\n * top_p\n   \n   * temperature를 활용하는 핵 샘플링 기법인 top_p를 사용하면 모델이 응답을 생성하는 결정성을 제어할 수 있습니다. 정확하고\n     사실적인 답변을 원한다면 이를 낮게 유지합니다. 더 다양한 반응을 원한다면 더 높은 값으로 증가시킵니다.\n\n * Max Length\n   \n   * max length를 조정하여 모델이 생성하는 토큰의 수를 관리할 수 있습니다. max length를 지정하면 길거나 관련 없는 응답을\n     방지하고 제어 비용을 관리하는데 도움이 될 수 있습니다.\n\n * Stop Sequences\n   \n   * stop sequence는 모델의 토큰 생성을 중지하는 문자열입니다. stop sequences를 지정하는 것은 모델의 응답 길이 및\n     구조를 제어하는데 도움이 될 수 있습니다. 예를 들어, stop sequence로 \"11\"을 추가하여 항목이 10개를 초과하지 않는\n     리스트를 생성하도록 모델에 지시할 수 있습니다.\n\n * Frequency Penalty\n   \n   * frequency penalty는 해당 토큰이 응답 및 프롬프트에 등장한 빈도에 비례하여 다음에 등장할 토큰에 불이익을 적용합니다.\n     frequency penalty가 높을수록 단어가 다시 등장할 가능성이 줄어듭니다. 이 설정은 자주 등장하는 토큰에 대하여 더 많은\n     페널티를 부여하여 모델의 응답에서 단어의 반복을 방지합니다.\n\n * Presence Penalty\n   \n   * presence penalty는 반복되는 토큰에 패널티를 적용하지만, frequency penalty와 달리 모든 토큰에 동일한\n     페널티가 적용됩니다. 다시 말해, 토큰이 2회 등장하는 토큰과 10회 등장하는 토큰이 동일한 페널티를 받습니다. 이 설정은 모델이\n     응답에서 구문을 너무 자주 반복하는 것을 방지합니다. 다양하거나 창의적인 텍스트를 생성하기 위해 더 높은 presence\n     penalty를 사용할 수 있습니다. 혹은 모델이 집중력을 유지해야 할 경우(사실을 기반으로) 더 낮은 presence penalty를\n     사용할 수 있습니다.\n\n * verbose\n   \n   * 显示执行过程\n\n\n용어#\n\n * NLP(Natural Language Processing)：自然语言处理，研究计算机与人类语言之间的交互。\n * RNN(Recurrent Neural Network)：循环神经网络，适用于处理序列数据。\n * LSTM(Long Short-Term Memory)：长短期记忆网络，RNN的一种变体，能够捕捉长距离依赖关系。\n * Transformer：一种基于自注意力机制的模型架构，广泛应用于自然语言处理任务。\n * Word2Vec：一种将词语映射到连续向量空间的技术，捕捉词语之间的语义关系。\n * BERT(Bidirectional Encoder Representations from\n   Transformers)：一种预训练的语言表示模型，能够捕捉上下文信息。\n * GPT(Generative Pre-trained Transformer)：一种基于Transformer架构的生成式预训练模型，擅长文本生成任务。\n * PGC(Professional Generated Content)：专业生成内容，指由专业人员创作的内容。\n * UGC(User Generated Content)：用户生成内容，指由普通用户创作的内容\n * AIGC(Artificial Intelligence Generated Content)：人工智能生成内容，指由人工智能系统创作的内容。\n * RLHF(Reinforcement Learning with Human\n   Feedback)：一种结合强化学习和人类反馈的训练方法，用于优化模型的行为。\n\n\n参考链接#\n\n * https://www.tensorflow.org/tutorials?hl=ko\n * https://bbycroft.net/llm\n * https://huggingface.co/\n * https://www.modelscope.ai/\n * https://ollama.ai/\n * https://zhuanlan.zhihu.com/p/1947349437224558654\n * https://github.com/jingyaogong/minimind","routePath":"/artificialIntelligence/20-LargeLanguageModel","lang":"","toc":[{"text":"架构","id":"架构","depth":3,"charIndex":42},{"text":"token","id":"token","depth":3,"charIndex":63},{"text":"模型区分方法","id":"模型区分方法","depth":3,"charIndex":346},{"text":"大模型开发流程","id":"大模型开发流程","depth":3,"charIndex":752},{"text":"추론모델 vs 비추론모델","id":"추론모델-vs-비추론모델","depth":3,"charIndex":853},{"text":"训练种类","id":"训练种类","depth":3,"charIndex":1167},{"text":"训练过程","id":"训练过程","depth":3,"charIndex":1624},{"text":"特点","id":"特点","depth":3,"charIndex":1749},{"text":"分类","id":"分类","depth":3,"charIndex":1802},{"text":"工作流程","id":"工作流程","depth":3,"charIndex":1916},{"text":"参数设置","id":"参数设置","depth":3,"charIndex":2037},{"text":"용어","id":"용어","depth":3,"charIndex":3532},{"text":"参考链接","id":"参考链接","depth":3,"charIndex":4242}],"frontmatter":{},"version":""},{"title":"Prompt Engineering 提示词工程","content":"#\n\n\n구성요소#\n\n * Instruction 지시\n * Context 문맥\n * Input Data 입력 데이터\n * Output Indicator 출력 지시자\n\n\n예시#\n\n * 문장 요약\n * 정보 추출\n * 질의응답\n * 텍스트 분류\n * 대화\n * 코드 생성\n * 추론\n\n\nBest practices#\n\n * 최신 모델 사용\n * 프롬프트 시작 부분에 지침을 넣고 ### 또는 “””를 사용하여 지침과 맥락을 구분\n * 원하는 맥락, 결과, 길이, 형식, 스타일 등에 대해 구체적이고 설명적이며 가능한 한 자세하게 작성\n * 예시를 통해 원하는 출력 형식을 명확하게 표현\n * 제로샷(zero-shot)으로 시작한 다음, 퓨샷(few-shot)으로 진행하여 둘 다 작동하지 않으면 미세 조정\n * \"불분명하고\" 부정확한 설명을 줄임\n * 단순히 무엇을 하지 말아야 하는지 말하는 대신, 무엇을 해야 하는지 설명\n * 코드 생성에 특화 - \"선행 단어? 힌트\"를 사용하여 모델을 특정 패턴으로 유도.\n * Use the Generate Anything feature??????\n\n\nTechniques#\n\n * Zero-shot\n   \n   * 대량의 데이터를 학습하고 지침을 따르도록 튜닝된 오늘날의 머신러닝은 제로샷(zero-shot)으로 작업을 수행할 수 있습니다\n\n * Few-shot\n   \n   * 퓨샷(few-shot) 프롬프트는 프롬프트에서 데모를 제공하여 모델이 더 나은 성능을 발휘하도록 유도하는 문맥 내 학습을 가능하게 하는\n     기술로 사용할 수 있습니다\n\n * Chain-of-Thought (CoT)\n   \n   * LLM의 추론(사고)를 통해서 어려운 질문을 답변하는 기술입니다. 복잡한 로직을 Step을 나눠서 단순화 하고 다시 답변하는\n     방식.(Let's think step by step)\n   * 예시\n     \n     다음 질문을 단계적으로 생각해서 답을 도출해줘.\n     질문: 철수가 가지고 있는 사과가 10개이고, 그 중 3개를 친구에게 주었다. 남은 사과는 몇 개인가?\n     \n   \n   * 참고\n     * https://www.163.com/dy/article/J6BKPTPH051193U6.html\n\n * Self-Consistency\n   \n   * 개념\n     * 먼저 언어 모델의 디코더에서 샘플링하여 다양한 추론 경로 세트를 생성합니다. 각 추론 경로는 서로 다른 최종 답으로 이어질 수\n       있으므로, 샘플링된 추론 경로를 주변화하여 최적의 답을 결정합니다. 최종 답 세트에서 가장 일관된 답을 찾습니다. 이러한 접근\n       방식은 인간의 경험과 유사합니다.\n   * 핵심\n     * 여러경로를 통한 추론\n     * 답안중 빈도가 제일 높은 답안이 출력\n   * 특징\n     * 복잡한 추론에 대한 정확도를 올릴수 있다.\n     * 안정성을 높일수 있다.\n   * 예시\n     \n     다음 질문을 여러 번(다양한 샘플) 답한 뒤, 각 샘플의 최종 답을 모아 다수결로 최종답을 결정해줘.\n     질문: 철수가 가지고 있는 사과가 10개이고, 그 중 3개를 친구에게 주었다. 남은 사과는 몇 개인가?\n     \n   \n   * 참고\n     * https://zhuanlan.zhihu.com/p/1945455658657875626\n\n * Generated Knowledge Prompting\n   \n   * 개념\n     * 사용자가 입력한 내용(지식) 기반으로 답변을 생성.\n   * 정보\n     * 실시간 업데이트 되는 정보(주식, 스포츠 스코어등등)\n     * 정책, 계약서\n     * 논문이라든가 전문분야의 내용\n\n * [AGENT] Prompt Chaining\n   \n   * 개념\n     * LLM의 안정성과 성능을 개선하기 위해 중요한 프롬프트 엔지니어링 기법 중 하나는 작업을 하위 작업으로 분할하는 것입니다. 이러한\n       하위 작업이 식별되면 LLM에 하위 작업에 대한 프롬프트가 표시되고 그 응답이 다른 프롬프트의 입력으로 사용됩니다. 프롬프트\n       연쇄라는 개념으로 작업을 하위 작업으로 분할하여 프롬프트 작업의 연쇄를 만드는 것을 프롬프트 체이닝 이라고 합니다.\n\n * Tree of Thoughts\n   \n   * 개념\n     * 하나의 질문에 대해 여러 개의 사고 흐름을 동시에 전개하고, 그중 최적의 결과를 선택하도록 유도하는 방식입니다. 브레인스토밍을\n       확장한 전략으로, 결정 경로를 나무(tree)처럼 분기시켜 모델이 다양한 가능성을 탐색하게 합니다.\n   * 예시\n     \n     이 문제를 해결할 수 있는 여러 접근 방식을 제시하고, 각 방법을 평가한 뒤 최적의 해결책을 추천해줘.\n     \n\n * [AGENT] Retrieval Augmented Generation (RAG)\n\n * [AGENT]Automatic Reasoning and Tool-use (ART)\n\n * [AGENT] Automatic Prompt Engineer (APE)\n\n * [AGENT] Active-Prompt\n\n * [???] Directional Stimulus Prompting\n\n * [AGENT] Program-Aided Language Models\n\n * [AGENT] ReAct\n   \n   * 예시\n     \n     질문: 대한민국의 2022년 1인당 GDP는 얼마였어?\n     Thought → Action → Observation → Answer 순으로 단계별로 응답해줘.\n     \n\n * [AGENT] Reflexion 是一种让 AI 智能体通过反思机制持续学习和优化的技术‌\n\n\nInjection#\n\n시스템 가드레일을 무시하고 해서는 안 되는 말을 하게 만드는 것입니다.\n\n * 방지\n   * 안전 가드레일\n   * 명시적 금지\n   * 입력 유효성 검사 및 삭제\n   * 이상 활동 감지\n   * 매개변수화(시스템 명령과 사용자 입력을 명확하게 분리하는것.)\n   * 아웃풋 필터링\n   * 동적 피드백 및 학습\n   * 내부 프롬프트 강화\n   * 최소권한\n   * 상황 및 시나리오 기반 안내\n\n\nOpenAI 官方推荐六大策略#\n\n 1. 指令要清晰 (write clear instructions)\n    \n    // 范例1\n    总结会议记录\n    ---\n    [会议记录]\n    \n    // 范例2\n    用一个段落总结会议记录。然后写下演讲者的 Markdown 清单以及他们的每个要点。\n    最后，列出发言人建议的后续步骤或行动项目。\n    ---\n    [会议记录]\n    \n\n 2. 提供参照(provide reference text)\n    \n    使用下方提供的由三重引号内的文章来回答问题。\n    如果在文章中找不到答案，请回答“我找不到答案”。\n    ---\n    \"\"\"文章一\"\"\"\n    \"\"\"文章二\"\"\"\n    \"\"\"文章三\"\"\"\n    \n    问题：[问题]\n    \n\n 3. 将复杂任务拆成简单的子任务 (split complex tasks into simpler subtasks)\n    \n    使用分类来让 GPT 参照处理子任务\n    对于需要很长对话的对话应用，总结或过滤先前的对话\n    \n\n 4. 让 GPTs 有时间思考 (give GPTs time to “think”)\n    \n    首先制定自己的问题解决方案。\n    然后将你的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。\n    在你自己完成问题之前，不要决定学生的解决方案是否正确。\n    \n     ---\n    \n     问题陈述：XXX\n     学生的解答：XXX\n    \n\n 5. 善用外部工具 (use external tools)\n    \n    // 范例：使用计算器\n    你是一个有能力使用计算器的助手。\n    当你需要进行数学计算时，请使用以下格式：\n    计算：[数学表达式]\n    例如：\n    计算：23乘以47\n    \n\n 6. 系统性测试改变 (test changes systematically)\n    \n    当我们要确定提示词的修改或策略时，会需要定义一个全面性的测试，用系统性的方式评估，才能确保提示词是最佳的，让这个改变对总体影响是正面的。\n\n\n참고자료#\n\n * https://www.ibm.com/kr-ko/think/prompt-engineering#605511093\n * https://help.openai.com/en/articles/6654000-best-practices-for-prompt-enginee\n   ring-with-the-openai-api\n * https://zhuanlan.zhihu.com/p/1947349437224558654\n * https://www.promptingguide.ai/kr","routePath":"/artificialIntelligence/30-PromptEngineering","lang":"","toc":[{"text":"구성요소","id":"구성요소","depth":2,"charIndex":3},{"text":"예시","id":"예시","depth":2,"charIndex":92},{"text":"Best practices","id":"best-practices","depth":2,"charIndex":156},{"text":"Techniques","id":"techniques","depth":2,"charIndex":551},{"text":"Injection","id":"injection","depth":2,"charIndex":2778},{"text":"OpenAI 官方推荐六大策略","id":"openai-官方推荐六大策略","depth":3,"charIndex":3015},{"text":"참고자료","id":"참고자료","depth":3,"charIndex":3983}],"frontmatter":{},"version":""},{"title":"Prompt Engineering 샘플 모음","content":"#\n\n\nZero-shot#\n\n * 예시를 주지 않고 바로 요구하는 형식입니다.\n\n## 샘플1\n다음 문장을 읽고 핵심 주장을 한 문장으로 요약하시오:\n\"인공지능 기술은 빠르게 발전하고 있지만, 윤리적 기준과 책임에 대한 논의는 아직 충분히 이루어지지 않고 있다.\"\n\n## 샘플2\n환경 보호를 위해 개인이 실천할 수 있는 행동 5가지를 제시하시오.\n\n## 샘플3\n아래 주제에 대해 찬성과 반대 입장을 각각 간단히 작성하시오:\n\"학교 수업에 인공지능 도입이 반드시 필요하다.\"\n\n\n\nFew-shot#\n\n * \"예시\"를 보여주고 비슷한 답을 유도하는 방식입니다.\n\n## 샘플1\n예시:\n입력: 바다는 넓고 푸르다.\n출력: 바다는 광대하며 푸른 색을 띤다.\n\n질문:\n입력: 하늘은 매우 맑다.\n출력:\n\n## 샘플2\n예시:\n질문: 커피의 장점은 무엇인가?\n답변: 졸음을 방지하고 집중력을 높여준다.\n\n질문: 독서의 장점은 무엇인가?\n답변:\n\n## 샘플3\n예시:\n주제: 스마트폰\n설명: 스마트폰은 통화, 인터넷, 사진 촬영 등 다양한 기능을 제공하는 휴대용 전자기기이다.\n\n주제: 태블릿\n설명:\n\n\n\nChain-of-Thought (CoT)#\n\n * 사고 과정을 단계적으로 설명하도록 유도하는 프롬프트\n\n## 샘플1\n문제: 민수는 사과를 12개 가지고 있었고, 친구에게 5개를 나눠줬다. 그 후 3개를 더 샀다. 지금 사과는 몇 개인가?\n한 단계씩 생각하면서 풀이 과정을 설명하고 정답을 구하시오.\n\n## 샘플2\n문제: 어떤 수에 8을 곱하면 64가 된다.\n단계별로 어떻게 계산했는지 이유를 설명하고 답을 구하시오.\n\n## 샘플3\n문제: 환경오염이 심해질 경우 어떤 결과가 나타날지\n원인 → 과정 → 결과 순서로 논리적으로 설명하시오.\n\n\n\nSelf-Consistency Prompting#\n\n * 여러 개의 답을 생성하게 한 후, 가장 일관된 답을 선택하는 방식\n\n## 샘플1\n문제: 민수는 하루에 물을 몇 번 마셔야 건강에 좋을까요?\n이 질문에 대해 서로 다른 3가지 답변을 생성한 후,\n가장 합리적이고 공통적인 답을 최종 답변으로 선택하시오.\n\n## 샘플2\n주제: 인공지능이 교육에 미치는 영향\n이 주제에 대해 서로 다른 관점의 답변을 3개 작성하고,\n이 중 가장 설득력 있는 하나를 선택해 최종 답변으로 제시하시오.\n\n## 샘플3\n문제: 대중교통 이용을 장려해야 하는 이유는 무엇인가?\n3가지 서로 다른 설명을 만든 후,\n공통되는 핵심 이유를 하나의 문장으로 정리하시오.\n\n\n\nGenerated Knowledge Prompting#\n\n * 답변 전에 관련 지식을 먼저 생성하도록 유도하는 방식\n\n## 샘플1\n주제: 태양 에너지\n\n1단계: 태양 에너지에 대해 알고 있는 사실 5가지를 먼저 나열하시오.\n2단계: 위 정보를 활용하여 태양 에너지의 장점을 3가지로 정리하시오.\n\n## 샘플2\n주제: 인공지능 윤리\n\n1단계: 인공지능 윤리와 관련된 문제 혹은 키워드를 5개 작성하시오.\n2단계: 이를 바탕으로 인공지능 윤리가 중요한 이유를 설명하시오.\n\n## 샘플3\n주제: 독서 습관\n\n1단계: 좋은 독서 습관의 특징을 5가지 작성하시오.\n2단계: 이 특징을 활용하여 '효율적인 독서 방법'을 설명하시오.\n\n\n\nRole Prompting#\n\n * AI에게 특정 역할을 부여하고 답변을 생성하게 하는 방식\n\n## 샘플1\n당신은 고등학교 과학 교사입니다.\n\"기후 변화\"를 중학생이 이해할 수 있게 쉽게 설명해주세요.\n\n## 샘플2\n당신은 마케팅 전문가입니다.\n새로운 친환경 텀블러 제품을 홍보하는 문구를 3개 작성해주세요.\n\n## 샘플3\n당신은 심리 상담사입니다.\n시험 불안감을 느끼는 학생에게 조언을 해주세요.\n\n\n\nInstruction Prompting#\n\n * 구체적인 지시를 내려 원하는 결과를 얻는 방식\n\n## 샘플1\n다음 조건을 만족하는 100자 이내의 자기소개문을 작성하시오:\n- 목표가 분명해야 함\n- 긍정적인 표현 사용\n- 미래 계획 포함\n\n## 샘플2\n아래 단어를 반드시 포함하여 5문장의 짧은 이야기를 작성하시오:\n(인공지능, 바다, 여행, 친구, 사진)\n\n## 샘플3\n\"스마트 시티\"에 대한 설명을 다음 형식으로 작성하시오:\n1) 정의\n2) 장점 2가지\n3) 예상되는 문제점 1가지\n\n\n\nTree-of-Thought (ToT) Prompting#\n\n * 여러 개의 생각 경로(가지)를 만들어 각각 탐색한 뒤, 가장 좋은 답을 선택하는 방식\n\n## 샘플1\n문제: 학교 급식의 음식물 쓰레기를 줄이는 방법은 무엇일까?\n\n1단계: 가능한 해결 방법을 최소 3가지 이상 제시하시오.\n2단계: 각 방법의 장점과 단점을 비교하시오.\n3단계: 가장 효과적인 방법 하나를 선택하고 이유를 설명하시오.\n\n## 샘플2\n주제: 시험 준비를 가장 효율적으로 하는 방법\n\n1) 가능한 전략 3가지 이상 제시\n2) 각 전략의 예상 효과와 한계 분석\n3) 최적의 전략 선택 및 실천 계획 제시\n\n## 샘플3\n문제: 청소년 스마트폰 사용 시간을 어떻게 줄일 수 있을까?\n\n1. 해결 방법 여러 개 제안\n2. 각 방법의 현실성 평가\n3. 최종 대안 선정 및 실행 방법 설명\n\n\n\nMeta-Prompting#\n\n * AI에게 “어떤 프롬프트가 좋은지” 또는 “프롬프트를 어떻게 만들지”를 생각하게 하는 기법\n * → 즉, 프롬프트를 설계하는 프롬프트입니다.\n\n## 샘플1\n주제: 환경 보호에 대한 글쓰기\n\n이 주제를 가장 효과적으로 설명할 수 있는 프롬프트를 만들어 주세요.\n프롬프트에는 목적, 대상, 글의 형식을 포함하세요.\n\n## 샘플2\n목표: 중학생에게 인공지능 개념을 쉽게 설명하기\n\n이 목표를 달성하기 위한 가장 좋은 프롬프트 문장을 작성하세요.\n\n## 샘플3\n과제: 학교 폭력 예방을 위한 캠페인 포스터 제작\n\nAI에게 입력할 최적의 프롬프트를 단계별로 설계하세요.\n\n\n\nReAct Prompting (Reason + Act)#\n\n * 생각(Reason) → 행동(Act) → 다시 생각 → 행동… 을 반복하는 구조\n * 단순한 답변이 아니라 **추론 + 행동(도구 사용, 탐색, 실행)**이 결합된 방식입니다.\n\n## 샘플1\n문제: \"서울의 오늘 날씨에 맞는 옷차림 추천\"\n\n다음 형식으로 답변하시오:\nThought:\nAction:\nObservation:\nThought:\nFinal Answer:\n\n## 샘플2\n과제: 가장 효율적인 아침 루틴 만들기\n\nReAct 형식(Thought → Action → Observation → Thought → Final Answer)을 사용해 작성하시오.\n\n## 샘플3\n문제: 스마트폰 사용 시간을 줄이기 위한 계획 수립\n\nReAct 구조를 활용하여 단계별로 해결 방안을 도출하시오.\n\n\n\nReflexion 프롬프팅 (반성·개선 기반)#\n\n * 한 번 답한 후 → 스스로 평가(반성) → 개선된 답 제시\n * AI가 스스로 피드백을 하고 더 나은 답을 만드는 방식입니다.\n\n## 샘플1\n주제: 시험 성적을 올리는 방법\n\n1단계: 첫 번째 답변 작성\n2단계: 답변의 부족한 점을 스스로 지적\n3단계: 개선된 답변 작성\n\n## 샘플2\n문제: 학교 환경을 개선하는 방법\n\nReflexion 구조를 사용해 답하시오:\n- 초기 답변\n- 자기 반성\n- 수정된 답변\n\n## 샘플3\n주제: 건강한 생활 습관\n\n자기평가와 개선 과정을 포함하여 최종 답변을 작성하시오.\n\n\n\nMulti-Agent Prompt (다중 에이전트 협업)#\n\n * 여러 전문가(AI 역할)가 서로 다른 관점에서 의견을 제시한 후, 종합 결론 도출\n\n## 샘플1\n주제: 온라인 수업의 장단점\n\n- 교육 전문가 의견\n- 학생 의견\n- 학부모 의견\n\n각각 작성한 후, 종합 결론을 도출하시오.\n\n## 샘플2\n문제: 교내 휴대폰 사용 금지\n\n- 교사 관점\n- 학생 관점\n- 심리학자 관점\n\n→ 최종 정책 제안 작성\n\n## 샘플3\n과제: 미래 직업 선택 조언\n\n- 진로 상담가\n- 기술 전문가\n- 경제학자\n\n→ 3가지 관점을 종합하여 조언 제시\n\n\n\nPrompt Chaining (프롬프트 체이닝)#\n\n * 하나의 큰 문제를 여러 개의 작은 프롬프트로 나눠 순서대로 해결하는 방식\n\n## 샘플1\n1단계: 학교에서 발생하는 문제를 3가지 나열하시오.\n2단계: 각 문제의 원인을 설명하시오.\n3단계: 해결 방안을 하나씩 제시하시오.\n\n## 샘플2\n1단계: 인공지능의 활용 분야를 3가지 적으시오.\n2단계: 각 분야의 장점을 설명하시오.\n3단계: 가장 유망한 분야를 하나 선택하고 이유를 쓰시오.\n\n## 샘플3\n1단계: 건강을 해치는 습관 3가지를 나열하시오.\n2단계: 해당 습관의 문제점을 설명하시오.\n3단계: 바꿀 수 있는 실천 계획을 작성하시오.\n\n\n\nRetrieval-Augmented Prompting (RAG 스타일)#\n\n * 주어진 자료(정보)를 바탕으로만 답을 생성하는 방식\n\n## 샘플1\n[자료]\n\"물은 인간 신체의 약 70%를 차지한다.\"\n\n질문: 위 자료를 근거로 충분한 수분 섭취가 중요한 이유를 설명하시오.\n\n## 샘플2\n[자료]\n\"숲은 공기를 정화하고 생태계를 보호한다.\"\n\n질문: 위 정보를 활용해 숲을 보호해야 하는 이유를 작성하시오.\n\n## 샘플3\n[자료]\n\"수면은 기억력 향상과 면역력에 도움을 준다.\"\n\n질문: 위 내용을 바탕으로 수면의 중요성을 설명하시오.\n\n\n\nConstraint-Based Prompting (제약 조건 기반)#\n\n * 반드시 지켜야 할 조건을 주고 답을 생성하게 하는 방식\n\n## 샘플1\n주제: 환경 보호\n조건:\n- 3문장 이내\n- '지구' 단어 포함\n- 초등학생이 이해할 수 있도록 작성\n\n## 샘플2\n주제: 인공지능\n조건:\n- 60자 이내\n- 비유 1개 포함\n\n## 샘플3\n주제: 독서의 중요성\n조건:\n- 5가지 항목\n- 번호 형식 사용\n\n\n\nRole + Goal + Constraint (복합형 프롬프트)#\n\n * 역할 + 목표 + 조건을 동시에 주는 방식\n\n## 샘플1\n당신은 환경 과학자입니다.\n목표: 학생에게 환경 보호의 중요성을 알리기\n조건:\n- 100자 이내\n- 해결 방법 2가지 포함\n\n## 샘플2\n당신은 상담 교사입니다.\n목표: 학생의 자신감을 높이기\n조건:\n- 질문 2개 포함\n- 부드러운 말투 사용\n\n## 샘플3\n당신은 마케팅 전문가입니다.\n목표: 친환경 제품 홍보\n조건:\n- 슬로건 1개\n- 장점 3가지 포함\n\n\n\nSelf-Ask (자문자답)#\n\n * 스스로 질문하고 답하여 결론을 도출하는 방식\n\n## 샘플1\n주제: 운동의 필요성\n\n1. 스스로 질문 3개 만들기\n2. 각 질문에 답하기\n3. 최종 결론 작성\n\n## 샘플2\n주제: 시간 관리\n\n- 스스로 질문 → 대답 → 정리하시오.\n\n## 샘플3\n주제: 스마트폰 사용\n\n- 왜 문제가 되는가?\n- 어떻게 줄일 수 있는가?\n- 최종 요약 작성\n\n\n\nContrastive Prompting (비교 대조)#\n\n * 두 개 이상의 개념을 비교하고 결론을 내리는 방식\n\n## 샘플1\n온라인 수업과 오프라인 수업을 비교하고\n더 효과적인 방식을 선택하여 이유를 설명하시오.\n\n## 샘플2\n전자책과 종이책의 장단점을 비교하시오.\n\n## 샘플3\n팀 활동과 개인 활동을 비교하고\n자신에게 맞는 방식을 선택하시오.\n\n\n\nPersona Switching (인물 전환)#\n\n * 여러 인물의 관점에서 동일한 주제를 분석하는 방식\n\n## 샘플1\n\"시험\"에 대해\n- 학생\n- 부모\n- 교사\n입장에서 각각 한 문장씩 작성하시오.\n\n## 샘플2\n\"환경 문제\"를\n- 과학자\n- 회사원\n- 청소년\n관점에서 설명하시오.\n\n## 샘플3\n\"인공지능\"을\n- 개발자\n- 예술가\n- 중학생\n입장에서 설명하시오.\n\n\n\nReverse Prompting (역프롬프팅)#\n\n * 답을 보고 질문을 역으로 만들어내는 방식\n\n## 샘플1\n답: \"그는 매일 1시간씩 운동을 한다.\"\n→ 이 답이 나오도록 질문을 만드시오.\n\n## 샘플2\n답: \"이 기술은 우리의 생활을 더욱 편리하게 만든다.\"\n→ 알맞은 질문을 작성하시오.\n\n## 샘플3\n답: \"그 문제의 핵심은 소통의 부족이다.\"\n→ 어떤 질문에서 나온 답인지 작성하시오.\n\n\n참고#\n\n * https://snackprompt.com/\n * https://github.com/langgptai/LangGPT?tab=readme-ov-file\n * https://langgptai.feishu.cn/wiki/RXdbwRyASiShtDky381ciwFEnpe\n * https://www.aishort.top/\n * https://prompts.chat/","routePath":"/artificialIntelligence/31-PromptEngineering-sample","lang":"","toc":[{"text":"Zero-shot","id":"zero-shot","depth":3,"charIndex":3},{"text":"Few-shot","id":"few-shot","depth":3,"charIndex":266},{"text":"Chain-of-Thought (CoT)","id":"chain-of-thought-cot","depth":3,"charIndex":551},{"text":"Self-Consistency Prompting","id":"self-consistency-prompting","depth":3,"charIndex":854},{"text":"Generated Knowledge Prompting","id":"generated-knowledge-prompting","depth":3,"charIndex":1214},{"text":"Role Prompting","id":"role-prompting","depth":3,"charIndex":1565},{"text":"Instruction Prompting","id":"instruction-prompting","depth":3,"charIndex":1791},{"text":"Tree-of-Thought (ToT) Prompting","id":"tree-of-thought-tot-prompting","depth":3,"charIndex":2066},{"text":"Meta-Prompting","id":"meta-prompting","depth":3,"charIndex":2492},{"text":"ReAct Prompting (Reason + Act)","id":"react-prompting-reason--act","depth":3,"charIndex":2829},{"text":"Reflexion 프롬프팅 (반성·개선 기반)","id":"reflexion-프롬프팅-반성개선-기반","depth":3,"charIndex":3252},{"text":"Multi-Agent Prompt (다중 에이전트 협업)","id":"multi-agent-prompt-다중-에이전트-협업","depth":3,"charIndex":3570},{"text":"Prompt Chaining (프롬프트 체이닝)","id":"prompt-chaining-프롬프트-체이닝","depth":3,"charIndex":3874},{"text":"Retrieval-Augmented Prompting (RAG 스타일)","id":"retrieval-augmented-prompting-rag-스타일","depth":3,"charIndex":4211},{"text":"Constraint-Based Prompting (제약 조건 기반)","id":"constraint-based-prompting-제약-조건-기반","depth":3,"charIndex":4514},{"text":"Role + Goal + Constraint (복합형 프롬프트)","id":"role--goal--constraint-복합형-프롬프트","depth":3,"charIndex":4741},{"text":"Self-Ask (자문자답)","id":"self-ask-자문자답","depth":3,"charIndex":5016},{"text":"Contrastive Prompting (비교 대조)","id":"contrastive-prompting-비교-대조","depth":3,"charIndex":5231},{"text":"Persona Switching (인물 전환)","id":"persona-switching-인물-전환","depth":3,"charIndex":5429},{"text":"Reverse Prompting (역프롬프팅)","id":"reverse-prompting-역프롬프팅","depth":3,"charIndex":5637}],"frontmatter":{},"version":""},{"title":"Prompt Engineering 샘플 모음","content":"#\n\n\n프롬프트 어떻게 만들어야 할까?#\n\n * AI에게 상황 설명을 충분히 제공해야 합니다.\n * 명확한 목표를 설정해야 합니다.\n * 결과물의 형식을 알려줘야 합니다.\n * 프롬프트 템플릿을 활용해서 일관성을 유지해야 합니다.\n * 프롬프트를 코드처럼 구조화 하는 방법도 있습니다.\n   * https://medium.com/@fullstackciso/prompts-as-code-is-this-the-future-of-pro\n     mpting-aac7fadf69cc\n\n\nRAG 프롬프트#\n\n### 사용자 프롬프트\n{{사용자 질문}}\n\n### 관련 참고자료\n{{검색된 텍스트}}\n\n### 응답 지침\n1. 제공된 참고자료를 근거로 사용자 질의에 대해 종합적이고 정확하며 일관성 있는 답변을 제공하세요.\n2. 검색된 참고자료가 충분하다면, 정확하고 관련성 있는 정보를 제공하는 데 집중하세요.\n3. 검색된 참고자료가 불충분한 경우에는 부족한 부분을 명시하고 추가 정보를 얻을 수 있는 잠재적 출처나 단 계를 제안하세요 .\n4. 근거 없는 정보나 추측은 답변에 포함하지 마세요.\n\n\n\n대화 컨텍스트 요약 프롬프트#\n\n# 🧾 대화 컨텍스트 인수인계 요약 요청\n\n## [상황 설명 및 목적]\n\n현재 대화는 LLM의 컨텍스트 한도에 도달했으므로, 이 세션에서는 추가 논의가 어려운 상태입니다.  \n따라서 지금까지의 대화를 새로운 세션에서 원활히 이어가기 위해, 지금까지의 모든 대화 내용을 빠짐없이 정리한 상세 요약본이 필요합니다.\n\n이 요약문은 단순 요약이 아니라 **전문가가 다른 전문가에게 맥락을 인수인계하는 문서**처럼 작성해야 합니다.  \n새로운 LLM 인스턴스가 이 문서만 보고도 즉시 논의를 이어갈 수 있어야 합니다.\n\n---\n\n## [작성 원칙]\n\n- 정보 누락 없이 최대한 자세하게 작성합니다.\n- 사실 중심으로 작성하며, 추측이나 과도한 해석은 피합니다.\n- 아래 구조와 Markdown heading을 반드시 따릅니다.\n- 중요 의사결정, 요구사항 변경, 제약조건은 반드시 포함합니다.\n- 잡담이나 반복 설명은 필요 시 축약할 수 있습니다.\n- 한국어로 작성합니다.\n\n---\n\n## [요약문 구조]\n\n### 1. 대화의 시작과 목표\n\n- 이 대화가 어떤 질문이나 목표에서 시작되었는지\n- 초기 전제조건, 제한사항, 가정\n- 사용자가 최종적으로 기대한 결과물\n\n---\n\n### 2. 주요 대화 흐름 및 상호작용\n\n- 핵심 질문과 답변 요약\n- 논의 중 방향 변화 또는 의사결정 발생 지점\n- 실패/보류된 시도\n- 사용자가 제공한 정보, 피드백, 추가 요청\n\n---\n\n### 3. 사용자 요구 vs LLM 제안 vs 확정 결정\n\n반드시 아래를 구분해서 정리:\n\n- **사용자 요구사항**\n- **LLM의 제안/아이디어**\n- **최종적으로 합의되거나 확정된 내용**\n\n---\n\n### 4. 지금까지 도달한 결론\n\n- 생성된 결과물 또는 합의된 내용\n- 해결된 문제 vs 아직 해결되지 않은 문제\n- 잠정적으로 정리된 아이디어, 초안, 코드 등\n\n---\n\n### 5. 미완료 항목 및 열린 질문 (Open Issues)\n\n- 아직 답변되지 않은 질문\n- 추가 검토가 필요한 선택지\n- 다음 세션에서 반드시 이어서 다뤄야 할 논점\n\n---\n\n### 6. 마지막 상태 및 다음 단계\n\n- 마지막 사용자 요청\n- 마지막 LLM 응답 내용\n- 논의 예정이었던 다음 작업 또는 주제\n- (선택) LLM이 준비 중이던 분석이나 응답\n\n---\n\n### 7. 사용자 선호 및 대화 스타일 (Conversation DNA)\n\n- 사용자가 선호하는 답변 스타일\n- 반복적으로 강조한 요구사항\n- 피해야 할 방식이나 주의점\n\n---\n\n### 8. 초압축 요약 (Ultra-Compact Summary)\n\n- 10줄 이하로 핵심만 요약\n- 다음 LLM이 바로 이어서 답변하기 위한 핵심 맥락만 포함\n\n---\n\n### 9. 다음 LLM이 이어서 시작할 추천 첫 문장 (선택)\n\n- 자연스럽게 논의를 이어가기 위한 시작 문장 1~2개\n","routePath":"/artificialIntelligence/32-PromptEngineering-sample2","lang":"","toc":[{"text":"프롬프트 어떻게 만들어야 할까?","id":"프롬프트-어떻게-만들어야-할까","depth":3,"charIndex":3},{"text":"RAG 프롬프트","id":"rag-프롬프트","depth":3,"charIndex":267},{"text":"대화 컨텍스트 요약 프롬프트","id":"대화-컨텍스트-요약-프롬프트","depth":3,"charIndex":551}],"frontmatter":{},"version":""},{"title":"Retrieval Augmented Generation","content":"#\n\n\nRetrieval Augmented Generation#\n\nRetrieval은 외부 지식 소스에서 관련 정보를 검색하여 LLM에 제공하는 컴포넌트입니다. 이를 통해 모델이 최신 정보에 접근하거나 도메인\n특화 지식을 활용할 수 있습니다. LLM은 학습동결 모델이기 때문에 사전학습된 지식 외의 정보를 제공하려면 Retrieval기능이 필수적입니다.\n또한 환각 문제를 완화하는데도 도움이 됩니다. RAG(Retrieval Augmented Generation)시스템의 핵심 구성 요소입니다.\n\n * 줄여서 얘기하면 검색기술 + LLM 제시어\n\n\n\nRetrieval Augmented Generation 흐름#\n\n\n\n 1. 문서 파싱\n 2. 텍스트 분할\n 3. 백터화(EmbeddingModel사용)\n 4. 벡터 DB 저장\n 5. 질문\n 6. Retrieval\n    * 검색알고리즘 사용(Cosine Similarity, Dot Product, Euclidean Distance 등)\n 7. 증강: 사용자 질문과 함께 검색된 내용을 LLM에 전달\n 8. 응답 생성\n\nRetrieval Augmented Generation 장점#\n\n * 실시간 업데이트\n * 비용 대비 효율성\n * 출처를 제공하는 응답이여서 믿음직함\n * 안전하고 제어 가능: 제공한 문서에 기반한 응답만 생성 가능하게 제어 가능\n\nRetrieval Augmented Generation 단점#\n\n * 검색품질의 한계\n * 시스템 복잡도 증가\n * context가 영향을 받음\n * 제공한 문서의 영향도가 큼\n\n\nAdvanced RAG#\n\n기본 RAG 방식에서 검색전, 검색중, 검색후 과정이 추가됨\n\n\n\n * Pre-Retrieval\n   * Query Rewriting\n   * HyDE\n * Retrieval\n   * 검색알고리즘 혼합사용(Cosine Similarity, Dot Product, Euclidean Distance 등)\n * Post-Retrieval\n   * Rerank(RAG-Fusion, Cohere)\n   * Filter\n   * Context 최적화\n\nRAG-Fusion#\n\n * 여러 쿼리 생성: 사용자의 원래 질문을 대규모 언어 모델(LLM)이 여러 가지 다른 관점이나 표현을 가진 하위 질문들로 다시 작성합니다.\n   예를 들어, \"MEMS 마이크로폰\"에 대해 물으면 \"MEMS 마이크로폰이란 무엇인가요?\", \"MEMS 마이크로폰의 장점은 무엇인가요?\"와\n   같은 질문을 생성할 수 있습니다.\n * 독립적인 검색: 생성된 각각의 하위 질문을 사용하여 문서 데이터베이스에서 관련 문서를 독립적으로 검색합니다. 이 과정에서 벡터 검색,\n   키워드 검색 등 다양한 검색 전략이 활용될 수 있습니다.\n * 결과 융합 및 재순위(Reranking): 각 검색 결과 목록을 RRF(Reciprocal Rank Fusion)라는 알고리즘을 사용하여\n   단일의 통합된 순위 목록으로 병합하고 재정렬합니다. RRF는 순위가 높은 문서에 더 높은 점수를 부여하여 가장 관련성이 높은 문서가 상단에\n   오도록 보장합니다.\n * 최종 답변 생성: 이렇게 융합 및 재순위된 문서를 원래 질문과 함께 LLM에 입력하여 최종적이고 일관성 있는 답변을 생성합니다.\n\nHyDE - 가상 문서 임베딩(Hypothetical Document Embeddings)#\n\n * 장점\n   * 검색 품질 향상: 일반 RAG는 질문 그대로 벡터화해 검색하지만, 질문이 짧거나 모호한 경우 검색 품질이 떨어질 수 있습니다.\n     HyDE는 LLM이 질문을 한 번 ‘확장’하여 더 풍부한 정보를 가진 문서를 만들어 주기 때문에 관련성이 높은 문서를 훨씬 잘\n     찾아냅니다.\n   * 희소하거나 구조화되지 않은 데이터에서 강함: 정확한 문장이 데이터베이스에 없어도 가상의 문서가 ‘중간 브리지(bridge)’ 역할을\n     하여 비슷한 주제의 문서를 더 잘 매칭할 수 있습니다.\n   * 쿼리 확장 효과(Query Expansion): 질문자가 떠올리지 못한 개념들을 LLM이 가상 문서에서 미리 언급해 줌으로써 검색\n     정보량과 정확도가 증가합니다.\n   * 도메인 지식이 부족한 사용자에게 유리: 사용자가 전문 용어나 정확한 키워드를 모르는 경우에도 HyDE가 질문을 보완해 주어 전문지식\n     기반 문서를 잘 검색할 수 있게 해줍니다.\n\nRerank(Model, library)#\n\nRerank이 필요한 상황#\n\n * 검색된 문서의 양이 많아서 프롬프트에 포함하기 어려운 경우\n * 검색된 문서의 품질이 낮아서 LLM이 혼란스러워하는 경우\n * 사용자 선호도를 반영해야 하는 경우\n * 검색된 문서의 최신성이나 신뢰성을 고려해야 하는 경우\n\nRerank 모델과 라이브러리#\n\n * Cohere Rerank v3.5\n * bge-reranker-large / base\n * Voyage rerank\n * OpenAI의 Rerank 기능 (latest)\n * https://ollama.com/search?q=rerank\n\nContext Compression#\n\n * (기법) LLM Summarization: 문서 길이를 줄이면서 핵심만 유지\n * (기법) Extractive Compression: 원문에서 쓸모없는 문장 제거\n * (기법) Sentence-level similarity filtering (문장 단위 relevance scoring)\n * (도구) LangChain의 Contextual Compression Retriever\n * (도구) LlamaIndex의 SentenceWindowRetriever, ContextFilter\n\nContext Filtering#\n\n * (기법) 질문과 관련성 낮은 문서 삭제\n * (기법) 중복 문서 제거\n * (기법) 동일 문장의 paraphrase 제거\n * (기법) 너무 오래된 정보 제거\n * (기법) metadata 기반 필터링 (날짜/카테고리)\n\nChunk Merging & Re-chunking#\n\n * (도구) LlamaIndex AutoMergingRetriever\n * (도구) LangChain ParentDocumentRetriever\n\nContext Ordering#\n\n * 가장 관련성 높은 순서\n * 출처별 그룹화\n * 최신 정보 먼저\n * 짧고 강한 문헌 먼저\n * 최신 → 근접 → 포괄 순\n\nRAGAS - Retrieval-Augmented Generation Assessment#\n\n * 평가 지표\n   * ContextRelevance: context 관련성\n   * ContextEntityRecall: context 유실여부\n   * ContextPrecision: context 정확성\n   * Faithfulness: 답변정확도, context에 근거해서 답변을 하는지.\n   * ResponseRelevance: 결과 관련성\n   * AnswerCorrectness: 답변 정확성\n   * SemanticSimilarity: 생성된 정답과 실제 정답의 의미적 유사도를 평가\n   * 기타 등등...\n\n\nModular RAG#\n\nRAG의 모든 단계를 모듈화하여, 교체·조합·최적화가 가능한 구조적인 RAG 시스템\n\n\n\n\nPageIndex#\n\nPageIndex는 인간 전문가가 복잡한 문서를 탐색하고 지식을 추출하는 방식을 시뮬레이션하는 추론 기반 검색 시스템입니다. 문서를 계층적 트리\n구조 색인으로 변환하고 LLM이 해당 구조에 대한 추론을 통해 관련 정보를 검색할 수 있도록 합니다.\n\nYou are given a list of documents with their IDs, file names, and descriptions. Your task is to select documents that may contain information relevant to answering the user query.\n\nQuery: {query}\n\nDocuments: [\n    {\n        \"doc_id\": \"xxx\",\n        \"doc_name\": \"xxx\",\n        \"doc_description\": \"xxx\"\n    }\n]\n\nResponse Format:\n{{\n    \"thinking\": \"<Your reasoning for document selection>\",\n    \"answer\": <Python list of relevant doc_ids>, e.g. ['doc_id1', 'doc_id2']. Return [] if no documents are relevant.\n}}\n\nReturn only the JSON structure, with no additional output.\n\n\n\n참고#\n\n * https://www.llamaindex.ai/llamaparse\n * https://zhuanlan.zhihu.com/p/722159912\n * https://rabiloo.com/blog/the-3-types-of-rag-models-naive-rag-modular-rag-and-\n   advanced-rag\n * https://zhuanlan.zhihu.com/p/1924487055976670911\n * https://www.zhihu.com/search?type=content&q=rag 如何评估\n * https://zhuanlan.zhihu.com/p/1975321777342260763\n * https://zhuanlan.zhihu.com/p/1956865613138986501\n * https://zhuanlan.zhihu.com/p/1920459703399462751\n * https://zhuanlan.zhihu.com/p/675509396\n * https://zhuanlan.zhihu.com/p/27274703035","routePath":"/artificialIntelligence/40-RetrievalAugmentedGeneration","lang":"","toc":[{"text":"Retrieval Augmented Generation","id":"retrieval-augmented-generation-1","depth":3,"charIndex":-1},{"text":"Retrieval Augmented Generation 흐름","id":"retrieval-augmented-generation-흐름","depth":4,"charIndex":307},{"text":"Retrieval Augmented Generation 장점","id":"retrieval-augmented-generation-장점","depth":4,"charIndex":542},{"text":"Retrieval Augmented Generation 단점","id":"retrieval-augmented-generation-단점","depth":4,"charIndex":672},{"text":"Advanced RAG","id":"advanced-rag","depth":3,"charIndex":773},{"text":"RAG-Fusion","id":"rag-fusion","depth":4,"charIndex":1037},{"text":"HyDE - 가상 문서 임베딩(Hypothetical Document Embeddings)","id":"hyde---가상-문서-임베딩hypothetical-document-embeddings","depth":4,"charIndex":1596},{"text":"Rerank(Model, library)","id":"rerankmodel-library","depth":4,"charIndex":2143},{"text":"Context Compression","id":"context-compression","depth":4,"charIndex":2469},{"text":"Context Filtering","id":"context-filtering","depth":4,"charIndex":2767},{"text":"Chunk Merging & Re-chunking","id":"chunk-merging--re-chunking","depth":4,"charIndex":2914},{"text":"Context Ordering","id":"context-ordering","depth":4,"charIndex":3027},{"text":"RAGAS - Retrieval-Augmented Generation Assessment","id":"ragas---retrieval-augmented-generation-assessment","depth":4,"charIndex":3119},{"text":"Modular RAG","id":"modular-rag","depth":3,"charIndex":3468},{"text":"PageIndex","id":"pageindex","depth":3,"charIndex":3533},{"text":"참고","id":"참고","depth":3,"charIndex":4257}],"frontmatter":{},"version":""},{"title":"Function Calling","content":"#\n\n...","routePath":"/artificialIntelligence/50-FunctionCalling","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"Fine-tuning 微调","content":"#\n\n\n소개#\n\n파인튜닝은 특정 작업이나 도메인에 높은 적합성을 확보하기 위해, 이미 훈련된 대규모 언어 모델에 특정 데이터셋을 사용하여 추가적인 학습을\n수행하는 작업을 말합니다. 미세 조정은 표면적으로 모델 학습에 사용되는 기술이지만 일반적으로 \"학습\"이라고 하는 것과는 다른 프로세스입니다.\n명확성을 위해 데이터 과학자는 일반적으로 후자를 이러한 맥락에서 사전 학습이라고 부릅니다.\n\n\n방법#\n\nFull Fine-tuning#\n\n전체 파인튜닝은 모델의 모든 매개변수를 업데이트하여 모델 전체를 새로운 데이터에 맞춰 재학습하는 방식입니다. 일반적으로 작업과 기존 학습된\n모델의 차이가 크거나 모델의 높은 적응성이 필요할 때 사용합니다. 많은 컴퓨팅 자원과 시간이 필요하지만 그만큼 성능 향상이 큽니다.\n\nPartial Fine-Tuning / Layer Freezing#\n\n모델 전체를 다 학습시키지 않고, 특정 레이어만 학습시키는 방식입니다. 미세 조정 중 특정 레이어는 업데이트하지 못하도록 “얼려” 두는\n기술입니다.\n\nLayer Freezing는 “여기 레이어는 학습하지 마라”라고 고정시키는 기술 Partial Fine-Tuning “일부 레이어만\n학습시키겠다”라는 전략\n\nParameter-Efficient Fine-Tuning(PEFT)#\n\n * Prompt Tuning: 입력 또는 학습 데이터에 맞춤형 프롬프트를 주입하여 프리픽스 튜닝을 간소화하고 모델을 학습시킵니다. 하드\n   프롬프트는 수동으로 생성되는 것이고, 소프트 프롬프트는 기본 모델에서 지식을 추출하여 AI가 생성한 숫자 문자열입니다.\n * P-Tuning: 수동으로 생성한 프롬프트를 사용하는 대신 자동화된 프롬프트 훈련 및 생성을 도입하여 시간이 지남에 따라 더욱 영향력 있는\n   훈련 프롬프트를 생성합니다.\n * Prefix-Tuning: 모든 매개변수를 고정된 상태로 유지하면서 접두사라고 하는 작업 특이적 연속 벡터를 각 트랜스포머 계층에\n   추가합니다. 이렇게 하면 접두사 조정 모델은 완전히 미세 조정된 비슷한 성능의 모델보다 매개변수를 천 배 이상 적게 저장합니다.\n * LoRA: 트윈 저순위 분해 행렬을 사용하여 모델 가중치를 최소화하고 훈련 가능한 매개변수의 하위 집합을 더 줄입니다.\n * QLoRA: 사전 학습된 각 매개변수의 가중치를 일반적인 32비트 가중치에서 단 4비트로 정량화 또는 표준화하는 LoRA의 확장\n   버전입니다. 따라서 QLoRA는 메모리를 상당히 절약하며, 단 하나의 GPU에서 LLM을 실행할 수 있습니다.\n * Adapter Tuning: 모델의 각 트랜스포머 계층에 훈련 가능한 작업별 매개변수 몇 개를 삽입하는 작은 추가 기능입니다.\n\nSupervised Fine-Tuning, SFT#\n\n??\n\nUnsupervised Fine-Tuning, UFT#\n\n??\n\n\n장점#\n\n * 일반 프롬프트보다 더 좋은 효과를 얻을수 있다.\n * 토큰사용도 줄일수 있다.\n * 속도가 빠르다\n\n\n단점#\n\n * 인력비용\n * 복잡한 기술 역량\n * 난이도가 높다\n\n\n튜닝#\n\n 1. 데이터셋 준비: 목표 작업에 필요한 입력(프롬프트)과 원하는 출력값을 매핑하는 레이블이 지정된 데이터셋을 확보하거나 생성해야 합니다.\n    요약과 같은 텍스트 생성 작업의 경우, 입력 텍스트와 요약된 출력값 쌍이 필요합니다.\n 2. 데이터셋 분할: 모범 사례에 따라 레이블이 지정된 데이터셋을 학습, 검증 및 테스트 세트로 분할합니다. 이렇게 하면 모델 학습,\n    하이퍼파라미터 튜닝 및 최종 평가를 위한 데이터가 분리됩니다.\n 3. 하이퍼파라미터 튜닝: 학습률, 배치 크기, 학습 스케줄과 같은 매개변수를 데이터에 가장 효과적인 방식으로 조정해야 합니다. 일반적으로 이\n    과정에는 소규모 검증 세트가 사용됩니다.\n 4. 모델 학습: 튜닝된 하이퍼파라미터를 사용하여 전체 학습 세트에서 모델 성능이 검증 세트에서 더 이상 향상되지 않을 때까지(조기 종료)\n    미세 조정 최적화 프로세스를 실행합니다.\n 5. 평가: 미세 조정된 모델의 성능을 실제 사용 사례에 대한 실제 예제로 구성된 별도의 테스트 세트에서 평가하여 실제 효율성을 추정합니다.\n 6. 배포 및 모니터링: 만족스러운 결과가 나오면, 미세 조정된 모델을 새로운 입력값에 대한 추론에 배포할 수 있습니다. 개념의\n    변화(concept drift)를 파악하기 위해 시간이 지남에 따라 모델의 성능과 정확도를 모니터링하는 것이 중요합니다.\n\n\n데이터셋 거버넌스 구축#\n\n 1. 요구사항 분석시 데이터에 대해서도 체크\n    \n    * 데이터의 종류\n    * 데이터의 수량\n    * 정답의 내용과 형식\n\n 2. 기술팀과 기획팀의 협업\n    \n    * 기획: 구체적인 요구사항과 사용자 시나리오를 제공\n    * 기술: 실현 가능성을 검토하고 필요한 데이터의 특성을 분석\n    * 데이터셋 구축 가이드라인을 작성.\n\n 3. 데이터셋 정의\n    \n    * 입력 데이터의 형식과 특성\n    * 출력 데이터의 형식과 요구사항\n    * 중간 처리 과정에서 필요한 데이터 형식\n\n 4. 데이터 수집과 애플리케이션 설계/구현을 반복하면서 시스템을 개선\n\n\n데이터 증강 CRAFT 방법론#\n\nCRAFT(Corpus Retrival and Augmentation for Fine-Tuning)는 소량의 데이만으로 특화된 대규모 데이터셋을\n합성하고 증강하는 기술입니다.(LLM을 활용하여 데이터셋을 생성하는 방법론) 핵심은 소수의 예시를 기반으로 대규모 데이터셋을 생성하는 것입니다.\nCRAFT는 다음과 같은 단계를 포함합니다:\n\n * 태스크의 기준을 명확히 정의\n * 임베딩 데이터 베이스 구축\n * 관련 문서 검색\n * LLM이 사용할 수 있는 형식으로 구조화\n * 합성 샘플 생성\n\n\n기타 용어#\n\n * Fuzzy Matching: 유사한 샘플을 억제하는 기술\n * Data Deduplication: 중복된 샘플을 제거하는 기술\n * Data Filtering: 품질이 낮은 샘플을 제거하는 기술\n\n\n풀파인튜닝 vs LoRA vs QLoRA#\n\n풀 파인튜닝#\n\n * 훈련 파라미터수: 100%, 모델의 전체 파라 미터를 학습시킨다\n * 추가 모델 저장 공간: 크다(모델 크기의 4~6배가 더 필요하다)\n * 메모리 요구사항: 매우 크다(예: 70B 모델 기준 최대 1TB)\n * 추론 속도 영향: 없다\n * 장점\n   * 모든 파라미터가 조정 가능하므로 높은 유연 성을 가지고 있다\n   * 최고 성능 잠재력이 가장 크다\n * 단점\n   * 자원을 많이 요구한 다(일반 개발자는 접 근이 어려움).\n   * 과적합 위험이 있고 학습속도가 느리다.\n\nLoRA#\n\n * 훈련 파라미터수: 1% 미만만 학습시킨다(랭크 (rank) 값에 비례)\n * 추가 모델 저장 공간: 매우 작다(수 MB 내외의 LORA 가중치만 저장)\n * 메모리 요구사항: 중간 정도의 크기다(원본 모 델 + LORA 모듈)\n * 추론 속도 영향: 없다\n * 장점\n   * 매우 가벼운 학습(자원 절약)이다.\n   * 풀 파인튜닝에 준하는 성 능을 유지한다.\n   * 파라미터 수가 작으므로 추론 시 부담 적다.\n * 단점\n   * 베이스 모델을 필요로 한 다(배포 시 LORA 모듈과 병합하거나 병렬 사용).\n   * 랭크(r) 등 하이퍼파라미 터 조정이 필요하다.\n   * 랭크가 너무 낮으면 성능 이 저하된다.\n\nQLoRA#\n\n * 훈련 파라미터수: 1% 미만만 학습시킨다 (LORA와 동일, 랭크(rank)값에 비례)\n * 추가 모델 저장 공간: 매우 작다(LORA 부분만 추가 저장, 베이스는 공유)\n * 메모리 요구사항: 매우 작다(4비트 양자화 모델 + LORA 모듈)\n * 추론 속도 영향: 거의 없다(양자화된 모델 속도에 좌우, 행렬 연산 병합 시 동일)\n * 장점\n   * 자원 사용을 극소화한 다(대형 모델도 단일 GPU로 파인튜닝 가능).\n   * 성능 손실이 거의 없다.\n   * LORA 장점을 모두 포 함한다.\n * 단점\n   * 양자화 지원 라이브러 리가 필요하다.\n   * 4비트 연산으로 구현 복잡도가 증가한다.\n   * 일부 정밀도가 저하되 어 성능의 차이가 날 수 있다.\n\n\n데이터셋 참고#\n\n * https://commoncrawl.org/\n * https://www.microsoft.com/en-us/research/project/microsoft-research-open-data\n   /\n * https://www.kaggle.com/datasets\n * https://huggingface.co/datasets\n * https://data.go.kr\n * https://aihub.or.kr","routePath":"/artificialIntelligence/60-FineTuning","lang":"","toc":[{"text":"소개","id":"소개","depth":3,"charIndex":3},{"text":"방법","id":"방법","depth":3,"charIndex":217},{"text":"장점","id":"장점","depth":3,"charIndex":1399},{"text":"단점","id":"단점","depth":3,"charIndex":1464},{"text":"튜닝","id":"튜닝","depth":3,"charIndex":1503},{"text":"데이터셋 거버넌스 구축","id":"데이터셋-거버넌스-구축","depth":3,"charIndex":2195},{"text":"데이터 증강 CRAFT 방법론","id":"데이터-증강-craft-방법론","depth":3,"charIndex":2540},{"text":"기타 용어","id":"기타-용어","depth":3,"charIndex":2836},{"text":"풀파인튜닝 vs LoRA vs QLoRA","id":"풀파인튜닝-vs-lora-vs-qlora","depth":3,"charIndex":2958},{"text":"데이터셋 참고","id":"데이터셋-참고","depth":3,"charIndex":4010}],"frontmatter":{},"version":""},{"title":"Fine-tuning 예제","content":"#\n\nopenapi튜닝 샘플#\n\n{\n  \"messages\": [\n    { \"role\": \"system\", \"content\": \"<放入系统讯息>\" },\n    { \"role\": \"user\", \"content\": \"<放入使用者的问题>\" },\n    { \"role\": \"assistant\", \"content\": \"<放入理想的回答>.\" }\n  ]\n}\n\n\n\n데이터셋#\n\n// lora/data/train.jsonl\n{\n  \"messages\": [\n    { \"role\": \"user\", \"content\": \"How many districts and townships does the market cover\" },\n    { \"role\": \"assistant\", \"content\": \"The market covers **4 districts (가도)** and **8 townships (향)**.\" }\n  ]\n}\n\n\n\n설치#\n\npip install -U huggingface_hub\nexport HF_ENDPOINT=https://hf-mirror.com\nhf download Qwen/Qwen2.5-0.5B-Instruct --local-dir qwen2.5-0.5B\n\ngit clone git@github.com:ml-explore/mlx-examples.git\n\npip install mlx-lm\npip install transformers\npip install torch\npip install numpy\n\n## 모델 트레이닝\nmlx_lm.lora --model /Users/julong/Documents/model/qwen2.5-0.5B --train --data ./data\n\n## 모델 합병\nmlx_lm.fuse --model /Users/julong/Documents/model/qwen2.5-0.5B --adapter-path adapters --save-path /Users/julong/Documents/model/qwen2.5-0.5B-julong\n\n## 테스트 원본\nmlx_lm.generate --model /Users/julong/Documents/model/qwen2.5-0.5B --prompt \"고양이는 어떤 동물인가요?\"\n\n## 테스트 튜닝이후\nmlx_lm.generate --model /Users/julong/Documents/model/qwen2.5-0.5B-julong --prompt \"고양이는 어떤 동물인가요?\"\n\n## GGUF형식으로 변환 및\ngit clone https://github.com/ggerganov/llama.cpp\ncd llama.cpp\npip install -r requirements.txt\n./convert_hf_to_gguf.py --outtype f16 /Users/julong/Documents/model/qwen2.5-0.5B-julong --outfile /Users/julong/Documents/model/qwen2.5-0.5B-julong/qwen2.5-0.5B-julong.gguf\n\n## Ollama에 추가\necho 'FROM /Users/julong/Documents/model/qwen2.5-0.5B-julong/qwen2.5-0.5B-julong.gguf' > /Users/julong/Documents/model/qwen2.5-0.5B-julong/Modelfile\nollama create julong-model -f /Users/julong/Documents/model/qwen2.5-0.5B-julong/Modelfile\n","routePath":"/artificialIntelligence/61-FineTuning-sample","lang":"","toc":[{"text":"데이터셋","id":"데이터셋","depth":2,"charIndex":195},{"text":"설치","id":"설치","depth":2,"charIndex":453}],"frontmatter":{},"version":""},{"title":"Embedding","content":"#\n\n机器学习中Embedding是什么\n\n\n검색#\n\n * TF-IDF(Term Frequency-Inverse Document Frequency) 단어 빈도와 역 문서 빈도를 곱하여 특정 문서에서\n   단어의 중요도를 나타내는 통계적 측정 방법입니다.\n * BM25(Best Matching 25) 검색어와 문서 간의 관련성을 계산해 가장 적합한 문서를 찾아주는 검색 랭킹 알고리즘이다.\n\n참고: https://wikidocs.net/289869\n\n\nVector Database(벡터DB)#\n\n\nSparse(희소) Vector 와 Dense(밀집) Vector#\n\n글을 벡터DB에 저장할 때, 글 전체 를 임베딩하거나 주요 키워드만 뽑아 임베딩할 수 있습니다. 주요 키워드만 뽑아 서 변환하면 벡터가 표현할\n수 있는 차원 중 일부만 사용하게 되고, 나머지 많은 차원은 0으로 '비어' 있게 됩니다. 이를 희소 벡터라고 합니다. 반면 글 전체를 임 베딩\n벡터로 변환하면 거의 모든 차원을 사용하게 되는데, 이를 밀집 벡터라고 합니다.\n\n희소 벡터는 특정 키워드에 맞는 단어를 검색하는 데 적합한 구조이며, 밀집 벡 더는 콘텐츠 전체의 의미를 검색하는 데 적합한 구조입니다. 희소\n벡터의 장점은 차원 값 대부분이 0이라 압축하기 쉬워 메모리 효율이 좋다는 점입니다. 반면 밀 집 베터는 모든 차원의 값을 가지고 있어 의미를\n이해하기 쉽다는 장점이 있습니 다 다만 희소 벡터는 키워드만으로는 완전한 의미를 파악하기 어렵고, 밀집 벡터 는 모든 차원의 값을 저정하므로\n메모리 사용량이 높다는 단점이 있습니다. 희소 벡터는 BM25와 같은 키워드 검색에 주로 이용되고, 밀집 벡터는 코사인 유사도 계산을 통해\n의미적 유사성을 찾는 데 활용됩니다.\n\n\n벡터DB 검색 방법#\n\n * HNSW(Hierarchical Navigable Small World) 그래프 기반의 검색 알고리즘으로, 대규모 벡터 데이터베이스에서\n   빠르게 유사한 벡터를 찾는 데 사용됩니다. HNSW는 벡터 간의 유사성을 기반으로 그래프를 구성하여 검색 효율성을 높입니다.\n * IVF(Inverted File) 벡터를 여러 개의 클러스터로 나누고, 각 클러스터에 대한 인덱스를 생성하여 검색 효율성을 높이는\n   방법입니다. 검색 시에는 먼저 클러스터를 선택한 후 해당 클러스터 내에서 유사한 벡터를 찾습니다.\n * PQ(Product Quantization) 벡터를 여러 개의 하위 벡터로 분할하여 각 하위 벡터를 양자화하는 방법입니다. 이를 통해\n   벡터의 차원을 줄이고, 검색 시에는 양자화된 하위 벡터 간의 유사성을 계산하여 빠르게 유사한 벡터를 찾습니다.\n * LSH(Locality-Sensitive Hashing) 유사한 벡터가 동일한 해시 버킷에 매핑되도록 하는 해싱 방법입니다. 이를 통해\n   검색 시에는 동일한 해시 버킷에 있는 벡터들만 비교하여 유사한 벡터를 빠르게 찾을 수 있습니다.\n\n\n벡터DB#\n\n * FAISS(Facebook AI Similarity Search) Facebook에서 개발한 라이브러리로, 대규모 벡터 데이터베이스에서\n   유사한 벡터를 빠르게 검색할 수 있도록 다양한 알고리즘과 인덱싱 방법을 제공합니다. HNSW, IVF, PQ 등 다양한 검색 방법을\n   지원하며, GPU 가속을 통해 대규모 데이터에서도 효율적으로 검색할 수 있습니다.\n * Annoy(Approximate Nearest Neighbors Oh Yeah) Spotify에서 개발한 라이브러리로, 대규모 벡터\n   데이터베이스에서 유사한 벡터를 빠르게 검색할 수 있도록 다양한 알고리즘과 인덱싱 방법을 제공합니다. HNSW, IVF, PQ 등 다양한\n   검색 방법을 지원하며, 메모리 효율적인 인덱싱을 통해 대규모 데이터에서도 효율적으로 검색할 수 있습니다.\n * ScaNN(Scalable Nearest Neighbors) Google에서 개발한 라이브러리로, 대규모 벡터 데이터베이스에서 유사한\n   벡터를 빠르게 검색할 수 있도록 다양한 알고리즘과 인덱싱 방법을 제공합니다. HNSW, IVF, PQ 등 다양한 검색 방법을 지원하며,\n   GPU 가속을 통해 대규모 데이터에서도 효율적으로 검색할 수 있습니다.\n * NMSLIB(Non-Metric Space Library) 대규모 벡터 데이터베이스에서 유사한 벡터를 빠르게 검색할 수 있도록 다양한\n   알고리즘과 인덱싱 방법을 제공합니다. HNSW, IVF, PQ 등 다양한 검색 방법을 지원하며, 메모리 효율적인 인덱싱을 통해 대규모\n   데이터에서도 효율적으로 검색할 수 있습니다.\n * Milvus 대규모 벡터 데이터베이스에서 유사한 벡터를 빠르게 검색할 수 있도록 다양한 알고리즘과 인덱싱 방법을 제공합니다. HNSW,\n   IVF, PQ 등 다양한 검색 방법을 지원하며, GPU 가속을 통해 대규모 데이터에서도 효율적으로 검색할 수 있습니다.\n\n\n参考链接#\n\n * https://projector.tensorflow.org/","routePath":"/artificialIntelligence/70-Embedding","lang":"","toc":[{"text":"검색","id":"검색","depth":3,"charIndex":22},{"text":"Vector Database(벡터DB)","id":"vector-database벡터db","depth":2,"charIndex":250},{"text":"Sparse(희소) Vector 와 Dense(밀집) Vector","id":"sparse희소-vector-와-dense밀집-vector","depth":3,"charIndex":275},{"text":"벡터DB 검색 방법","id":"벡터db-검색-방법","depth":3,"charIndex":861},{"text":"벡터DB","id":"벡터db","depth":3,"charIndex":1441},{"text":"参考链接","id":"参考链接","depth":3,"charIndex":2406}],"frontmatter":{},"version":""},{"title":"Agent","content":"#\n\n\n소개#\n\nGoogle 이 《Agents》 whitepaper 에서정의정의한 바에 의하면.\n\n인공 지능(AI) 에이전트는 가용 도구를 사용해서 워크플로를 설계하고 작업을 자동으로 수행하는 시스템입니다. AI 에이전트는 자연어 처리 외에도\n의사 결정, 문제 해결, 외부 환경과의 상호 작용, 작업 실행 등 다양한 기능을 포괄할 수 있습니다.\n\n\n핵심원칙#\n\n 1. 인식. 이는 에이전트가 작동하는 공간을 의미합니다. 이는 도로, 창고 또는 집의 바닥과 같은 물리적 공간일 수 있습니다. 또는 웹사이트나\n    서버와 같은 디지털 공간일 수 있습니다. 에이전트는 센서를 통해 그들의 환경을 평가하고 인식합니다. 자율주행 자동차의 입력은 센서,\n    카메라, 레이더가 될 수 있습니다. 한편, 챗봇은 고객의 질문이나 피드백에서 입력을 받습니다.\n 2. 추론. 그러면 에이전트가 어떤 결정을 내려야 할지 결정할 수 있습니다. 에이전트는 지식 기반을 바탕으로 규칙 기반 시스템, 머신 러닝\n    모델 또는 다른 알고리즘을 사용하여 의사결정을 안내할 수 있습니다.\n 3. 목표 설정. AI는 사전 정의된 목표 또는 사용자 입력을 기반으로 목표를 설정합니다. 그런 다음 의사 결정 트리, 강화 학습 또는 기타\n    계획 알고리즘을 사용하여 이러한 목표를 달성하기 위한 전략을 개발합니다.\n 4. 결정. 지식 기반 에이전트는 메모리와 세계에 대한 이해를 바탕으로 결정을 내립니다. 그것은 사용자의 목표와 객체와 이벤트 간의 관계를\n    고려합니다.\n 5. 행동. 한 번 결정이 내려지면, 에이전트는 환경 내에서 행동합니다.\n 6. 학습. AI 에이전트를 단순한 AI 시스템과 구별하는 것은 그것이 학습하고, 세밀화하고, 그것의 결정 만들기를 향상시킬 수 있는\n    능력입니다. 시간이 지남에 따라 에이전트는 그 경험에서 배우고 더욱 능숙하고 최적화됩니다.\n\n\n구성요소#\n\n * 인식\n   * 시각적\n   * 청각적\n   * 텍스트\n   * 환경적\n   * 예측적\n * 추론\n   * 조건부 논리\n   * 휴리스틱\n   * ReAct(이유+행동)\n   * ReWOO(관찰 없이 추론하기 reasoning without observation)\n   * 자기반성\n * 메모리\n   * 단기\n   * 장기(에피소드, 의미, 절차 등등)\n * 계획 수립(Plan)\n   * 목표 정의\n   * 상태 표현\n   * 행동 순서화\n   * 최적화 및 평가\n   * 협업\n * 도구 사용(Tool)\n * 커뮤니케이션\n   * agent간 통신\n     * KQML(Knowledge Query and Manipulation Language)\n     * FIPA-ACL(Foundation for Intelligent Physical Agents – Agent Communication\n       Language)\n   * 인간-AI 통신\n     * 자연어 처리(Natural Language Processing), 음성 인식 등등\n * 러닝\n   * 지도 학습 supervised-learning\n   * 비지도 학습 unsupervised-learning\n   * 강화 학습\n   * 지속적인 학습\n   * 다중 에이전트 학습\n\n\n구현#\n\n 1. 문제를 정의\n 2. 데이터, 도구 준비\n 3. 적절한 AI 모델을 선택\n 4. 지속적인 모니터링\n 5. 성공 측정 및 평가\n\n\n워크플로우 / AI 어시스턴트 / AI 에이전트#\n\n워크플로는 LLM(Learning Leadership Machine)과 도구가 미리 정의된 코드 경로를 통해 조율되는 시스템입니다.\n\nAI 에이전트\n\n에이전트는 LLM이 자체 프로세스와 도구 사용을 동적으로 지시하고 작업 수행 방식을 제어하는 시스템입니다.\n\nAI 어시스턴트\n\nAI 어시스턴트는 사용자의 직접적인 요청이나 명령에 반응하여(Reactive) 작업을 수행합니다.\n\n\n기타#\n\n流程#\n\n * 规划 Planning\n   * 概念\n     * 观察与思考怎么完成任务\n     * 利用拥有的工具实现目的\n     * 任务拆分成子任务\n     * 执行任务的过程中进行反思和完善 吸取教训以完善未来的步骤\n * 记忆 Memory\n   * 分类\n     * 感觉记忆(Sensory Memory)\n     * 短期记忆\n     * 长期记忆\n * 工具 Tools\n   * 预制工具\n     * Bing Search\n     * dall-E Image\n   * 自定义工具\n   * 工具集\n * 执行 Action\n   * 执行任务\n   * 反馈结果\n\n举例#\n\n 1.  输入: 请问现任美国总统是谁？他的年龄的平方是多少？请用中文告诉我这两个问题\n 2.  规划: 我需要使用搜索引擎来找到美国现任总统的名字 然后使用计算器来计算他的年龄的平方‘\n 3.  执行: search\n 4.  执行输入: 美国现任总统\n 5.  Observation: joe biden\n 6.  Thought: 现任美国总统是 joe biden\n 7.  执行: Calculator\n 8.  执行输入: 68^2\n 9.  Observation: 4624\n 10. Thought: 我现在知道了美国现任总统是 joe biden 他的年龄的平方是 4624\n 11. Final Answer: 美国现任总统是 joe biden 他的年龄的平方是 4624\n\n框架#\n\n * Plan and Execute\n   1. user request\n   2. plan\n   3. generate tasks\n   4. exec tasks(single task agent(loop))\n   5. update state with task results\n   6. rePlan\n   7. response to user\n * Self Ask\n * Thiking and Self-Reflection 思考并自我反思\n   * 框架主要用于模拟和实现复杂决策过程，通过不断自我评估和调整，使系统能够学习并改进决策过程，从而在面对复杂问题时做出更加有效的决策\n   * Thinking\n     * LLM ⇒ Thougth1 ⇒ Action1 ⇒ Thougth2 ⇒ Action2 ⇒ Thougth3 ⇒ Action3 ⇒ End\n   * Self-Reflection\n     * LLM ⇒ Thougth1 ⇒ Action1 ⇒ LLM ⇒ Thougth2 ⇒ Action2 ⇒ LLM ⇒ End","routePath":"/artificialIntelligence/80-Agent","lang":"","toc":[{"text":"소개","id":"소개","depth":3,"charIndex":3},{"text":"핵심원칙","id":"핵심원칙","depth":3,"charIndex":194},{"text":"구성요소","id":"구성요소","depth":3,"charIndex":928},{"text":"구현","id":"구현","depth":3,"charIndex":1579},{"text":"워크플로우 / AI 어시스턴트 / AI 에이전트","id":"워크플로우--ai-어시스턴트--ai-에이전트","depth":3,"charIndex":1659},{"text":"기타","id":"기타","depth":3,"charIndex":1900}],"frontmatter":{},"version":""},{"title":"Agentic Design Patterns","content":"#\n\n\nPrompt Chaining#\n\n이 방법은 LLM이 복잡한 문제를 단일 단계로 통합적으로 해결하는 접근 방식을 버리고 분할 정복 전략을 채택합니다. 즉, 원래의 복잡한 문제를\n더 작고 관리하기 쉬운 하위 문제들의 연속으로 분해하고, 각 하위 문제는 특별히 설계된 단서를 통해 개별적으로 처리한 후, 그 결과를 다음\n단서에 입력으로 전달합니다.","routePath":"/artificialIntelligence/81-AgentPattern","lang":"","toc":[{"text":"Prompt Chaining","id":"prompt-chaining","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"Agent Project","content":"#\n\n\npre-guardrail#\n\npre가드레일 는 AI 시스템이 의도한 대로 작동하도록 보장하는 일련의 안전 조치입니다. 이러한 조치는 시스템이 예측할 수 없는 방식으로\n행동하거나 의도하지 않은 결과를 초래할 수 있는 잠재적인 위험을 완화하는 데 도움이 됩니다. 사전 가드레일의 예로는 입력 검증, 액세스 제어,\n모니터링 및 경고 시스템, 비상 중지 메커니즘 등이 있습니다. 사전 가드레일을 구현함으로써 개발자는 AI 시스템이 안전하고 신뢰할 수 있으며\n윤리적으로 작동하도록 보장할 수 있습니다.\n\n\npost-guardrail#\n\npost 가드레일 는 AI 시스템이 의도한 대로 작동하는지 확인하기 위해 시스템이 배포된 후에 구현되는 안전 조치입니다. 이러한 조치는 시스템이\n예측할 수 없는 방식으로 행동하거나 의도하지 않은 결과를 초래할 수 있는 잠재적인 위험을 모니터링하고 완화하는 데 도움이 됩니다. 사후\n가드레일의 예로는 지속적인 모니터링 및 감사, 사용자 피드백 메커니즘, 정기적인 업데이트 및 패치, 사고 대응 계획 등이 있습니다. 사후\n가드레일을 구현함으로써 개발자는 AI 시스템이 안전하고 신뢰할 수 있으며 윤리적으로 작동하도록 보장할 수 있습니다.\n\n\n모니터링#\n\n모니터링 은 AI 시스템의 성능과 행동을 지속적으로 관찰하고 분석하는 프로세스입니다. 모니터링은 시스템이 의도한 대로 작동하는지 확인하고\n잠재적인 문제나 위험을 식별하는 데 도움이 됩니다. 모니터링의 예로는 시스템 로그 및 메트릭 분석, 사용자 피드백 수집, 정기적인 감사 및\n검토, 이상 탐지 메커니즘 등이 있습니다. 모니터링을 구현함으로써 개발자는 AI 시스템이 안전하고 신뢰할 수 있으며 윤리적으로 작동하도록 보장할\n수 있습니다.\n\n\n에이전트가 실패하는 상황#\n\n문서가 길어지면 인용된 정보나 초반의 내용을 기억하지 못한다.#\n\n프롬프트에 의존하지 말고 메모리 시스템을 구축하여 에이전트가 장기적인 정보를 저장하고 검색할 수 있도록 해야 한다.\n\n적합한 도구를 선택하지 못한다.#\n\n명시적으로 도구 메뉴를 제공해 에이전트가 선택하도록 해야 한다.\n\n에이전트 사이의 협업이 안된다.#\n\n프롬프트로 작업의 목표와 범위를 명확하게 정의하고 에이전트의 역할과 책임을 명확히 해야 한다.","routePath":"/artificialIntelligence/82-AgentProject","lang":"","toc":[{"text":"pre-guardrail","id":"pre-guardrail","depth":3,"charIndex":3},{"text":"post-guardrail","id":"post-guardrail","depth":3,"charIndex":281},{"text":"모니터링","id":"모니터링","depth":3,"charIndex":599},{"text":"에이전트가 실패하는 상황","id":"에이전트가-실패하는-상황","depth":3,"charIndex":852}],"frontmatter":{},"version":""},{"title":"A2A","content":"Model Context Protocol#\n\nMCP(Model Context Protocol)는 AI 애플리케이션을 외부 시스템에 연결하기 위한 오픈 소스 표준입니다.\n\n\n사용사례#\n\n * 상담원은 사용자의 Google 캘린더와 Notion에 접근하여 더욱 개인화된 AI 비서 역할을 할 수 있습니다.\n * Claude Code는 Figma 디자인을 사용하여 전체 웹 앱을 생성할 수 있습니다.\n * 기업용 챗봇은 조직 전체의 여러 데이터베이스에 연결하여 사용자가 채팅을 통해 데이터를 분석할 수 있도록 지원합니다.\n * AI 모델은 Blender에서 3D 디자인을 만들고 3D 프린터로 출력할 수 있습니다.\n\n\n핵심 구성 요소#\n\n * 기본 프로토콜: Core JSON-RPC 메시지 유형\n * 수명주기 관리: 연결 초기화, 기능 협상 및 세션 제어\n * 권한 부여: HTTP 기반 전송을 위한 인증 및 권한 부여 프레임워크\n * 서버 기능: 서버에서 제공하는 리소스, 프롬프트 및 도구\n * 클라이언트 기능: 클라이언트에서 제공하는 샘플링 및 루트 디렉터리 목록\n * 유틸리티: 로깅 및 인자 자동 완성과 같은 공통 관심사\n\n\nArchitecture#\n\nhttps://modelcontextprotocol.io/specification/2025-11-25/architecture\n\n\nAgent Comunication Protocol#\n\n\n소개#\n\n에이전트 통신 프로토콜(ACP)은 AI 에이전트, 애플리케이션 및 인간을 연결하는 데 있어 점점 더 중요해지는 과제를 해결하기 위한 개방형\n에이전트 상호 운용성 프로토콜입니다. 최신 AI 에이전트는 종종 서로 다른 프레임워크, 팀 및 인프라에 걸쳐 독립적으로 구축됩니다. 이러한\n파편화는 혁신을 저해하고 에이전트 간의 효과적인 협업을 어렵게 만듭니다. ACP는 에이전트가 표준화된 RESTful API를 통해 통신할 수\n있도록 함으로써 이러한 문제를 해결합니다.\n\n\n현문제점#\n\n * 통합 장벽 - 서로 다른 에이전트를 연결하려면 맞춤형 솔루션이 필요합니다.\n * 중복 작업 - 팀에서 유사한 기능을 재구축해야 합니다.\n * 확장성 문제 - 지점 간 통합은 확장성이 떨어집니다.\n * 일관성 없는 개발자 경험 - 각 프레임워크마다 고유한 패턴이 있습니다.\n\n\n사용사례#\n\n * Flexible Agent Replacement(유연한 에이전트 교체)\n * Multi-Agent Collaboration(다중 에이전트 협업)\n * Cross-Platform Integration(크로스 플랫폼 통합)\n * Inter-Company Partnerships(기업 간 파트너십)\n\n\nA2A#\n\ngithub.com/a2aproject/a2a-js\n\n\nACP vs A2A#\n\nIBM이 2025년 3월에 출시한 에이전트 통신 프로토콜(ACP)과 구글이 2025년 4월에 출시한 에이전트 간 통신 프로토콜(A2A)은 모두\n에이전트 간 통신을 위한 표준 인터페이스를 만드는 것을 목표로 합니다. ACP의 장점은 다음과 같습니다.\n\n * Open Governance\n * Co-developed with BeeAI\n * REST-based Communication\n * Offline Agent Discovery\n * Message Structure\n * Agent Support\n * Native SDK\n\n\nACP vs MCP#\n\nAI 모델(주로 LLM)에 컨텍스트(리소스, 도구 등)를 제공합니다. MCP는 LLM과 해당 도구/리소스 간의 연결을 가능하게 하므로 \"단일\n에이전트\" 환경 내에서 효과적으로 작동합니다. 반면, 에이전트 통신 프로토콜(ACP)은 에이전트 간의 통신을 가능하게 하는 프로토콜입니다.\n\ngraph TD\n    subgraph \"Agent 1\"\n        A1[model] <--> |MCP| B1[tool]\n        A1 <--> |MCP| C1[resource]\n        A1 <--> |MCP| D1[...]\n    end\n\n    subgraph \"Agent 2\"\n        A2[model] <--> |MCP| B2[tool]\n        A2 <--> |MCP| C2[resource]\n        A2 <--> |MCP| D2[...]\n    end\n\n    A1 <--> |ACP| A2\n\n    class Agent1,Agent2 agent;\n    class A1,A2 model;\n    class B1,B2,C1,C2,D1,D2 mcp;\n","routePath":"/artificialIntelligence/90-ModelContextProtocol","lang":"","toc":[{"text":"사용사례","id":"사용사례","depth":3,"charIndex":95},{"text":"핵심 구성 요소","id":"핵심-구성-요소","depth":3,"charIndex":342},{"text":"Architecture","id":"architecture","depth":3,"charIndex":576},{"text":"소개","id":"소개","depth":3,"charIndex":694},{"text":"현문제점","id":"현문제점","depth":3,"charIndex":960},{"text":"사용사례","id":"사용사례-1","depth":3,"charIndex":1124},{"text":"ACP vs A2A","id":"acp-vs-a2a","depth":3,"charIndex":1337},{"text":"ACP vs MCP","id":"acp-vs-mcp","depth":2,"charIndex":1645}],"frontmatter":{},"version":""},{"title":"LLM Judge","content":"#\n\n用一个大模型来当裁判，评判其他大模型的输出质量。 你给他一个评估标准，然后让它根据这个标准来评分。是否准确，是否完整，是否符合要求等等。\n\n\n优点#\n\n * 规模化\n   * 人工评判成本高且耗时，使用大模型作为裁判可以大幅降低成本并提高效率。\n * 一致性\n   * 人类评判可能会受到主观因素影响，而大模型可以提供更加一致和客观的评判。\n * 成本低\n   * 相比于雇佣大量人类评判员，使用大模型作为裁判的成本更低。\n * 可解释性\n   * 许多大模型可以提供评判依据和解释，帮助理解评分结果。\n\n\n偏见#\n\n * 位置偏见\n   \n   * 靠前的答案可能会被认为更好。\n   * 解决: 在评分时随机打乱答案顺序， 评估多次取平均， 次结果差异大时人工复核。\n\n * 长度偏见\n   \n   * 更长的答案可能会被认为更全面。\n   * 解决: 评估prompt中明确告诉他评分标准\n   \n   # 评分标准说明\n   \n   回答的质量与长度无关\n   \n   评分原则\n   简洁准确的回答 -> 高分\n   冗长啰嗦的回答 -> 低分\n   \n\n * 自我偏好\n   \n   * 模型可能会偏好与自己生成风格相似的答案。\n   * 解决: 用不同的模型交叉评估\n\n * 风格偏见\n   \n   * 模型可能会偏好某种特定的表达风格。比如说 结构化分点回答比连贯自然语言分数更高。\n   * 解决: 在评分标准中明确说明检查的内容\n     * 明确评估标准\n       * 关注内容准确性\n       * 完整性是核心评分纬度\n       * 表达形式不影响评分\n     * 提供标准示例\n       * 展示不同风格的高质量回答\n       * 帮助模型理解质量 不同于 形式\n\n * 知识边界\n   \n   * 模型可能无法准确评估超出其知识范围的答案。 但模型会很自信的给出评估结果，这会导致误导。\n   * 解决: 引入领域知识，prompt里给相关的背景资料， 或者这个领域的微调好的模型来评估。 要是跳前不允许 只能人工评估。","routePath":"/artificialIntelligence/9990-LLMJudge","lang":"","toc":[{"text":"优点","id":"优点","depth":3,"charIndex":73},{"text":"偏见","id":"偏见","depth":3,"charIndex":256}],"frontmatter":{},"version":""},{"title":"langchain","content":"#\n\nLangChain은 2022년 10월, 하버드 대학의 Harrison Chase가 주도한 LLM을 활용한 애플리케이션을 구축하기 위한\n프레임워크입니다. LangChain핵심목표는 AI어플리케이션을 쉽고 빠르게 구현하는것입니다.예를 들면 Agent, QA시스템, 대햐형\n로봇등등입니다. LangChain은 다양한 언어 모델과 도구들을 통합하여 복잡한 작업을 수행할 수 있도록 지원합니다.\n\n\n왜서 langchain을 사용할까?#\n\nLangChain은 다음과 같은 이유로 사용됩니다:\n\n 1. 모듈화: LangChain은 다양한 구성 요소(예: LLM, 프롬프트 템플릿, 메모리 등)를 모듈화하여 개발자가 쉽게 조합하고 확장할 수\n    있도록 합니다.\n 2. 도구 통합: LangChain은 외부 도구(예: 검색 엔진, 데이터베이스 등)와의 통합을 지원하여 LLM의 기능을 확장합니다.\n 3. 체인 구성: LangChain은 여러 단계를 거쳐 작업을 수행하는 체인을 쉽게 구성할 수 있도록 도와줍니다.\n 4. 커뮤니티 및 생태계: LangChain은 활발한 커뮤니티와 다양한 플러그인 및 확장 기능을 제공하여 개발자가 최신 기술을 활용할 수\n    있도록 지원합니다.\n\n\nlangchain과 LLM직접 구현의 차이점#\n\n비교 항목            직접 대모델 API 호출                            LANGCHAIN 사용 개발\n개발 방식            단순 작업에는 직관적이지만, 복잡한 기능은 많은 커스텀 코드 필요     모듈을 조합하는 방식으로 복잡한 기능도 쉽게 구현 가능\n여러 모델 지원         모델 제공업체마다 다른 API를 직접 구현해야 함              통합 인터페이스 제공 → OpenAI, Anthropic, Hugging Face 등 쉽게 전환/조합 가능\n외부 데이터 연동        데이터 로딩, 전처리, 벡터화, 검색 기능까지 모두 직접 구현해야 함   PDF, DB, API 등과 쉽게 연결할 수 있는 RAG 기능과 다양한 도구 기본 제공\n문맥(컨텍스트) 관리      대화 히스토리를 직접 관리해야 하며 Token 초과 위험 있음       Memory 컴포넌트 제공 → 단기·장기 기억을 자동 관리\n복잡한 작업 자동화       다단계 추론, 도구 호출 등을 구현하려면 논리 구조 설계가 어려움     Agent 기능 제공 → 모델이 스스로 도구를 선택·호출해 작업 수행\n운영(배포·모니터링) 지원   표준화된 디버깅/모니터링 도구 부족                      LangSmith로 추적, 디버깅, 평가, 모니터링 지원\n\n\nlangchain 아키텍처#\n\n * LangChain\n   * langchain\n     * Chains\n     * Agents\n     * Retrieval strategies\n   * langchain-community\n     * Model I/O\n     * Retrival\n     * Tool\n   * langchain-core\n     * LCEL(LangChain Expression Language)\n * LangGraph\n   * Directed Graph와 Conditional Edge를 기반으로 멀티에이전트 애플리케이션을 구축할수 있으려 조건 분기, 반복,\n     병렬 등 복잡한 제어 흐름을 지원한다, 또한 상태 지속성, 중단후 재실행, 시간여행, 인간-에이전트 협업과 같은 고급기능을 구현 할수\n     있다.\n * LangSmith\n   * Debugging\n   * Playground\n   * Prompt Management\n   * Annotation\n   * Testing\n   * Monitoring\n * LangServe LangChain개발한 chain, agent등을 쉽게 배포하고 운영할수 있도록 지원하는 서비스\n\n\nLangChain 주요 컴포넌트#\n\n\nModel I/O#\n\nLLM모델과 상호작용 하는 컴포넌트로서 Format, Predict, Parse 단계가 있다. 대응하는 컴포넌트는 PromptTemplate,\nModel(LLM), OutputParser가 있다.\n\n\n\nLLM 분류#\n\n * LLMs: 단순히 텍스트 생성\n * Chat Models: 대화형 모델\n * Embedding Models: 텍스트를 벡터로 변환\n\nMessage#\n\n * System Message: 모델의 동작방식을 정의\n * Human Message: 사용자 입력\n * AI Message: 모델의 응답\n\nPromptTemplate#\n\n * Prompt: 모델에 전달되는 전체 텍스트\n * PromptTemplate: 변수화된 프롬프트\n * ChatPromptTemplate: 대화형 프롬프트 템플릿\n * XxxMessagePromptTemplate: 특정 유형의 메시지에 대한 프롬프트 템플릿\n * FewShotPromptTemplate: 몇 가지 예시를 포함하는 프롬프트 템플릿\n\nOutputParser#\n\n * StrOutputParser: 단순 문자열 출력 파서\n * JsonOutputParser: JSON 형식의 출력 파서\n * CommaSeparatedListOutputParser: 쉼표로 구분된 리스트 출력 파서\n * DatetimeOutputParser: 날짜 및 시간 출력 파서\n * XmlOutputParser: XML 형식의 출력 파서\n\n사용방식#\n\n * invoke: 단일 입력에 대한 예측 수행(ainvoke : 비동기 버전)\n * stream: 스트리밍 출력을 지원하는 예측 수행(astream : 비동기 버전)\n * batch: 배치 입력에 대한 예측 수행(abatch : 비동기 버전)\n\n\nChains#\n\nchain은 여러개 컴포넌트(prompt template, llm, memory, tool등)를 연결하여 특정 작업을 수행하는 단위입니다.\nchain에서 실행한 결과를 다음 체인에 전달하여 복잡한 작업을 수행할수 있습니다.\n\n\n\n종류#\n\n * LLMChain: prompt템플릿과 LLM을 package화한 가장 기본적인 체인\n * MultiPromptChain: 여러 개의 프롬프트 템플릿을 준비해두고, 입력을 **가장 적합한 프롬프트(템플릿)**로 LLM이 자동\n   선택하도록 하는 라우터.\n * LLMRouterChain: LLM이 입력을 읽고, **어떤 체인(또는 프롬프트)**으로 보낼지 결정하는 Router Chain.\n * EmbeddingRouterChain: 입력을 **임베딩(Embedding)**하여 미리 정의된 “주제 벡터들”과의 유사도 계산을 통해\n   어떤 체인으로 보낼지 결정하는 Router Chain.\n * MultiRetrievalQaRouter: 여러 개의 Retriever(벡터DB or 검색 소스)를 준비해두고, 입력을 보고 어떤\n   Retriever에서 자료를 가져올지 라우팅하는 체인.\n * SimpleSequentialChain: 여러개의 체인을 순차적으로 연결하여 실행, 앞 체인의 출력이 다음 체인의 입력.\n * SequentialChain: 여러개의 체인을 순차적으로 연결하여 실행, 여러 입력·출력을 각각 지정\n * RetrievalQA: Retriever로 문서를 검색한 뒤 LLM에 넣어 답변 생성.\n * ConversationalRetrievalQAChain: 대화형 문맥을 유지하면서 Retriever로 문서를 검색한 뒤 LLM에 넣어 답변\n   생성.\n * LCELChain: LangChain Expression Language(LCEL)을 사용하여 체인을 정의하는 방식\n * StuffDocumentsChain: 여러 문서를 하나로 합쳐서 LLM에 전달하는 체인\n * MapReduceDocumentsChain: 여러 문서를 각각 LLM에 전달하여 요약한 뒤, 그 요약들을 다시 LLM에 전달하여 최종 요약\n   생성\n * MapReRankDocumentsChain: 여러 문서를 각각 LLM에 전달하여 점수를 매긴 뒤, 상위 문서들을 다시 LLM에 전달하여\n   답변 생성\n * RefineChain: 초기 요약을 생성한 뒤, 추가 문서들을 순차적으로 반영하여 요약을 점진적으로 개선\n * LLMMathChain: 수학 문제 해결을 위해 LLM과 계산기를 결합한 체인\n * APIChain: API 호출을 위해 프롬프트 템플릿과 LLM을 결합한 체인\n * SQLDatabaseChain: 데이터베이스 질의를 위해 프롬프트 템플릿, LLM, 데이터베이스 커넥터를 결합한 체인\n * Hypothetical Document Embeddings: 문서의 가상 임베딩을 생성하여 검색 효율성을 높이는 체인\n * VectorDBQAChain: 벡터 데이터베이스에서 문서를 검색한 뒤 LLM에 넣어 답변 생성\n * ConversationalQAChain: 대화형 문맥을 유지하면서 LLM에 답변 생성\n * TransformChain: 입력 데이터를 변환하는 함수를 체인에 통합\n * LLMCheckerChain: LLM의 출력을 검증하는 체인\n * AnalyzeDocumentChain: 문서를 분석하는 체인\n * ConstitutionalChain: LLM의 출력을 헌법적 원칙에 따라 수정하는 체인\n * ExtractionChain: 구조화된 데이터를 추출하는 체인\n * LLMRequestChain: LLM에 대한 요청을 관리하는 체인 .....\n\n\nMemory#\n\n\n\n종류#\n\nMEMORY 종류                         설명                                               특징                     장점\nConversationBufferMemory          전체 대화를 원문 그대로 저장하여 LLM에 전달하는 기본 메모리              단순 버퍼 방식, 시간순 메시지 저장   구현이 쉽고 맥락 전달이 가장 자연스러움\nConversationBufferWindowMemory    전체 이력을 보관하되 LLM에는 최근 N개 메시지만 전달                  최근 맥락 중심, 비용 절감형 방식    최신 대화 맥락을 유지하면서 토큰 비용을 크게 줄일 수 있음\nConversationSummaryMemory         오래된 대화를 LLM이 *요약(summary)*하여 축약 저장               장기 대화에 최적화, 핵심 정보 중심   매우 긴 대화도 효율적으로 유지 가능하며 토큰 사용량 최소화\nConversationSummaryBufferMemory   오래된 대화는 요약, 최신 대화는 원문 유지하는 혼합형 메모리               요약 + 최근 메시지 버퍼 결합      자연스러운 대화 흐름 유지와 비용 절감을 동시에 실현\nConversationKGMemory              대화에서 엔티티·관계·사실을 추출해 지식 그래프(KG) 형태로 저장            구조적 지식 표현, 관계 기반 메모리   장기적 사실·관계를 명확하고 체계적으로 저장 가능\nVectorStoreRetrieverMemory        대화를 임베딩하여 VectorStore에 저장 후 유사도 검색으로 관련 내용만 로드   벡터 기반 검색, 확장성 높음       매우 큰 대화 기록도 효율적으로 검색 가능하여 장기 기억에 강함\nEntityMemory                      대화에서 사람·사물·장소 등 엔티티 기반 정보를 추출해 저장                엔티티 중심 구조화 메모리         사용자 정보·속성·선호 등을 장기적으로 안정적으로 기억\nChatMessageHistory                메모리 구성에 사용되는 기본 메시지 히스토리 객체                      단순 메시지 저장 구조           커스텀 메모리 개발 시 가장 유연하고 확장성이 좋음\nCustom Memory                     BaseMemory를 상속해 직접 구현하는 맞춤형 메모리                  완전 사용자 정의 가능           서비스 요구에 맞춘 고급 메모리 구조를 구축할 수 있음\n\n\nTools#\n\nTools는 LLM, Agent가 외부 시스템과 상호작용할수 있도록 도와주는 컴포넌트입니다. 본질은 함수(function)이며, 입력을 받아\n특정 작업을 수행한후 출력을 반환합니다. 예를들어 검색도구, 계산기, 데이터베이스, API통신 등이 있습니다.\n\n구성#\n\n * name: 도구 이름\n * description: 도구에 대한 설명으로 프롬프트에 포함되어 LLM이 도구를 선택하는데 도움을 줌\n * parameters: 도구에 전달되는 매개변수 정의\n * return type: 도구가 반환하는 출력 형식\n\n\n\n도구 호출 안되는 이슈#\n\n * LLM이 판단하기에 도구 호출이 필요하지 않다고 판단하는 경우\n * 도구 설명이 모호하여 LLM이 적절한 도구를 선택하지 못하는 경우\n * 일부 LLM 자체가 도구 호출을 선호하지 않는 경우(예: DeepSeek-R1)\n\n해결: 도구에 대한 description이나 제시어를 바꿔 보거나 다른 LLM을 사용\n\nlangchain tool과 MCP Server차이점#\n\n비교 항목         내장 TOOLS           MCP SERVER\n배포 위치         에이전트 내부(동일 프로세스)   독립 서비스(별도 프로세스/네트워크)\n코드 결합도        강한 결합(직접 코드 참조)    느슨한 결합(프로토콜 기반 통신)\n재사용성          해당 에이전트에서만 사용 가능   여러 에이전트 간 공유 가능\n업데이트 및 유지보수   수정 시 에이전트 재빌드 필요   독립적으로 업데이트 가능, 에이전트 재빌드 불필요\n성능            로컬 직접 호출로 매우 빠름    네트워크/IPC 통신 필요로 상대적으로 느림\n적합한 사용 시나리오   단순·특화 기능 도구        범용·복잡·확장 가능한 도구\n\n\nAgents#\n\n에이전트는 LLM과 도구를 결합하여 복잡한 작업을 수행하는 컴포넌트입니다. 에이전트는 사용자의 입력을 받아 적절한 도구를 선택하고 호출하여\n작업을 수행한 후 결과를 반환합니다.\n\n\n\n구성요소#\n\n * Memory 관리: 대화형 에이전트는 Memory컴포넌트를 사용하여 대화 히스토리를 관리하고 문맥을 유지합니다.\n   * short-term memory: 최근 대화 내용을 기억\n   * long-term memory: 장기적인 정보나 사실을 기억\n * Tools 활용: 에이전트는 다양한 도구를 활용하여 외부 시스템과 상호작용하고 복잡한 작업을 수행합니다.\n * Planning: 에이전트는 작업을 여러 단계로 나누어 계획을 세우고 실행할 수 있습니다.\n   * Reflection\n   * Self-critics\n   * Chain of Thoughts\n   * Subgoal decomposition\n * Action and Observation: 에이전트는 도구를 호출하고 그 결과를 관찰하여 다음 행동을 결정합니다.\n\nDeepagents#\n\ndeepagents는 복잡하고 다단계 작업을 처리할 수 있는 에이전트를 구축하기 위한 독립형 라이브러리입니다.\n\n사용해야 하는 경우#\n\n * 계획 및 분해가 필요한 복잡하고 다단계 작업을 처리할 때\n * 파일 시스템 도구를 통해 대량의 컨텍스트를 관리할 때\n * 컨텍스트 격리를 위해 특수 하위 에이전트에 작업을 위임할 때\n * 대화 및 스레드 간에 메모리를 유지할 때\n\n핵심 역량#\n\n * 계획 및 분해: 작업을 여러 단계로 나누어 계획을 세우고 실행\n * Context관리: 파일 시스템 도구를 통해 대량의 컨텍스트 관리\n * 하위 에이전트: 특수 하위 에이전트를 통해 작업 위임 및 컨텍스트 관리\n * Long-term memory: LangGraph의 Store를 사용하여 스레드 간에 영구 메모리를 확장\n\n예제#\n\n// 에이전트를 전문 연구자로 안내하는 시스템 프롬프트\nconst researchInstructions = `당신은 전문 연구자입니다. 당신의 임무는 철저한 조사를 수행하고 완성도 높은 보고서를 작성하는 것입니다.\n\n정보 수집의 주요 수단으로 인터넷 검색 도구를 사용할 수 있습니다.\n\n## \\`internet_search\\`\n\n이 기능을 사용하여 특정 쿼리에 대한 인터넷 검색을 실행합니다. 반환할 최대 결과 수, 주제, 그리고 원본 콘텐츠 포함 여부를 지정할 수 있습니다.\n`;\n\n\n참고#\n\n * https://zhuanlan.zhihu.com/p/1935481980641863575\n\n\nRetrieval Augmented Generation#\n\nRetrieval은 외부 지식 소스에서 관련 정보를 검색하여 LLM에 제공하는 컴포넌트입니다. 이를 통해 모델이 최신 정보에 접근하거나 도메인\n특화 지식을 활용할 수 있습니다. LLM은 학습동결 모델이기 때문에 사전학습된 지식 외의 정보를 제공하려면 Retrieval기능이 필수적입니다.\n또한 환각 문제를 완화하는데도 도움이 됩니다. RAG(Retrieval Augmented Generation)시스템의 핵심 구성 요소입니다.\n\n\n\nRetrieval Augmented Generation 흐름1#\n\n\n\n 1. 문서 파싱\n\n 2. 텍스트 분할\n\n 3. 백터화(EmbeddingModel사용)\n    \n    * nomic-embed-text\n    * mxbai-embed-large\n    * embedding-gemma\n\n 4. 벡터 DB 저장\n\n 5. 질문\n\n 6. 검색알고리즘(Cosine Similarity, Dot Product, Euclidean Distance 등)\n\n 7. 지식 재배치(RerankModels): 유사한 값이 높은 순으로 정렬\n\n 8. 증강: 사용자 질문과 함께 검색된 내용을 LLM에 전달\n\n 9. 응답 생성\n\nRetrieval Augmented Generation 장점#\n\n * 실시간 업데이트\n * 비용 대비 효율성\n * 출처를 제공하는 응답이여서 믿음직함\n * 안전하고 제어 가능: 제공한 문서에 기반한 응답만 생성 가능하게 제어 가능\n\nRetrieval Augmented Generation 단점#\n\n * 검색품질의 한계\n * 시스템 복잡도 증가\n * context가 영향을 받음\n * 제공한 문서의 영향도가 큼\n\nlangchain에서 구현#\n\n 1. Document Loaders\n\n * page_content: 문서의 실제 텍스트 내용\n * metadata: 문서에 대한 추가 정보\n\n 2. Text Splitters\n    \n    작동 원리\n    \n    우선 세분화한 후 병합하는 전략을 따릅니다. 먼저 텍스트를 작은 문장 단위로 분할한 다음, 이러한 문장들을 순서대로 결합하여 설정된 블록\n    크기 제한에 도달할 때까지 더 큰 블록으로 만듭니다. 새 블록을 생성할 때는 이전 블록과 일부 중복되는 부분을 유지하여 문맥의 연속성을\n    보장합니다.\n    \n    왜 구분이 필요한가\n    \n    * 생성된 답변의 품질 보장: 검색된 텍스트 블록이 너무 크고 관련 없는 정보가 많으면 LLM이 관련 없는 내용에 방해를 받아 핵심\n      문제에 집중하지 못할 수 있습니다. 심지어 관련 없는 정보를 잘못 통합하여 부정확하거나 장황한 답변을 생성할 수도 있습니다.\n    * 모델의 컨텍스트 창 제한 극복: 모든 대형 모델에는 고정된 컨텍스트 창이 있으며, 이는 모델이 한 번에 \"보고\" 처리할 수 있는\n      텍스트의 총량이 제한되어 있음을 의미합니다.\n    * 검색 정확도 향상: 검색 시스템은 특정 질문에 답할 수 있는 단락을 직접 찾을 수 있어 검색 결과의 관련성과 정확성을 크게\n      향상시킵니다.\n    \n    langchain의 Text Splitters\n    \n    * TextSplitter: LangChain에서 모든 텍스트 분할기의 기반이 되는 추상(Base) 클래스입니다.\n    * CharacterTextSplitter: 문자/문단 단위로 단순하게 분할하는 기본 방식.\n    * RecursiveCharacterTextSplitter: 여러 분리자를 계층적으로 적용하여 자연스럽게 텍스트를 분할하는 권장 방식.\n    * TokenTextSplitter: 토큰 개수 기준으로 텍스트를 분할하는 방식(OpenAI 등 토큰 제한 대응).\n    * LatexTextSplitter: LaTeX 문서 프로그래밍 언어를 이해\n    * MarkdownTextSplitter: Markdown 구조를 이해\n\n 3. Text Embedding Models(모델: nomic-embed-text등등.)\n\n 4. Vector Stores\n\n * 저장\n * 검색\n\n 5. Retrievers Vector Stores가 함수 제공(알고리즘포함)\n\n\nCallbacks#\n\n\n기타 미정리#\n\nchunk#\n\n * chunkSize\n * chunkOverlap\n\n\n\nMMR#\n\nLangChain 支持对检索结果进行基于 maximum marginal relevance（MMR，最大边界相关法）的重新排序\n\n多查询检索#\n\n以距离为度量的向量数据库检索，是通过将 query 进行 embedding（表征）到高维的向量空间，然后基于距离检索相似文档（embedding\n到相同向量空间）。\n\n但有时 query 中词语的轻微改变，或者 embedding 无法很好地捕获 query 的语义信息，那么将导致无法有效检索到相似文档。 而多 query\n检索便是应对这个问题，会通过提示词工程，将 query 输入到 LLM 从不同角度生成多个类似的查询，再分别用多个 query\n去进行检索，然后汇聚这些检索结果，并进行去重，这样能够获取更多潜在的相似文档。\n\n * https://reference.langchain.com/javascript/classes/_langchain_classic.retriev\n   ers_multi_query.MultiQueryRetriever.html\n\nconst retriever = new MultiQueryRetriever.fromLLM({\n  llm: new ChatAnthropic({}),\n  retriever: new MemoryVectorStore().asRetriever(),\n  verbose: true,\n});\nconst retrievedDocs = await retriever.invoke(\"What are mitochondria made of?\");\n\n\n\n링크#\n\n * https://zhuanlan.zhihu.com/p/684209043\n * https://zhuanlan.zhihu.com/p/684216350\n * https://zhuanlan.zhihu.com/p/1975217069487313790\n * 基于LangChain的RAG开发教程（二)\n * LLM(大语言模型)「Agent」开发教程-LangChain（三）","routePath":"/artificialIntelligence/tools/langchain","lang":"","toc":[{"text":"왜서 langchain을 사용할까?","id":"왜서-langchain을-사용할까","depth":2,"charIndex":220},{"text":"langchain과 LLM직접 구현의 차이점","id":"langchain과-llm직접-구현의-차이점","depth":2,"charIndex":601},{"text":"langchain 아키텍처","id":"langchain-아키텍처","depth":2,"charIndex":1296},{"text":"LangChain 주요 컴포넌트","id":"langchain-주요-컴포넌트","depth":2,"charIndex":1892},{"text":"Model I/O","id":"model-io","depth":3,"charIndex":1913},{"text":"Chains","id":"chains","depth":3,"charIndex":2783},{"text":"Memory","id":"memory","depth":3,"charIndex":4590},{"text":"Tools","id":"tools","depth":3,"charIndex":5947},{"text":"Agents","id":"agents","depth":3,"charIndex":6835},{"text":"Retrieval Augmented Generation","id":"retrieval-augmented-generation","depth":3,"charIndex":8112},{"text":"Callbacks","id":"callbacks","depth":3,"charIndex":10180},{"text":"기타 미정리","id":"기타-미정리","depth":3,"charIndex":10193},{"text":"링크","id":"링크","depth":3,"charIndex":10957}],"frontmatter":{},"version":""},{"title":"ollama","content":"#\n\n\n명령어#\n\n명령어                     기능 요약\nollama --help           전체 명령어 및 옵션 확인\nollama --version        버전 정보 확인\nollama serve            Ollama 서버 시작\nollama pull <모델>        모델 다운로드만 수행\nollama run <모델>         모델 다운로드 + 실행 (대화 세션)\nollama list             로컬 모델 목록 출력\nollama ps               현재 실행 중인 모델 목록 확인\nollama stop <모델>        실행 중 모델 종료\nollama rm <모델>          모델 삭제\nollama show <모델>        모델 메타 데이터 보기\nollama cp <src> <dst>   모델 복제\nollama push <모델>        모델을 레지스트리로 업로드\n\n\nollama run huggingface#\n\nGGUF파일어어야 됨.\n\n * https://huggingface.co/Neuwhufbox/BGE-m3-ko-gguf\n\nollama run hf.co/{username}/{reponame}:latest\n","routePath":"/artificialIntelligence/tools/ollama","lang":"","toc":[{"text":"명령어","id":"명령어","depth":3,"charIndex":3},{"text":"ollama run huggingface","id":"ollama-run-huggingface","depth":3,"charIndex":480}],"frontmatter":{},"version":""},{"title":"Hello","content":"#\n\n:::giphy xTiTngMMCIt7FramOc :::","routePath":"/hello/","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"Portfolio","content":"#\n\n\nLibrary#\n\nJECO#\n\n별도의 셋팅이 필요없는 React 개발 환경을 만들어 보고 싶어서 도전했던 프로젝트\n\n * npm: https://www.npmjs.com/package/jeco\n * github: https://github.com/jl917/jeco\n\nJNPKG#\n\nNPM 패키지를 편하게 만들기 위해서 만들었던 좋은 도구이고 semantic-release가 포함되어서 초기 관리가 굉장히 편리\n\n * npm: https://www.npmjs.com/package/jnpkg\n * github: https://github.com/jl917/jnpkg\n\nJBIN#\n\nNODE 기반 CLI를 누구나 만들수 있도록 도와주는 빌드도구\n\n * npm: https://www.npmjs.com/package/@julong/jbin\n * github: https://github.com/jl917/jbin\n\nCHECKER#\n\n프로젝트 품질향상을 위한 도구로 eslint, stylelint, markdownlint, htmlhint를 포함\n\n * npm: https://www.npmjs.com/package/@julong/checker\n * github: https://github.com/jl917/checker\n\nESlint Watch#\n\nESLint를 번들러에 포함시키지 않고 별도로 비동기처리 함으로써 개발환경을 개선하고자 만들었던 프로젝트\n\n * npm: https://www.npmjs.com/package/@julong/eslint-watch\n * github: https://github.com/jl917/eslintWatch\n\nmicro-frontend-utils#\n\n마이크로 프론트엔드 구축할때 React 또는 Vue의 mount, unmount를 도와주는 유틸\n\n * npm: https://www.npmjs.com/package/@julong/micro-frontend-utils\n * github: https://github.com/jl917/micro-frontend-utils\n\n\nPlugin#\n\nbabel-plugin-add-optional-chaining#\n\n일부환경에 필요한 기능으로서 옵셔널 체이닝을 자동으로 추가해서 TypeError 오류를 발생 최소화\n\n * npm: https://www.npmjs.com/package/babel-plugin-add-optional-chaining\n * github: https://github.com/jl917/babel-plugin-add-optional-chaining\n\nrspress-plugin-sitemap#\n\nSEO 검색엔진에 필요한 사이트맵 자동생성 플러그인\n\n * npm: https://www.npmjs.com/package/rspress-plugin-sitemap\n * github: https://github.com/jl917/rspress-plugin-sitemap\n\nrspress-plugin-clarity#\n\nMicrosoft Clarity 연동을 위한 플러그인\n\n * npm: https://www.npmjs.com/package/rspress-plugin-clarity\n * github: https://github.com/jl917/rspress-plugin-clarity\n\nvite-plugin-jsx-remove-attrs#\n\nvite 개발환경에서 빌드시 불필요한 속성을 제거해주는 플러그인\n\n * npm: https://www.npmjs.com/package/@julong/vite-plugin-jsx-remove-attrs\n * github: https://github.com/jl917/vite-plugin-jsx-remove-attrs\n\nwebpack-plugin-runtime-assets#\n\n마이크로 프론트엔드 개발시 runtime에 꼭 필요한 js파일만 가져오는 플러그인\n\n * npm: https://www.npmjs.com/package/@julong/webpack-plugin-runtime-assets\n * github: https://github.com/jl917/webpack-plugin-runtime-assets\n\nwinston-mongodb#\n\nexpress 서버에서 winston 사용시 관련로그를 mongodb에 저장하는 플러그인\n\n * npm: https://www.npmjs.com/package/@julong/winston-mongodb\n * github: https://github.com/jl917/winston-mongodb","routePath":"/hello/portfolio","lang":"","toc":[{"text":"Library","id":"library","depth":2,"charIndex":3},{"text":"JECO","id":"jeco","depth":4,"charIndex":13},{"text":"JNPKG","id":"jnpkg","depth":4,"charIndex":153},{"text":"JBIN","id":"jbin","depth":4,"charIndex":321},{"text":"CHECKER","id":"checker","depth":4,"charIndex":457},{"text":"ESlint Watch","id":"eslint-watch","depth":4,"charIndex":631},{"text":"micro-frontend-utils","id":"micro-frontend-utils","depth":4,"charIndex":814},{"text":"Plugin","id":"plugin","depth":2,"charIndex":1018},{"text":"babel-plugin-add-optional-chaining","id":"babel-plugin-add-optional-chaining","depth":4,"charIndex":1027},{"text":"rspress-plugin-sitemap","id":"rspress-plugin-sitemap","depth":4,"charIndex":1266},{"text":"rspress-plugin-clarity","id":"rspress-plugin-clarity","depth":4,"charIndex":1442},{"text":"vite-plugin-jsx-remove-attrs","id":"vite-plugin-jsx-remove-attrs","depth":4,"charIndex":1619},{"text":"webpack-plugin-runtime-assets","id":"webpack-plugin-runtime-assets","depth":4,"charIndex":1828},{"text":"winston-mongodb","id":"winston-mongodb","depth":4,"charIndex":2050}],"frontmatter":{},"version":""},{"title":"Social","content":"#\n\n * https://github.com/jl917\n * https://codesandbox.io/u/jl917\n * https://www.npmjs.com/~julong\n * https://leetcode.cn/u/julong1988/","routePath":"/hello/social","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"Software","content":"#\n\n\n개발용#\n\n이름                   링크\nZsh                  https://ohmyz.sh/\nHomebrew             https://brew.sh/\nGit 다운로드             https://git-scm.com/download/mac\nGit SSH 키 생성         https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥\nNode.js              https://formulae.brew.sh/formula/node\nPict                 brew install pict\nVisual Studio Code   https://code.visualstudio.com/\nVS Code 설정           https://code.visualstudio.com/docs/setup/mac\nSpectacle            https://github.com/eczarny/spectacle/releases\nVSCodium             https://vscodium.com/\nSmart JSON Editor    http://www.smartjsoneditor.com/\nGitHub Desktop       https://desktop.github.com/\nNVM                  https://github.com/nvm-sh/nvm/tree/master\nStudio 3T            https://studio3t.com/download/\nCursor               https://cursor.sh/\nPicGo                https://molunerfinn.com/PicGo/\nChrome 베타            https://www.google.com/chrome/beta/\nChrome 한국어           https://www.google.com/intl/ko/chrome/\nPostman              https://www.postman.com/downloads/?utm_source=postman-home\nNotion               https://www.notion.so/ko-kr\nGas Mask             https://github.com/2ndalpha/gasmask\nreqable              https://reqable.com/en-US/\nOphiuchi             https://www.ophiuchi.dev/\nDebugtron            https://github.com/pd4d10/debugtron\ntrae                 https://www.trae.ai/\nrust                 https://rust-lang.org/learn/get-started/\nyoutubedownload      https://ytdn.netlify.app/#mac\n\n\nAI#\n\n이름            링크\nollama        https://ollama.com/download\nchatbox       https://chatboxai.app/en\nanythingllm   https://anythingllm.com/desktop\n\n\n개인용#\n\n이름          링크\nIINA        https://iina.io/\nMotrix      https://motrix.app/\nFileZilla   https://filezilla-project.org/\nWireshark   https://www.wireshark.org/\nInfuse      https://apps.apple.com/kr/app/infuse-비디오-플레이어/id1136220934\nPicView     https://picview.org/\n\n\n설정#\n\ngit config --global user.name \"JuLong\"\ngit config --global user.email julong1988@naver.com\nnpm install -g http-server\ncd ~/\nmkdir .ssh\ncd .ssh\nssh-keygen -o\ncat ~/.ssh/id_rsa.pub\n\nxattr -cr /Applications/PicGo.app\nsudo spctl --master-disable\n\ndefaults write com.apple.finder AppleShowAllFiles -bool true\nkillall Finder\n\n## npm set\nnpm set init-author-name 'jl917'\nnpm set init-author-email 'julong1988@naver.com'\nnpm set init-author-url 'https://jl917.github.io'\nnpm set init-license 'MIT'\n\n## python set\nln -s $(which python3) /opt/homebrew/bin/python\nln -s $(which pip3) /opt/homebrew/bin/pip\n\n\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\n\n# .zshrc\n# alias pip=/usr/bin/pip3\n# alias python=/usr/bin/python3\n\nexport PATH=\"$HOME/.cargo/bin:$PATH\"\nexport ZSH=\"$HOME/.oh-my-zsh\"\nZSH_THEME=\"robbyrussell\"\nplugins=(git)\nsource $ZSH/oh-my-zsh.sh\nexport PATH=/opt/homebrew/bin:$PATH\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\nautoload -U add-zsh-hook\nload-nvmrc() {\n  local nvmrc_path\n  nvmrc_path=\"$(nvm_find_nvmrc)\"\n\n  if [ -n \"$nvmrc_path\" ]; then\n    local nvmrc_node_version\n    nvmrc_node_version=$(nvm version \"$(cat \"${nvmrc_path}\")\")\n\n    if [ \"$nvmrc_node_version\" = \"N/A\" ]; then\n      nvm install\n    elif [ \"$nvmrc_node_version\" != \"$(nvm version)\" ]; then\n      nvm use\n    fi\n  elif [ -n \"$(PWD=$OLDPWD nvm_find_nvmrc)\" ] && [ \"$(nvm version)\" != \"$(nvm version default)\" ]; then\n    echo \"Reverting to nvm default version\"\n    nvm use default\n  fi\n}\n\nadd-zsh-hook chpwd load-nvmrc\nload-nvmrc\n\n\nexport PYENV_ROOT=\"$HOME/.pyenv\"\n[[ -d $PYENV_ROOT/bin ]] && export PATH=\"$PYENV_ROOT/bin:$PATH\"\neval \"$(pyenv init - bash)\"\neval \"$(pyenv virtualenv-init -)\"\n\n\n\n\n\n기타 설치#\n\nbrew install python\n\n## 安装pyenv\ncurl https://pyenv.run | bash\n\n## 安装指定版本（如3.12.0）\npyenv install 3.12.0\n\n## 设置全局版本\npyenv global 3.12.0\n","routePath":"/hello/software","lang":"","toc":[{"text":"개발용","id":"개발용","depth":2,"charIndex":3},{"text":"AI","id":"ai","depth":2,"charIndex":1483},{"text":"개인용","id":"개인용","depth":2,"charIndex":1634},{"text":"설정","id":"설정","depth":2,"charIndex":1904},{"text":"기타 설치","id":"기타-설치","depth":2,"charIndex":3882}],"frontmatter":{},"version":""},{"title":"ESC/POS 프린터 명령어 문서","content":"#\n\n\n기본 제어 문자#\n\n * LF (\\x0a): 라인 피드 (줄바꿈)\n * FS (\\x1c): 필드 구분자\n * FF (\\x0c): 폼 피드 (페이지 넘김)\n * GS (\\x1d): 그룹 구분자\n * DLE (\\x10): 데이터 링크 이스케이프\n * EOT (\\x04): 전송 종료\n * NUL (\\x00): Null 문자\n * ESC (\\x1b): 이스케이프 시퀀스 시작\n * TAB (\\x74): 탭\n * EOL (\\n): 줄 끝\n\n\n피드 제어 시퀀스#\n\n * CTL_LF (\\x0a): 인쇄 후 줄바꿈\n * CTL_GLF (\\x4a\\x00): 줄 간격 없이 인쇄 및 용지 공급\n * CTL_FF (\\x0c): 폼 피드\n * CTL_CR (\\x0d): 캐리지 리턴\n * CTL_HT (\\x09): 수평 탭\n * CTL_VT (\\x0b): 수직 탭\n\n\n문자 간격#\n\n * CS_DEFAULT (\\x1b\\x20\\x00): 기본 문자 간격으로 설정\n * CS_SET (\\x1b\\x20): 문자 간격 설정\n\n\n줄 간격#\n\n * LS_DEFAULT (\\x1b\\x32): 기본 줄 간격으로 설정\n * LS_SET (\\x1b\\x33): 줄 간격 설정\n\n\n하드웨어 제어#\n\n * HW_INIT (\\x1b\\x40): 버퍼 데이터 삭제 및 모드 초기화\n * HW_SELECT (\\x1b\\x3d\\x01): 프린터 선택\n * HW_RESET (\\x1b\\x3f\\x0a\\x00): 프린터 하드웨어 리셋\n\n\n금전함 제어#\n\n * CD_KICK_2 (\\x1b\\x70\\x00\\x19\\x78): 2번 핀으로 펄스 신호 전송\n * CD_KICK_5 (\\x1b\\x70\\x01\\x19\\x78): 5번 핀으로 펄스 신호 전송\n\n\n여백 설정#\n\n * BOTTOM (\\x1b\\x4f): 하단 여백 설정\n * LEFT (\\x1b\\x6c): 좌측 여백 설정\n * RIGHT (\\x1b\\x51): 우측 여백 설정\n\n\n용지 컷팅#\n\n * PAPER_FULL_CUT (\\x1d\\x56\\x00): 용지 완전 절단\n * PAPER_PART_CUT (\\x1d\\x56\\x01): 용지 부분 절단\n * PAPER_CUT_A (\\x1d\\x56\\x41): A 타입 부분 절단\n * PAPER_CUT_B (\\x1d\\x56\\x42): B 타입 부분 절단\n * STAR_FULL_CUT (\\x1B\\x64\\x02): STAR 프린터용 완전 절단\n\n\n텍스트 포맷#\n\n\n기본 포맷#\n\n * TXT_NORMAL (\\x1b\\x21\\x00): 일반 텍스트\n * TXT_2HEIGHT (\\x1b\\x21\\x10): 2배 높이 텍스트\n * TXT_2WIDTH (\\x1b\\x21\\x20): 2배 너비 텍스트\n * TXT_4SQUARE (\\x1b\\x21\\x30): 2배 높이 및 너비 텍스트\n * STAR_TXT_EMPHASIZED (\\x1B\\x45): STAR 프린터용 강조 텍스트\n * STAR_CANCEL_TXT_EMPHASIZED (\\x1B\\x46): STAR 프린터용 강조 취소\n\n\n텍스트 스타일#\n\n * TXT_UNDERL_OFF (\\x1b\\x2d\\x00): 밑줄 해제\n * TXT_UNDERL_ON (\\x1b\\x2d\\x01): 1점 밑줄 설정\n * TXT_UNDERL2_ON (\\x1b\\x2d\\x02): 2점 밑줄 설정\n * TXT_BOLD_OFF (\\x1b\\x45\\x00): 굵은 글씨 해제\n * TXT_BOLD_ON (\\x1b\\x45\\x01): 굵은 글씨 설정\n * TXT_ITALIC_OFF (\\x1b\\x35): 이탤릭체 해제\n * TXT_ITALIC_ON (\\x1b\\x34): 이탤릭체 설정\n\n\n글꼴 설정#\n\n * TXT_FONT_A (\\x1b\\x4d\\x00): A 글꼴\n * TXT_FONT_B (\\x1b\\x4d\\x01): B 글꼴\n * TXT_FONT_C (\\x1b\\x4d\\x02): C 글꼴\n\n\n정렬#\n\n * TXT_ALIGN_LT (\\x1b\\x61\\x00): 왼쪽 정렬\n * TXT_ALIGN_CT (\\x1b\\x61\\x01): 가운데 정렬\n * TXT_ALIGN_RT (\\x1b\\x61\\x02): 오른쪽 정렬\n\n\nSTAR 프린터 정렬#\n\n * STAR_TXT_ALIGN_LA (\\x1B\\x1D\\x61\\x00): 왼쪽 정렬\n * STAR_TXT_ALIGN_CA (\\x1B\\x1D\\x61\\x01): 가운데 정렬\n * STAR_TXT_ALIGN_RA (\\x1B\\x1D\\x61\\x02): 오른쪽 정렬\n\n\n바코드 포맷#\n\n\n텍스트 위치#\n\n * BARCODE_TXT_OFF (\\x1d\\x48\\x00): HRI 문자 표시 안함\n * BARCODE_TXT_ABV (\\x1d\\x48\\x01): HRI 문자 위쪽 표시\n * BARCODE_TXT_BLW (\\x1d\\x48\\x02): HRI 문자 아래쪽 표시\n * BARCODE_TXT_BTH (\\x1d\\x48\\x03): HRI 문자 위아래 표시\n\n\n바코드 글꼴#\n\n * BARCODE_FONT_A (\\x1d\\x66\\x00): A 글꼴\n * BARCODE_FONT_B (\\x1d\\x66\\x01): B 글꼴\n\n\n바코드 타입#\n\n * BARCODE_UPC_A (\\x1d\\x6b\\x00): UPC-A\n * BARCODE_UPC_E (\\x1d\\x6b\\x01): UPC-E\n * BARCODE_EAN13 (\\x1d\\x6b\\x02): EAN13\n * BARCODE_EAN8 (\\x1d\\x6b\\x03): EAN8\n * BARCODE_CODE39 (\\x1d\\x6b\\x04): CODE39\n * BARCODE_ITF (\\x1d\\x6b\\x05): ITF\n * BARCODE_NW7 (\\x1d\\x6b\\x06): NW7\n * BARCODE_CODE93 (\\x1d\\x6b\\x48): CODE93\n * BARCODE_CODE128 (\\x1d\\x6b\\x49): CODE128\n\n\n2D 코드 포맷#\n\n\n타입#\n\n * TYPE_PDF417: PDF417 바코드\n * TYPE_DATAMATRIX: Data Matrix\n * TYPE_QR: QR 코드\n\n\nQR 코드 오류 수정 레벨#\n\n * QR_LEVEL_L: 7% 오류 수정\n * QR_LEVEL_M: 15% 오류 수정\n * QR_LEVEL_Q: 25% 오류 수정\n * QR_LEVEL_H: 30% 오류 수정\n\n\n이미지 포맷#\n\n * S_RASTER_N: 일반 크기 래스터 이미지\n * S_RASTER_2W: 2배 너비 래스터 이미지\n * S_RASTER_2H: 2배 높이 래스터 이미지\n * S_RASTER_Q: 4배 크기 래스터 이미지\n\n\n비트맵 포맷#\n\n * BITMAP_S8: 8-bit 단일 밀도\n * BITMAP_D8: 8-bit 이중 밀도\n * BITMAP_S24: 24-bit 단일 밀도\n * BITMAP_D24: 24-bit 이중 밀도\n\n\n색상 설정#\n\n * 0 (\\x1b\\x72\\x00): 검정색\n * 1 (\\x1b\\x72\\x01): 빨간색\n * REVERSE (\\x1dB1): 색상 반전 (흰색 텍스트, 검은 배경)\n * UNREVERSE (\\x1dB0): 색상 반전 해제 (검은 텍스트, 흰색 배경)","routePath":"/mark/escpos","lang":"","toc":[{"text":"기본 제어 문자","id":"기본-제어-문자","depth":2,"charIndex":3},{"text":"피드 제어 시퀀스","id":"피드-제어-시퀀스","depth":2,"charIndex":246},{"text":"문자 간격","id":"문자-간격","depth":2,"charIndex":423},{"text":"줄 간격","id":"줄-간격","depth":2,"charIndex":508},{"text":"하드웨어 제어","id":"하드웨어-제어","depth":2,"charIndex":586},{"text":"금전함 제어","id":"금전함-제어","depth":2,"charIndex":720},{"text":"여백 설정","id":"여백-설정","depth":2,"charIndex":837},{"text":"용지 컷팅","id":"용지-컷팅","depth":2,"charIndex":937},{"text":"텍스트 포맷","id":"텍스트-포맷","depth":2,"charIndex":1166},{"text":"기본 포맷","id":"기본-포맷","depth":3,"charIndex":1176},{"text":"텍스트 스타일","id":"텍스트-스타일","depth":3,"charIndex":1460},{"text":"글꼴 설정","id":"글꼴-설정","depth":3,"charIndex":1753},{"text":"정렬","id":"정렬","depth":3,"charIndex":1868},{"text":"STAR 프린터 정렬","id":"star-프린터-정렬","depth":3,"charIndex":1991},{"text":"바코드 포맷","id":"바코드-포맷","depth":2,"charIndex":2150},{"text":"텍스트 위치","id":"텍스트-위치","depth":3,"charIndex":2160},{"text":"바코드 글꼴","id":"바코드-글꼴","depth":3,"charIndex":2365},{"text":"바코드 타입","id":"바코드-타입","depth":3,"charIndex":2454},{"text":"2D 코드 포맷","id":"2d-코드-포맷","depth":2,"charIndex":2814},{"text":"타입","id":"타입","depth":3,"charIndex":2826},{"text":"QR 코드 오류 수정 레벨","id":"qr-코드-오류-수정-레벨","depth":3,"charIndex":2910},{"text":"이미지 포맷","id":"이미지-포맷","depth":2,"charIndex":3028},{"text":"비트맵 포맷","id":"비트맵-포맷","depth":2,"charIndex":3157},{"text":"색상 설정","id":"색상-설정","depth":2,"charIndex":3276}],"frontmatter":{},"version":""},{"title":"Conventional Commits","content":"#\n\n\n참고#\n\n * https://www.conventionalcommits.org/en/v1.0.0/\n\n컨벤션 스타일#\n\n * @commitlint/config-angular\n * @commitlint/config-conventional\n * @commitlint/config-lerna-scopes\n * @commitlint/config-nx-scopes\n * @commitlint/config-patternplate\n * conventional-changelog-lint-config-atom\n * conventional-changelog-lint-config-canonical\n * commitlint-config-jira","routePath":"/mark/guideline/commits","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3},{"text":"컨벤션 스타일","id":"컨벤션-스타일","depth":4,"charIndex":59}],"frontmatter":{},"version":""},{"title":"Front-End Checklist","content":"#\n\n\n참고#\n\n * https://github.com/thedaviddias/Front-End-Checklist","routePath":"/mark/guideline/frontend-checklist","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"Nodejs Best Practices","content":"#\n\n\n참고#\n\n * https://github.com/goldbergyoni/nodebestpractices/tree/master","routePath":"/mark/guideline/node","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"Project Guidelines","content":"#\n\n\n참고#\n\n * https://github.com/elsewhencode/project-guidelines","routePath":"/mark/guideline/project","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"Code Review(js/ts)","content":"#\n\n * 새로운 종속성 검토\n * 라이브러리 중복 방지\n * 가져오기 관행 검증\n * 번역 검증(새로 추가된 영역이 제대로 지역화되었는지 확인)\n * 적절한 타이핑 적용\n * 명명 규칙 확인\n * 부울 접두사 사용(부울 의도를 명확히 하기 위해 is, are 또는 should 사용)\n * 함수 이름은 함수가 수행하거나 반환하는 내용을 설명해야 합니다.\n * 지나치게 복잡한 로직 주의\n * 장황한 코드 간소화\n * 모호한 코드에 대한 문의\n * 하드코딩된 값 사용 금지(경로, 이름, 값을 상수 또는 구성으로 이동)\n * 이전 버전과의 호환성 유지\n * 반복적인 로직 제거\n * 폼 유효성 검사 확인\n * 누락되었거나 처리되지 않은 try/catch 블록 확인\n * 비동기 작업이 효율적이고 올바르게 처리되는지 확인\n * 이전 개발 경험을 활용하여 코드 개선 방향 제시","routePath":"/mark/guideline/review","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"Semantic Versioning","content":"#\n\n\n참고#\n\n * https://semver.org/","routePath":"/mark/guideline/semver","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"Javascript Testing Best Practices","content":"#\n\n\n참고#\n\n * https://github.com/goldbergyoni/javascript-testing-best-practices","routePath":"/mark/guideline/test","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"Web Content Accessibility Guidelines","content":"#\n\n\n참고#\n\n * http://www.kwacc.or.kr/WAI/wcag21/","routePath":"/mark/guideline/wcag","lang":"","toc":[{"text":"참고","id":"참고","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"npm packages","content":"Mark#\n\n * 得物商家客服从 Electron 迁移到 Tauri 的技术实践\n * RFC: JSON Merge\n * Web 3D 引擎 galacean\n * Deeper Dive Into React\n * source-map\n * source-map 설명\n * source-map-visualization\n * WHATWG-Standards\n * Google Style Guides(html, css, js, ts ...)\n * AngularJS Git Commit Message Conventions\n * 贡献者公约 Contributor Covenant Translations\n * Github Community Guidelines\n * JavaScript Standard Style\n * Fake Images\n * Dynamic DummyImage Generator\n * JavaScript Patterns\n * creativecommons\n * Test your front-end against a real API\n * JSON Schema Validator\n * Emmet\n * ColorSpace\n * Google SEO\n * Web Platform Incubator Community Group\n * The HTTP Archive Tracks How the Web is Built\n * Tauri VS Electron 启动性能 PK\n\n\nEducation#\n\n * fullstackopen\n * Rust Course\n * Rusty Book\n\n\nReact core#\n\n * https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkzMjIxNTcyMA==&action=getalbu\n   m&album_id=1783121402896678912&subscene=159&subscene=&scenenote=https%3A%2F%2\n   Fmp.weixin.qq.com%2Fs%2FUC022AC-O506ueFykZyWbQ&nolastread=1#wechat_redirect\n * https://react.iamkasong.com/\n * https://www.qinguanghui.com/\n\n\nnpm packages#\n\n * https://www.npmjs.com/package/jsbarcode\n * https://www.npmjs.com/package/qrcode\n * https://www.npmjs.com/package/dexie\n * https://www.npmjs.com/package/localforage\n * https://www.npmjs.com/search?q=node-schedule\n * https://www.npmjs.com/package/numeral\n * https://www.npmjs.com/package/currency.js\n * https://www.npmjs.com/package/print-js\n * https://www.npmjs.com/package/jsonpath-plus\n * https://www.npmjs.com/package/jimp\n * https://www.npmjs.com/package/mitt\n * https://www.npmjs.com/package/realm\n * https://www.npmjs.com/package/lozad\n * https://www.npmjs.com/package/zeromq\n * https://www.npmjs.com/package/gcoord\n * https://jsrepo.dev/\n * https://github.com/DavidHDev/react-bits\n * https://www.npmjs.com/package/fs-extra\n * https://www.npmjs.com/package/keytar\n * https://www.npmjs.com/package/archiver\n * https://www.npmjs.com/package/wcwidth","routePath":"/mark/","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"编程词汇","content":"#\n\n\nA#\n\n英文                                   译法 1        译法 2   译法 3\na block of pointers                  一块指针        一组指针   \nabbreviation                         缩略语                \nabstract                             抽象的                \nabstract syntax tree, AST            抽象语法树              \nabstraction                          抽象                 \nabstraction barrier                  抽象屏障        抽象阻碍   \nabstraction of function calls        函数调用抽象             \naccess                               访问          存取     \naccess function                      访问函数        存取函数   \naccumulator                          累加器                \nactivate                             激活                 \nad hoc                               专设                 \nadapter                              适配器                \naddress                              地址                 \nalgebraic data type                  代数数据类型             \nalgorithm                            算法                 \nalias                                别名                 \nallocate                             分配          配置     \nalternative                          备选                 \namortized analysis                   平摊分析               \nanaphoric                            指代                 \nannotation                           注解                 \nanonymous function                   匿名函数               \nantecedent                           前提          前件     先决条件\nappend                               追加          拼接     \napplication                          应用          应用程序   \napplication framework                应用框架               \napplication program interface, API   应用程序编程接口           \napplication service provider, ASP    应用程序服务提供商          \napplicative                          应用序                \nargument                             参数          自变量    实际参数/实参\narithmetic                           算术                 \narray                                数组                 \nartificial intelligence, AI          人工智能               \nassemble                             组合                 \nassembly                             汇编                 \nassignment                           赋值                 \nassignment operator                  赋值操作符              \nassociated                           关联的                \nassociation list, alist              关联列表               \natom                                 原子                 \natomic                               原子的                \natomic value                         原子型值               \nattribute                            属性          特性     \naugmented                            扩充                 \nautomatic memory management          自动内存管理             \nautomatically infer                  自动推导               \nautometa theory                      自动机理论              \nauxiliary                            辅助                 \n\n\nB#\n\n英文                          译法 1      译法 2     译法 3\nbackquote                   反引用                \nbacktrace                   回溯                 \nbackward compatible         向下兼容               \nbandwidth                   带宽                 \nbase case                   基本情形               \nbase class                  基类                 \nBayes' theorem              贝叶斯定理              \nbest viable function        最佳可行函式    最佳可行函数   \nBezier curve                贝塞尔曲线              \nbignum                      大数                 \nbinary operator             二元操作符              \nbinary search               二分查找      二分搜索     二叉搜索\nbinary search tree          二叉搜索树              \nbinary tree                 二叉树                \nbinding                     绑定                 \nbinding vector              绑定向量               \nbit                         位         比特       \nbit manipulation            位操作                \nblack box abstraction       黑箱抽象               \nblock                       块         区块       \nblock structure             块结构       区块结构     \nblock name                  代码块名字              \nBlub paradox                Blub 困境            \nbody                        体         主体       \nboilerplate                 公式化       样板       \nbookkeeping                 簿记                 \nboolean                     布尔                 \nborder                      边框                 \nbottom-up design            自底向上的设计            \nbottom-up programming       自底向上编程             \nbound                       边界                 \nbounds checking             边界检查               \nbox notation                箱子表示法              \nbrace                       花括弧       花括号      \nbracket                     方括弧       方括号      \nbranch                      分支        跳转       \nbreadth-first               广度优先               \nbreadth-first search, BFS   广度优先搜索             \nbreakpoint                  断点                 \nbrevity                     简洁                 \nbuffer                      缓冲区                \nbuffer overflow attack      缓冲区溢出攻击            \nbug                         臭虫                 \nbuilding                    创建                 \nbuilt-in                    内置                 \nbyte                        字节                 \nbytecode                    字节码                \n\n\nC#\n\n英文                                译法 1               译法 2      译法 3\ncache                             缓存                           \ncall                              调用                           \ncallback                          回调                           \nCamelCase                         驼峰式大小写                       \ncandidate function                候选函数                         \ncapture                           捕捉                           \ncase                              分支                           \ncharacter                         字符                           \nchecksum                          校验和                          \nchild class                       子类                           \nchoke point                       滞塞点                          \nchunk                             块                            \ncircular definition               循环定义                         \nclarity                           清晰                           \nclass                             类                  类别        \nclass declaration                 类声明                          \nclass library                     类库                           \nclient                            客户                 客户端       \nclipboard                         剪贴板                          \nclone                             克隆                           \nclosed world assumption           封闭世界假定                       \nclosure                           闭包                           \nclutter                           杂乱                           \ncode                              代码                           \ncode bloat                        代码膨胀                         \ncollection                        收集器                复合类型      \ncolumn                            行                  栏         \ncolumn-major order                行主序                          \ncomma                             逗号                           \ncommand-line                      命令行                          \ncommand-line interface, CLI       命令行界面                        \nCommon Lisp Object System, CLOS   Common Lisp 对象系统             \nCommon Gateway Interface, CGI     通用网关接口                       \ncompatible                        兼容                           \ncompilation                       编译                           \ncompilation parameter             编译参数                         \ncompile                           编译                           \ncompile inline                    内联编译                         \ncompile time                      编译期                          \ncompiled form                     编译后的形式                       \ncompiler                          编译器                          \ncomplex                           复杂                           \ncomplexity                        复杂度                          \ncompliment                        补集                           \ncomponent                         组件                           \ncomposability                     可组合性                         \ncomposition                       组合                 组合函数      \ncompound value                    复合数据               复合值       \ncompression                       压缩                           \ncomputation                       计算                           \ncomputer                          计算机                          \nconcatenation                     串接                           \nconcept                           概念                           \nconcrete                          具体                           \nconcurrency                       并发                           \nconcurrent                        并发                           \nconditional                       条件式                          \nconditional variable              条件变量                         \nconfiguration                     配置                           \nconnection                        连接                           \ncons                              构造                           \ncons cell                         构元                 cons 单元   \nconsequent                        结果                 推论        \nconsistent                        一致性                          \nconstant                          常量                           \nconstraint                        约束                           \nconstraint programming            约束式编程                        \ncontainer                         容器                           \ncontent-based filtering           基于内容的过滤                      \ncontext                           上下文                语境        环境\ncontinuation                      延续性                          \ncontinuous integration, CI        持续集成                         \ncontrol                           控件                           \ncooperative multitasking          协作式多任务                       \ncopy                              拷贝                           \ncorollary                         推论                           \ncoroutine                         协程                           \ncorruption                        程序崩溃                         \ncrash                             崩溃                           \ncreate                            创建                           \ncrystallize                       固化                           \ncurly                             括弧状的                         \ncurried                           柯里的                          \ncurrying                          柯里化                          \ncursor                            光标                           \ncurvy                             卷曲的                          \ncycle                             周期                           \n\n\nD#\n\n英文                                                 译法 1           译法 2     译法 3\ndangling pointer                                   迷途指针           野指针      \nDefense Advanced Research Projects Agency, DARPA   美国国防部高级研究计划局            \ndata                                               数据                      \ndata structure                                     数据结构                    \ndata type                                          数据类型                    \ndata-driven                                        数据驱动                    \ndatabase                                           数据库                     \ndatabase schema                                    数据库模式                   \ndatagram                                           数据报文                    \ndead lock                                          死锁                      \ndebug                                              调试                      \ndebugger                                           调试器                     \ndebugging                                          调试                      \ndeclaration                                        声明                      \ndeclaration forms                                  声明形式                    \ndeclarative                                        声明式            说明式      \ndeclarative knowledge                              声明式知识          说明式知识    \ndeclarative programming                            声明式编程          说明式编程    \ndeclarativeness                                    可声明性                    \ndeclaring                                          声明                      \ndeconstruction                                     解构                      \ndeduction                                          推导             推断       \ndefault                                            缺省             默认       \ndefer                                              推迟                      \ndeficiency                                         缺陷             不足       \ndefine                                             定义                      \ndefinition                                         定义                      \ndelegate                                           委托                      \ndelegation                                                                 \ndellocate                                          释放                      \ndemarshal                                          散集                      \ndeprecated                                         废弃                      \ndepth-first                                        深度优先                    \ndepth-first search, DFS                            深度优先搜索                  \nderived                                            派生                      \nderived class                                      派生类                     \ndesign pattern                                     设计模式                    \ndesignator                                         指示符                     \ndestructive                                        破坏性的                    \ndestructive function                               破坏性函数                   \ndestructuring                                      解构                      \ndevice driver                                      硬件驱动程序                  \ndimensions                                         维度                      \ndirective                                          指令                      \ndirective                                          指示符                     \ndirectory                                          目录                      \ndisk                                               盘                       \ndispatch                                           分派             派发       \ndistributed computing                              分布式计算                   \nDLL hell                                           DLL 地狱                  \ndocument                                           文档                      \ndotted list                                        点状列表                    \ndotted-pair notation                               带点尾部表示法        带点尾部记法   \nduplicate                                          复本                      \ndynamic binding                                    动态绑定                    \ndynamic extent                                     动态范围                    \ndynamic languages                                  动态语言                    \ndynamic scope                                      动态作用域                   \ndynamic type                                       动态类型                    \n\n\nE#\n\n英文                        译法 1    译法 2   译法 3\neffect                    效果             \nefficiency                效率             \nefficient                 高效             \nelaborate                                \nelucidating                              \nembedded language         嵌入式语言          \nemulate                   仿真             \nencapsulation             封装             \nenum                      枚举             \nenumeration type          枚举类型           \nenumrators                枚举器            \nenvironment               环境             \nequal                     相等             \nequality                  相等性            \nequation                  方程             \nequivalence               等价性            \nerror message             错误信息           \nerror-checking            错误检查           \nescaped                   逃脱      溢出     \nescape character          转义字符           \nevaluate                  求值      评估     \nevaluation                求值             \nevent                     事件             \nevent driven              事件驱动           \nexception                 异常             \nexception handling        异常处理           \nexception specification   异常规范           \nexit                      退出             \nexpendable                可扩展的           \nexplicit                  显式             \nexploratory programming   探索式编程          \nexport                    导出      引出     \nexpression                表达式            \nexpressive power          表达能力           \nextensibility             可扩展性           \nextent                    范围      程度     \nexternal representation   外部表示法          \nextreme programming       极限编程           \n\n\nF#\n\n英文                        译法 1     译法 2     译法 3\nfactorial                 阶乘                \nfamily                    （类型的）系            \nfeasible                  可行的               \nfeature                   特色                \nfield                     字段       栏位       \nfile                      文件                \nfile handle               文件句柄              \nfill pointer              填充指针              \nfineo-grained             细粒度               \nfirmware                  固件                \nfirst-class               第一类的     第一级的     一等的\nfirst-class function      第一级函数    第一类函数    一等函数\nfirst-class object        第一类的对象   第一级的对象   一等公民\nfixed-point               不动点               \nfixnum                    定长数      定点数      \nflag                      标记                \nflash                     闪存                \nflexibility               灵活性               \nfloating-point            浮点数               \nfloating-point notation   浮点数表示法            \nflush                     刷新                \nfold                      折叠                \nfont                      字体                \nforce                     迫使                \nform                      形式                \nform                      表单                \nformal parameter          形参                \nformal relation           形式关系              \nforward                   转发                \nforward references                          \nfractal                   分形                \nfractions                 派系                \nframework                 框架                \nfreeware                  自由软件              \nfunction                  函数                \nfunction literal          函数字面常量            \nfunction object           函数对象              \nfunctional arguments      函数型参数             \nfunctional programming    函数式编程             \nfunctionality             功能性               \n\n\nG#\n\n英文                              译法 1       译法 2   译法 3\ngame                            游戏                \ngarbage                         垃圾                \ngarbage collection              垃圾回收              \ngarbage collector               垃圾回收器             \ngeneralized                     泛化                \ngeneralized variable            广义变量              \ngenerate                        生成                \ngenerator                       生成器               \ngeneric                         通用的        泛化的    \ngeneric algorithm               通用算法       泛型算法   \ngeneric function                通用函数              \ngeneric programming             通用编程       泛型编程   \ngenrative programming           生产式编程             \nglobal                          全局的               \nglobal declaration              全局声明              \nglue program                    胶水程序              \ngoto                            跳转                \ngraphical user interface, GUI   图形用户界面            \ngreatest common divisor         最大公因数             \nGreenspun's tenth rule          格林斯潘第十定律          \n\n\nH#\n\n英文                                  译法 1      译法 2   译法 3\nhack                                破解               \nhacker                              黑客               \nhandle                              处理器       处理程序   句柄\nhard disk                           硬盘               \nhard-wire                                            \nhardware                            硬件               \nhash tables                         哈希表       散列表    \nheader                              头部               \nheader file                         头文件              \nheap                                堆                \nhelper                              辅助函数      辅助方法   \nheuristic                           启发式              \nhigh-order                          高阶               \nhigher-order function               高阶函数             \nhigher-order procedure              高阶过程             \nhyperlink                           超链接              \nHyperText Markup Language, HTML     超文本标记语言          \nHyperText Transfer Protocol, HTTP   超文本传输协议          \n\n\nI#\n\n英文                                    译法 1      译法 2   译法 3\nidentical                             一致               \nidentifier                            标识符              \nidentity                              同一性              \nill type                              类型不正确            \nillusion                              错觉               \nimperative                            命令式              \nimperative programming                命令式编程            \nimplement                             实现               \nimplementation                        实现               \nimplicit                              隐式               \nimport                                导入               \nincremental testing                   增量测试             \nindent                                缩排        缩进     \nindentation                           缩排        缩进     \nindented                              缩排        缩进     \nindention                             缩排        缩进     \ninfer                                 推导               \ninfinite loop                         无限循环             \ninfinite recursion                    无限递归             \ninfinite precision                    无限精度             \ninfix                                 中序               \ninformation                           信息               \ninformation technology, IT            信息技术             \ninheritance                           继承               \ninitialization                        初始化              \ninitialize                            初始化              \ninline                                内联               \ninline expansion                      内联展开             \ninner class                           内嵌类              \ninner loop                            内层循环             \ninput                                 输入               \ninstances                             实例               \ninstantiate                           实例化              \ninstructive                           教学性的             \ninstrument                            记录仪              \ninteger                               整数               \nintegrate                             集成               \ninteractive language                  交互式语言            \ninteractive programming environment   交互式编程环境          \ninteractive testing                   交互式测试            \ninteracts                             交互               \ninterface                             接口               \nintermediate form                     过渡形式      中间形式   \ninternal                              内部               \ninternet                              互联网       因特网    \ninterpolation                         插值               \ninterpret                             解释               \ninterpreter                           解释器              \ninterrupt                             中止        中断     \nintersection                          交集               \ninter-process communication, IPC      进程间通信            \ninvariants                            约束条件             \ninvoke                                调用               \nitem                                  项                \niterate                               迭代               \niteration                             迭代的              \niterative                             迭代的              \niterator                              迭代器              \n\n\nJ#\n\n英文                          译法 1     译法 2   译法 3\njagged                      锯齿状的            \njob control language, JCL   作业控制语言          \njudicious                   明智的             \n\n\nK#\n\n英文                 译法 1    译法 2   译法 3\nkernel             核心             \nkernel language    核心语言           \nkeyword argument   关键字参数          \nkeywords           关键字            \nkludge             蹩脚             \n\n\nL#\n\n英文                                译法 1        译法 2     译法 3\nlambda calculus                   lambda 演算            \nlarval startup                    雏形创业公司               \nlaser                             激光                   \nlatitude                                               \nlayout                            版型                   \nlazy                              惰性                   \nlazy evaluation                   惰性求值                 \nlegacy software                   历史遗留软件               \nleverage                          杠杆          (动词)利用   \nlexical                           词法的                  \nlexical analysis                  词法分析                 \nlexical closure                   词法闭包                 \nlexical scope                     词法作用域                \nLanguage For Smart People, LFSP   聪明人的语言               \nlibrary                           库           函数库      函式库\nlifetime                          生命期                  \nlinear iteration                  线性迭代                 \nlinear recursion                  线性递归                 \nlink                              链接          连接       \nlinker                            连接器                  \nlist                              列表                   \nlist operation                    列表操作                 \nliteral                           字面                   \nliteral constant                  字面常量                 \nliteral representation            字面量                  \nload                              装载          加载       \nloader                            装载器         加载器      \nlocal                             局部的         局域的      \nlocal declarations                局部声明                 \nlocal function                    局部函数        局域函数     \nlocal variable                    局部变量        局域变量     \nlocality                          局部性                  \nloop                              循环                   \nlvalue                            左值                   \n\n\nM#\n\n英文                              译法 1      译法 2     译法 3\nmachine instruction             机器指令               \nmachine language                机器语言               \nmachine language code           机器语言代码             \nmachine learning                机器学习               \nmacro                           宏                  \nmailing list                    邮件列表               \nmainframes                      大型机                \nmaintain                        维护                 \nmanifest typing                 显式类型               \nmanipulator                     操纵器                \nmapping                         映射                 \nmapping functions               映射函数               \nmarshal                         列集                 \nmath envy                       对数学家的妒忌            \nmember                          成员                 \nmemorizing                      记忆化                \nmemory                          内存                 \nmemory allocation               内存分配               \nmemory leaks                    内存泄漏               \nmenu                            菜单                 \nmessage                         消息                 \nmessage-passing                 消息传递               \nmeta-                           元-                 \nmeta-programming                元编程                \nmetacircular                    元循环                \nmethod                          方法                 \nmethod combination              方法组合      方法组合机制   \nmicro                           微                  \nmiddleware                      中间件                \nmigration                       （数据库）迁移            \nminimal network                 最小网络               \nmirror                          镜射                 \nmismatch type                   类型不匹配              \nmodel                           模型                 \nmodem                           调制解调器              \nmodifier                        修饰符                \nmodularity                      模块性                \nmodule                          模块                 \nmonad                           单子                 \nmonkey patch                    猴子补丁               \nmonomorphic type language       单型语言               \nMoore's law                     摩尔定律               \nmouse                           鼠标                 \nmulti-task                      多任务                \nmultiple values                 多值                 \nmutable                         可变的                \nmutex                           互斥锁                \nMultiple Virtual Storage, MVS   多重虚拟存储             \n\n\nN#\n\n英文                            译法 1      译法 2   译法 3\nnamespace                     命名空间             \nnative                        本地的              \nnative code                   本地码              \nnatural language              自然语言             \nnatural language processing   自然语言处理           \nnested                        嵌套               \nnested class                  嵌套类              \nnetwork                       网络               \nnewline                       换行        新行     \nnon-deterministic choice      非确定性选择           \nnon-strict                    非严格              \nnon-strict evaluation         非严格求值            \nnondeclarative                                 \nnondestructive version        非破坏性的版本          \nnumber crunching              数字密集运算           \n\n\nO#\n\n英文                            译法 1      译法 2   译法 3\nobject                        对象               \nobject code                   目标代码             \nobject-oriented               面向对象             \nobject-oriented programming   面向对象编程           \nOccam's razor                 奥卡姆剃刀原则          \non the fly                    运行中       执行时    \nonline                        在线               \nopen source                   开放源码             \noperand                       操作对象             \noperating system, OS          操作系统             \noperation                     操作               \noperator                      操作符              \noptimization                  优化               \noptimization of tail calls    尾调用优化            \noption                        选项               \noptional                      可选的       选择性的   \noptional argument             选择性参数            \nordinary                      常规的              \northogonality                 正交性              \noverflow                      溢出               \noverhead                      额外开销             \noverload                      重载               \noverride                      覆写               \n\n\nP#\n\n英文                             译法 1     译法 2      译法 3\npackage                        包                  \npair                           点对                 \npalindrome                     回文                 \nparadigm                       范式                 \nparallel                       并行                 \nparallel computer              并行计算机              \nparam                          参数                 \nparameter                      参数       形式参数/形参   \nparen-matching                 括号匹配               \nparent class                   父类                 \nparentheses                    括号                 \nParkinson's law                帕金森法则              \nparse                          解析                 \nparse tree                     解析树      分析树       \nparser                         解析器                \npartial application            部分应用               \npartial applied                分步代入的              \npartial function application   部分函数应用             \nparticular ordering            部分有序               \npass by adress                 按址传递     传址        \npass by reference              按引用传递    传引用       \npass by value                  按值传递     传值        \npath                           路径                 \npattern                        模式                 \npattern match                  模式匹配               \nperform                        执行                 \nperformance                    性能                 \nperformance-critical                              \npersistence                    持久性                \nphrenology                     相面                 \nphysical                       物理的                \npipe                           管道                 \npixel                          像素                 \nplaceholder                    占位符                \nplanning                       计划                 \nplatform                       平台                 \npointer                        指针                 \npointer arithmetic             指针运算               \npoll                           轮询                 \npolymorphic                    多态                 \npolymorphism                   多态                 \npolynomial                     多项式的               \npool                           池                  \nport                           端口                 \nportable                       可移植性               \nportal                         门户                 \npositional parameters          位置参数               \npostfix                        后序                 \nprecedence                     优先级                \nprecedence list                优先级列表              \npreceding                      前述的                \npredicate                      判断式      谓词        \npreemptive multitasking        抢占式多任务             \npremature design               过早设计               \npreprocessor                   预处理器               \nprescribe                      规定                 \nprime                          素数                 \nprimitive                      原语                 \nprimitive recursive            主递归                \nprimitive type                 原生类型               \nprincipal type                 主要类型               \nprint                          打印                 \nprinted representation         打印表示法              \nprinter                        打印机                \npriority                       优先级                \nprocedure                      过程                 \nprocedurual                    过程化的               \nprocedurual knowledge          过程式知识              \nprocess                        进程                 \nprocess priority               进程优先级              \nproductivity                   生产力                \nprofile                        评测                 \nprofiler                       评测器      性能分析器     \nprogrammer                     程序员                \nprogramming                    编程                 \nprogramming language           编程语言               \nproject                        项目                 \nprompt                         提示符                \nproper list                    正规列表               \nproperty                       属性                 \nproperty list                  属性列表               \nprotocol                       协议                 \nprototype                      原型                 \npseudo code                    伪码                 \npseudo instruction             伪指令                \npurely functional language     纯函数式语言             \npushdown stack                 下推栈                \n\n\nQ#\n\n英文                      译法 1   译法 2   译法 3\nqualified               修饰的    带前缀的   \nqualifier               修饰符           \nquality                 质量            \nquality assurance, QA   质量保证          \nquery                   查询            \nquery language          查询语言          \nqueue                   队列            \nquote                   引用            \nquoted form             引用形式          \n\n\nR#\n\n英文                                           译法 1         译法 2   译法 3\nrace condition                               条件竞争         竞态条件   \nradian                                       弧度                  \nRedundant Array of Independent Disks, RAID   冗余独立磁盘阵列            \nraise                                        引起                  \nrandom number                                随机数                 \nrange                                        范围           区间     \nrank                                         （矩阵）秩        排名     \nrapid prototyping                            快速原型开发              \nrational database                            关系数据库               \nraw                                          未经处理的               \nread                                         读取                  \nread-evaluate-print loop, REPL               读取-求值-打印循环          \nread-macro                                   读取宏                 \nrecord                                       记录                  \nrecursion                                    递归                  \nrecursive                                    递归的                 \nrecursive case                               递归情形                \nrefactor                                     重构                  \nrefer                                        参考                  \nreference                                    引用           参考     \nreferential transparency                     引用透明                \nrefine                                       精化                  \nreflection                                   反射           映像     \nregister                                     寄存器                 \nregistry creep                               注册表蠕变               \nregular expression                           正则表达式               \nrepresent                                    表现                  \nrequest                                      请求                  \nresolution                                   解析度                 \nresolve                                      解析                  \nrest parameter                               剩余参数                \nreturn                                       返回           回车     \nreturn value                                 返回值                 \nreuse of software                            代码重用                \nright associative                            右结合                 \nReduced Instruction Set Computer, RISC       精简指令系统计算机           \nrobust                                       健壮                  \nrobustness                                   健壮性          鲁棒性    \nroutine                                      例程                  \nrouting                                      路由                  \nrow-major order                              列主序                 \nremote procedure call, RPC                   远程过程调用              \nrun-length encoding                          游程编码                \nrun-time typing                              运行期类型               \nruntime                                      运行期                 \nrvalue                                       右值                  \n\n\nS#\n\n英文                                 译法 1            译法 2    译法 3\nS-expression                       S-表达式                   \nsave                               储存                      \nSecure Sockets Layer, SSL          安全套接字层                  \nscaffold                           脚手架             鹰架      \nscalar type                        标量                      \nscan                               扫描                      \nschedule                           调度                      \nscheduler                          调度程序                    \nscope                              作用域                     \nSCREAMING_SNAKE_CASE               尖叫式蛇底大写                 \nscreen                             屏幕                      \nscripting language                 脚本语言                    \nsearch                             查找              搜寻      \nsegment of instructions            指令片段                    \nsemantics                          语义                      \nsemaphore                          信号量                     \nsemicolon                          分号                      \nsequence                           序列                      \nsequential                         循序的             顺序的     \nsequential collection literals                             \nserial                             串行                      \nserialization                      序列化                     \nseries                             串行              级数      \nserver                             服务器                     \nshadowing                          隐蔽了                     \nsharp                              犀利的                     \nsharp-quote                        升引号                     \nshortest path                      最短路径                    \nSICP                               《计算机程序的构造与解释》           \nside effect                        副作用                     \nsignature                          签名                      \nsimple vector                      简单向量                    \nsimulate                           模拟                      \nSingle Point of Truth, SPOT        真理的单点性                  \nsingle-segment                     单段的                     \nsketch                             草图              初步框架    \nslash                              斜线                      \nslot                               槽                       \nsmart pointer                      智能指针                    \nsnake_case                         蛇底式小写                   \nsnapshot                           屏幕截图                    \nsocket                             套接字                     \nsoftware                           软件                      \nsolution                           方案                      \nsource code                        源代码                     \nspace leak                         内存泄漏                    \nspaghetti                          面条式代码           意面式代码   \nspaghetti stack                    意面式栈            面条式栈    \nspam                               垃圾邮件                    \nspec                               规格                      \nspecial form                       特殊形式                    \nspecial variable                   特殊变量                    \nspecialization                     特化                      \nspecialize                         特化                      \nspecialized array                  特化数组                    \nspecification                      规格说明            规范      \nsplitter                           切分窗口                    \nsprite                             精灵图                     \nsquare                             平方                      \nsquare root                        平方根                     \nsquash                             碰撞                      \nstack                              栈                       \nstack frame                        栈帧                      \nstakeholder                                                \nstandard library                   标准函式库                   \nstate machine                      状态机                     \nstatement                          陈述              语句      \nstatic type                        静态类型                    \nstatic type system                 静态类型系统                  \nstatus                             状态                      \nstore                              保存                      \nstream                             流                       \nstrict                             严格                      \nstrict evaluation                  严格求值                    \nstring                             字串              字符串     \nstring template                    字串模版                    \nstrong type                        强类型                     \nstructural recursion               结构递归                    \nstructured values                  结构型值                    \nsubroutine                         子程序                     \nsubset                             子集                      \nsubstitution                       代换                      \nsubstitution model                 代换模型                    \nsubtype                            子类型                     \nsuperclass                         基类                      \nsuperfluous                        多余的                     \nsupertype                          超集                      \nsupport                            支持                      \nsuspend                            挂起                      \nswapping values                    交换变量的值                  \nsymbol                             符号                      \nsymbolic computation               符号计算                    \nsyntax                             语法                      \nsystem administrator               系统管理员                   \nsystem administrator disease       系统管理员综合症                \nSystem Network Architecture, SNA   系统网络体系                  \n\n\nT#\n\n英文                   译法 1          译法 2   译法 3\n(database)table      数据表                  \ntable                表格                   \ntag                  标签            标记     \ntail-recursion       尾递归                  \ntail-recursive       尾递归的                 \nTAOCP                《计算机程序设计艺术》          \ntarget               目标                   \ntaxable operators    需节制使用的操作符            \ntaxonomy             分类法                  \ntemplate             模版                   \ntemporary object     临时对象                 \ntesting              测试                   \ntext                 文本                   \ntext file            文本文件                 \nthread               线程                   \nthread safe          线程安全                 \nthree-valued logic   三值逻辑                 \nthrow                抛出            丢掷     引发\nthrowaway program    一次性程序                \ntimestamp            时间戳                  \ntoken                词法记号          语义单位   语元\ntop-down design      自顶向下的设计              \ntop-level            顶层                   \ntrace                追踪                   \ntrailing space       行尾空白                 \ntransaction          事务                   \ntransition network   转移网络                 \ntransparent          透明的                  \ntraverse             遍历                   \ntree                 树                    \ntree recursion       树形递归                 \ntrigger              触发器                  \ntuple                元组                   \nTuring machine       图灵机                  \nTuring complete      图灵完备                 \ntypable              类型合法                 \ntype                 类型                   \ntype constructor     类构造器                 \ntype declaration     类型声明                 \ntype hierarchy       类型层级                 \ntype inference       类型推导                 \ntype name            类型名                  \ntype safe            类型安全                 \ntype signature       类型签名                 \ntype synonym         类型别名                 \ntype variable        类型变量                 \ntyping               类型指派          输入     \n\n\nU#\n\n英文                              译法 1      译法 2   译法 3\nuser interface, UI              用户界面             \nunary                           一元的              \nunderflow                       下溢               \nunification                     合一        统一     \nunion                           并集               \nuniversally quantify            全局量化             \nunqualfied                      未修饰的             \nunwinding                                        \nuptime                          运行时间             \nUniform Resource Locator, URL   统一资源定位符          \nuser                            用户               \nutilities                       实用函数             \n\n\nV#\n\n英文                       译法 1    译法 2   译法 3\nvalidate                 验证             \nvalidator                验证器            \nvalue constructor        值构造器           \nvaporware                朦胧件            \nvariable                 变量             \nvariable capture         变量捕捉           \nvariadic input           可变输入           \nvariant                  变种             \nventure capitalist, VC   风险投资商          \nvector                   向量             \nviable function          可行函数           \nvideo                    视频             \nview                     视图             \nvirtual function         虚函数            \nvirtual machine          虚拟机            \nvirtual memory           虚内存            \nvolatile                 挥发             \nvowel                    元音             \n\n\nW#\n\n英文                                       译法 1    译法 2   译法 3\nwarning message                          警告信息           \nweb server                               网络服务器          \nweight                                   权值      权重     \nwell type                                类型正确           \nwildcard                                 通配符            \nwindow                                   窗口             \nword                                     单词      字      \nwrapper                                  包装器     包装     \nWhat You See Is What You Get, WYSIWYG    所见即所得          \nWhat You See Is What You Want, WYSIWYW   所见即所想          \n\n\nX#\n\n\nY#\n\n英文             译法 1   译法 2   译法 3\nY combinator   Y组合子          \n\n\nZ#\n\n英文             译法 1    译法 2   译法 3\nZ-expression   Z-表达式          \nzero-indexed   零索引的           \n\n\n专业名词#\n\n英文                      译法 1   译法 2   译法 3\nThe Paradox of Choice   选择谬论          \n\n> 文章来源：https://github.com/JuanitoFatas/Computer-Science-Glossary/blob/master/dic\n> t.textile","routePath":"/mark/word","lang":"","toc":[{"text":"A","id":"a","depth":2,"charIndex":3},{"text":"B","id":"b","depth":2,"charIndex":2874},{"text":"C","id":"c","depth":2,"charIndex":5192},{"text":"D","id":"d","depth":2,"charIndex":10836},{"text":"E","id":"e","depth":2,"charIndex":15406},{"text":"F","id":"f","depth":2,"charIndex":17054},{"text":"G","id":"g","depth":2,"charIndex":18920},{"text":"H","id":"h","depth":2,"charIndex":20001},{"text":"I","id":"i","depth":2,"charIndex":21039},{"text":"J","id":"j","depth":2,"charIndex":24353},{"text":"K","id":"k","depth":2,"charIndex":24543},{"text":"L","id":"l","depth":2,"charIndex":24763},{"text":"M","id":"m","depth":2,"charIndex":26736},{"text":"N","id":"n","depth":2,"charIndex":29294},{"text":"O","id":"o","depth":2,"charIndex":30072},{"text":"P","id":"p","depth":2,"charIndex":31234},{"text":"Q","id":"q","depth":2,"charIndex":35732},{"text":"R","id":"r","depth":2,"charIndex":36132},{"text":"S","id":"s","depth":2,"charIndex":39244},{"text":"T","id":"t","depth":2,"charIndex":45074},{"text":"U","id":"u","depth":2,"charIndex":47152},{"text":"V","id":"v","depth":2,"charIndex":47812},{"text":"W","id":"w","depth":2,"charIndex":48601},{"text":"X","id":"x","depth":2,"charIndex":49238},{"text":"Y","id":"y","depth":2,"charIndex":49243},{"text":"Z","id":"z","depth":2,"charIndex":49313},{"text":"专业名词","id":"专业名词","depth":2,"charIndex":49416}],"frontmatter":{},"version":""},{"title":"Client","content":"#\n\nnpm install --save @apollo/client graphql\n\n\n\nClient#\n\n\n\nconst client = new ApolloClient({\n  uri: \"http://localhost:4000\",\n  cache: new InMemoryCache(),\n  defaultOptions: {\n    watchQuery: {\n      fetchPolicy: \"no-cache\",\n      errorPolicy: \"ignore\",\n    },\n    query: {\n      fetchPolicy: \"no-cache\",\n      errorPolicy: \"all\",\n    },\n  },\n});\n\nexport default client;\n\n\n\nApolloProvider#\n\nrender(\n  <ApolloProvider client={client}>\n    <Provider store={store}>\n      <Router />\n    </Provider>\n  </ApolloProvider>,\n  document.getElementById(\"app\")\n);\n\n\n\nMutation#\n\n\n\n\n\n// graphql부분(1)\nconst ADD_USER = gql`\n  mutation AddUser($first: String, $last: String, $email: String) {\n    addUser(first: $first, last: $last, email: $email) {\n      email\n    }\n  }\n`;\n\nconst Page = () => {\n  const [resetKey, setResetKey] = useState(0);\n  // graphql부분(2)\n  const [addUser, { data }] = useMutation(ADD_USER);\n\n  const onFinish = ({ first, last, email }) => {\n    // graphql부분(3)\n    addUser({ variables: { first, last, email } });\n    setResetKey(resetKey + 1);\n  };\n  return (\n    <Form\n      onFinish={onFinish}\n      labelCol={{ span: 4 }}\n      wrapperCol={{ span: 20 }}\n      initialValues={{\n        first: `dao${new Date().getTime()}`,\n        last: `lang${new Date().getTime()}`,\n        email: `daolang${new Date().getTime()}@gmail.com`,\n      }}\n      key={resetKey}\n    >\n      <Form.Item\n        name=\"first\"\n        label=\"first\"\n      >\n        <Input />\n      </Form.Item>\n      <Form.Item\n        name=\"last\"\n        label=\"last\"\n      >\n        <Input />\n      </Form.Item>\n      <Form.Item\n        name=\"email\"\n        label=\"Email\"\n      >\n        <Input />\n      </Form.Item>\n      <Form.Item>\n        <Button\n          type=\"primary\"\n          htmlType=\"submit\"\n        >\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  );\n};\n\nexport default Page;\n\n\nQuery\n\n\n\n\n\n\n\n// graphql(1)\nconst GET_USERS = gql`\n  query Users {\n    users {\n      key: _id\n      name {\n        first\n        last\n      }\n      email\n    }\n  }\n`;\n\nconst columns = [\n  {\n    title: \"Id\",\n    dataIndex: \"key\",\n    key: \"key\",\n  },\n  {\n    title: \"First\",\n    dataIndex: \"name\",\n    key: \"name\",\n    render: (item) => item.first,\n  },\n  {\n    title: \"Last\",\n    dataIndex: \"name\",\n    key: \"name\",\n    render: (item) => item.first,\n  },\n  {\n    title: \"Email\",\n    dataIndex: \"email\",\n    key: \"email\",\n  },\n];\n\nconst Page = () => {\n  // graphql(2)\n  const { loading, error, data } = useQuery(GET_USERS);\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error :(</p>;\n\n  return (\n    <div>\n      <Table\n        columns={columns}\n        dataSource={data.users}\n      />\n    </div>\n  );\n};\n\nexport default Page;\n","routePath":"/note/graphql/client","lang":"","toc":[{"text":"Client","id":"client-1","depth":3,"charIndex":-1},{"text":"ApolloProvider","id":"apolloprovider","depth":3,"charIndex":372},{"text":"Mutation","id":"mutation","depth":3,"charIndex":554}],"frontmatter":{},"version":""},{"title":"GraphQL","content":"#\n\n * GraphQL 是一种协议和一种 API 查询语言(实现数据查询的 runtime), 通常基于 http 协议\n * GraphQL 是客户端和服务器之间通信的规范。\n\n\n优点#\n\n\n1.提高开发速度#\n\n * 可以减少发出请求\n * 单个调用来获取所需数据\n * 减少延迟， 还能降低服务器的压力\n * GraphQL 具有自文档的特点\n\n\n2.提升开发者体验#\n\n * 更少的时间思考如何获取数据\n * 在使用 Apollo 时，只需要在 UI 中声明数据\n * 数据和 UI 放在一起，阅读代码和编写代码都变得更方便了\n * GraphQL 之于数据， 就如 React 之于 UI\n\n\n3.将复杂的 API 进行简化和标准化#\n\n * 可以按照需求自由组合和嵌套对象\n * 对于每个对象都能够获得所需的数据，不多也不少\n\n\n4.提升安全性#\n\n * 需要进行 schema 验证，而且是强类型的，因为这是它规范的一部分。\n * 它可以频繁更新，而不会因为引入了新类型造成重大变更。\n\n\n设计原则#\n\n * 分层(查询字段层次分明。字段嵌套在其他字段当中，查询字段的结构与其返回的数据结构相似)\n * 以产品为中心(客户端所需的数据，以及客户端支持的语言和 runtime)\n * 强类型(每个数据点在模版当中都有其特定的类型，并且均会进行验证)\n * 客户端指定查询(服务器提供功能供客户端使用)\n * 类型自查(能够查询 GraphQL 服务器的类型检测系统)\n\n\nREST 缺点#\n\n * 过量获取\n * 缺乏灵活性\n\n\n术语#\n\n * SEQL(Structured English Query Language) - 结构化英文查询语言\n * SQL(Structured Query Language) - 结构化查询语言\n * SDL(Schema Definition Language) - 模版定义语言\n * scalar type - 标量类型（String, Int, Boolean, ID, Float）\n * ID(Identity Document)","routePath":"/note/graphql/","lang":"","toc":[{"text":"优点","id":"优点","depth":2,"charIndex":92},{"text":"1.提高开发速度","id":"1提高开发速度","depth":3,"charIndex":98},{"text":"2.提升开发者体验","id":"2提升开发者体验","depth":3,"charIndex":178},{"text":"3.将复杂的 API 进行简化和标准化","id":"3将复杂的-api-进行简化和标准化","depth":3,"charIndex":303},{"text":"4.提升安全性","id":"4提升安全性","depth":3,"charIndex":372},{"text":"设计原则","id":"设计原则","depth":2,"charIndex":453},{"text":"REST 缺点","id":"rest-缺点","depth":2,"charIndex":644},{"text":"术语","id":"术语","depth":2,"charIndex":673}],"frontmatter":{},"version":""},{"title":"Query","content":"#\n\n\n工具#\n\n 1. GraphiQL (http://snowtooth.herokuapp.com/graphql)\n\n 2. GraphQL Playground (https://www.graphqlbin.com/)\n    \n    $ brew cask install praphql-playground\n    \n\n\n公共 API （https://github.com/APIs-guru/graphql-apis）#\n\n\n内置类型#\n\n * Int\n * FLoat\n * String\n * Boolean\n * ID\n\n参考： http://snowtooth.moonhighway.com\n\n\n查询字段 query#\n\n## Basic\nquery liftsAndTrails {\n  liftCount(status: OPEN)\n  allLifts {\n    name\n    status\n  }\n  allTrails {\n    name\n    diffculty\n  }\n}\n## NameSpace\nquery liftsAndTrails {\n  open: liftCount(status: OPEN)\n  chairlifts: allLifts {\n    name\n    status\n  }\n  skiSlopes: allTrails {\n    name\n    diffculty\n  }\n}\n\n\n\n片段 Fragment#\n\nfragment liftInfo on Lift {\n  name\n  status\n  capacity\n  night\n  elevationGain\n}\nfragment trailInfo on Trail {\n  name\n  difficulty\n}\n\nquery {\n  Lift(id: \"jazz-cat\") {\n    ...liftInfo\n    trailAccess {\n      ...trailInfo\n    }\n  }\n  Trail(id: \"river-run\") {\n    ...trailInfo\n    accessedByLifts {\n      ...liftInfo\n    }\n  }\n}\n\n\n\n变更 mutation#\n\nmutation createSong {\n  addSong(title: \"No Scrubs\", numberOne: true, performerName: \"TLC\") {\n    id\n    title\n    numberOne\n  }\n}\n\n\n\n订阅 subscription#\n\nsubscription {\n  liftStatusChange {\n    name\n    capacity\n    status\n  }\n}\n\n## 修改\nmutation closeLift {\n  setLiftStatus(id: \"astra-express\", status: HOLD) {\n    name\n    status\n  }\n}\n\n\n\n自检 inrospection ???#\n\nquery {\n  __schema {\n    types {\n      name\n      description\n    }\n  }\n}\n\nquery {\n  __type(name: \"Lift\") {\n    name\n    fields {\n      name\n      description\n      type {\n        name\n      }\n    }\n  }\n}\n","routePath":"/note/graphql/query","lang":"","toc":[{"text":"工具","id":"工具","depth":3,"charIndex":3},{"text":"公共 API （https://github.com/APIs-guru/graphql-apis）","id":"公共-api-httpsgithubcomapis-gurugraphql-apis","depth":3,"charIndex":171},{"text":"内置类型","id":"内置类型","depth":3,"charIndex":225},{"text":"查询字段 query","id":"查询字段-query","depth":3,"charIndex":315},{"text":"片段 Fragment","id":"片段-fragment","depth":3,"charIndex":640},{"text":"变更 mutation","id":"变更-mutation","depth":3,"charIndex":983},{"text":"订阅 subscription","id":"订阅-subscription","depth":3,"charIndex":1130},{"text":"自检 inrospection ???","id":"自检-inrospection-","depth":3,"charIndex":1333}],"frontmatter":{},"version":""},{"title":"SCHEMA","content":"#\n\n你要对 API 包含的数据类型进行统筹，讨论并正式确定下来。 这种类型的集合就是后端程序员所熟知的 schema\n\nschema 优先是一种设计方法论，遵循它可以使团队保持一致的数据类型。\n\n\nTYPE#\n\ntype Photo {\n  id: ID! # 非空字段 non-nullable\n  name: String!\n  url: String!\n  description: String\n}\n\n\n\n标量类型 scalar#\n\nhttps://www.npmjs.com/package/graphql-custom-types\n\nscalar DataTime\ntype Photo {\n  id: ID!\n  name: String!\n  url: String!\n  description: String\n  created: DateTime!\n}\n\n\n\n\nconst myCustomScalarType = new GraphQLScalarType({\n  name: \"MyCustomScalar\",\n  description: \"Description of my custom scalar type\",\n  serialize(value) {\n    let result;\n    // 从服务端发送给客户端的数据\n    return result;\n  },\n  parseValue(value) {\n    // 从客户端接收的数据\n    let result;\n    return result;\n  },\n  parseLiteral(ast) {\n    switch (ast.kind) {\n    }\n  },\n});\n\nconst schemaString = `\nscalar MyCustomScalar\n\ntype Foo {\n  aField: MyCustomScalar\n}\n\ntype Query {\n  foo: Foo\n}\n`;\n\n\n\n枚举 enum#\n\nenum PhotoCategory {\n  SELFIE\n  PORTRAIT\n  ACTION\n  LANDSCAPE\n  GRAPHIC\n}\n\n\n\n列表 list#\n\n[String]\n[Int] # 可空的整数值列表\n# [] => ok, [null,1,2] => ok\n[Int!] # 不可空的整数值列表\n# [] => ok, [null,1,2] => error\n[Int]! # 可空的整数值非空列表\n# [] => error, [null,1,2] => ok\n[Int!]! # 不可空的整数值非空列表\n# [] => error, [null,1,2] => error\n\n\n\n连接 Linked#\n\n一对一#\n\ntype User {\n\tusername: ID!\n\tname: String\n\tavatar: String\n}\ntype Photo {\n\tid: ID!\n\turl: String!\n\tdescription: String\n\tcreated: DateTime!\n\tpostedBy: User!\n}\n\n\n一对多#\n\ntype User {\n\tusername: ID!\n\tname: String\n\tavatar: String\n\tphotos: [Photo!]\n}\ntype Photo {\n\tid: ID!\n\turl: String!\n\tdescription: String\n\tcreated: DateTime!\n\tpostedBy: User!\n}\n\n\n多对多？？#\n\n直通类型#\n\ntype User {\n\tusername: ID!\n\tname: String\n\tavatar: String\n}\ntype User {\n\tfriends [User!]!\n}\n\n\n\n联合类型 union type#\n\n\n接口 interface#\n\n\n参数 argument#\n\ntype Query {\n\t# 查询\n\tUser(id: ID!): User!\n\t# 筛选\n\tallPhotos(category: PhotoCategory): [Photo!]!\n}\n\n\n#\n\n\n输入#","routePath":"/note/graphql/schema","lang":"","toc":[{"text":"TYPE","id":"type","depth":3,"charIndex":99},{"text":"标量类型 scalar","id":"标量类型-scalar","depth":3,"charIndex":207},{"text":"枚举 enum","id":"枚举-enum","depth":3,"charIndex":864},{"text":"列表 list","id":"列表-list","depth":3,"charIndex":951},{"text":"连接 Linked","id":"连接-linked","depth":3,"charIndex":1179},{"text":"一对一","id":"一对一","depth":4,"charIndex":1191},{"text":"一对多","id":"一对多","depth":4,"charIndex":1354},{"text":"多对多？？","id":"多对多","depth":4,"charIndex":1535},{"text":"直通类型","id":"直通类型","depth":4,"charIndex":1543},{"text":"联合类型 union type","id":"联合类型-union-type","depth":3,"charIndex":1644},{"text":"接口 interface","id":"接口-interface","depth":3,"charIndex":1663},{"text":"参数 argument","id":"参数-argument","depth":3,"charIndex":1679},{"text":"","id":"","depth":4,"charIndex":1791},{"text":"输入","id":"输入","depth":3,"charIndex":-1}],"frontmatter":{},"version":""},{"title":"Server","content":"#\n\nmodule.exports = \"db\"; // https://randomuser.me/api/?results=50\n\n\n\ntypeDefs#\n\nconst { gql } = require(\"apollo-server\");\n\nmodule.exports = gql`\n  type Name {\n    first: String\n    last: String\n  }\n  type User {\n    name: Name\n    email: String\n  }\n  type Query {\n    users: [User]\n  }\n  type Mutation {\n    addUser(first: String, last: String, email: String): User\n  }\n`;\n\n\n\nresolves#\n\nconst db = require(\"./db\");\n\nmodule.exports = {\n  Query: {\n    users: () => db.results,\n  },\n  Mutation: {\n    addUser: (obj, args, ctx) => {\n      console.log(args); // 받은 객체 저장.\n      return \"등록 완료\";\n    },\n  },\n};\n\n\n\napp#\n\nconst { ApolloServer, makeExecutableSchema } = require(\"apollo-server\");\nconst typeDefs = require(\"./typeDefs\");\nconst resolvers = require(\"./resolves\");\n\nconst schema = makeExecutableSchema({ typeDefs, resolvers });\nconst server = new ApolloServer({ schema });\n\n// The `listen` method launches a web server.\nserver.listen().then(({ url }) => {\n  console.log(`🚀  Server ready at ${url}`);\n});\n","routePath":"/note/graphql/server","lang":"","toc":[{"text":"typeDefs","id":"typedefs","depth":3,"charIndex":69},{"text":"resolves","id":"resolves","depth":3,"charIndex":376},{"text":"app","id":"app","depth":3,"charIndex":607}],"frontmatter":{},"version":""},{"title":"Doctype","content":"#\n\n\nDoctype#\n\n<!doctype html>\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\n\n\nmeta#\n\n<meta charset=\"UTF-8\">\n\n<!-- 页面关键词 -->\n<meta name=\"keywords\" content=\"\"/>\n<!-- 页面描述 -->\n<meta name=\"description\" content=\"网站介绍\"/>\n<meta name =\"viewport\" content =\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\">\n\n<!-- 优先使用 IE 最新版本和 Chrome -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\n\n<!-- mobile -->\n<!-- 忽略数字自动识别为电话号码； -->\n<meta name=\"format-detection\" content=\"telephone=no\" />\n<!-- 忽略数字自动识别为邮箱 -->\n<meta name=\"format-detection\" content=\"email=no\">\n\n<!-- ios -->\n<!-- 添加到主屏后设置状态栏的背景颜色； -->\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\n<!-- 添加到主屏后的标题（iOS 6 新增） -->\n<meta name=\"apple-mobile-web-app-title\" content=\"标题\">\n<!-- 启动WebApp全屏模式； -->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n\n<!-- 搜索引擎抓取 -->\n<meta name=\"robots\" content=\"index,follow\"/>\n\n<!-- sns 社交标签 begin -->\n<!-- 参考微博API -->\n<meta property=\"og:type\" content=\"类型\" />\n<meta property=\"og:url\" content=\"URL地址\" />\n<meta property=\"og:title\" content=\"标题\" />\n<meta property=\"og:image\" content=\"图片\" />\n<meta property=\"og:description\" content=\"描述\" />\n<!-- sns 社交标签 end -->\n\n<!-- Theme Color for Chrome, Firefox OS and Opera -->\n<meta name=\"theme-color\" content=\"#4285f4\">\n\n<!-- Windows Phone -->\n<meta name=\"msapplication-navbutton-color\" content=\"#4285f4\">\n\n<!-- Security -->\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'\">\n<meta http-equiv=\"X-Content-Type-Options\" content=\"nosniff\">\n\n<!-- PWA -->\n<link rel=\"manifest\" href=\"/manifest.json\">\n<meta name=\"mobile-web-app-capable\" content=\"yes\">\n\n<!-- Favicon -->\n<link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\">\n<link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/favicon-16x16.png\">\n<link rel=\"mask-icon\" href=\"/safari-pinned-tab.svg\" color=\"#5bbad5\">\n<meta name=\"msapplication-TileColor\" content=\"#da532c\">\n\n<!-- DNS Prefetch -->\n<link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\">\n<link rel=\"dns-prefetch\" href=\"//www.google-analytics.com\">\n\n<!-- Preconnect -->\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com/\" crossorigin>\n\n\n\nlink#\n\n<!-- iOS 图标 begin -->\n<link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/>\n<!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->\n<link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/>\n<!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->\n<link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/>\n<!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->\n<!-- iOS 图标 end -->\n\n<!-- iOS 启动画面 begin -->\n<link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/>\n<!-- iPad 竖屏 768 x 1004（标准分辨率） -->\n<link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/>\n<!-- iPad 竖屏 1536x2008（Retina） -->\n<link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/>\n<!-- iPad 横屏 1024x748（标准分辨率） -->\n<link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/>\n<!-- iPad 横屏 2048x1496（Retina） -->\n\n<link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/>\n<!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) -->\n<link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/>\n<!-- iPhone/iPod Touch 竖屏 640x960 (Retina) -->\n<link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/>\n<!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) -->\n<!-- iOS 启动画面 end -->\n","routePath":"/note/html/doctype","lang":"","toc":[{"text":"Doctype","id":"doctype-1","depth":3,"charIndex":-1},{"text":"meta","id":"meta","depth":3,"charIndex":206},{"text":"link","id":"link","depth":3,"charIndex":2289}],"frontmatter":{},"version":""},{"title":"HTML Entity","content":"#\n\n\nASCII Characters (Printable)#\n\n인쇄 가능한 문자만 표시되며 제어 문자(0-31)는 시각적 표현이 없으므로 HTML 페이지에 있어서는 안 됩니다.\n\nCHARACTER   ENTITY NAME   ENTITY NUMBER   DESCRIPTION\n                                          Space\n!                         !               Exclamation mark\n\"                         \"               Quotation mark\n#                         #               Number sign\n$                         $               Dollar sign\n%                         %               Percent sign\n&           &             &               Ampersand\n'                         '               Apostrophe\n(                         (               Opening/Left Parenthesis\n)                         )               Closing/Right Parenthesis\n*                         *               Asterisk\n+                         +               Plus sign\n,                         ,               Comma\n-                         -               Hyphen\n.                         .               Period\n/                         /               Slash\n0                         0               Digit 0\n1                         1               Digit 1\n2                         2               Digit 2\n3                         3               Digit 3\n4                         4               Digit 4\n5                         5               Digit 5\n6                         6               Digit 6\n7                         7               Digit 7\n8                         8               Digit 8\n9                         9               Digit 9\n:                         :               Colon\n;                         ;               Semicolon\n<           <             <               Less-than\n=                         =               Equals sign\n>           >             >               Greater than\n?                         ?               Question mark\n@                         @               At sign\nA                         A               Uppercase A\nB                         B               Uppercase B\nC                         C               Uppercase C\nD                         D               Uppercase D\nE                         E               Uppercase E\nF                         F               Uppercase F\nG                         G               Uppercase G\nH                         H               Uppercase H\nI                         I               Uppercase I\nJ                         J               Uppercase J\nK                         K               Uppercase K\nL                         L               Uppercase L\nM                         M               Uppercase M\nN                         N               Uppercase N\nO                         O               Uppercase O\nP                         P               Uppercase P\nQ                         Q               Uppercase Q\nR                         R               Uppercase R\nS                         S               Uppercase S\nT                         T               Uppercase T\nU                         U               Uppercase U\nV                         V               Uppercase V\nW                         W               Uppercase W\nX                         X               Uppercase X\nY                         Y               Uppercase Y\nZ                         Z               Uppercase Z\n[                         [               Opening/Left square bracket\n\\                         \\               Backslash\n]                         ]               Closing/Right square bracket\n^                         ^               Caret\n_                         _               Underscore\n`                         `               Grave accent\na                         a               Lowercase a\nb                         b               Lowercase b\nc                         c               Lowercase c\nd                         d               Lowercase d\ne                         e               Lowercase e\nf                         f               Lowercase f\ng                         g               Lowercase g\nh                         h               Lowercase h\ni                         i               Lowercase i\nj                         j               Lowercase j\nk                         k               Lowercase k\nl                         l               Lowercase l\nm                         m               Lowercase m\nn                         n               Lowercase n\no                         o               Lowercase o\np                         p               Lowercase p\nq                         q               Lowercase q\nr                         r               Lowercase r\ns                         s               Lowercase s\nt                         t               Lowercase t\nu                         u               Lowercase u\nv                         v               Lowercase v\nw                         w               Lowercase w\nx                         x               Lowercase x\ny                         y               Lowercase y\nz                         z               Lowercase z\n{                         {               Opening/Left curly brace\n|                         |               Vertical bar\n}                         }               Closing/Right curly brace\n~                         ~               Tilde\n\n\nISO 8859-1 Characters#\n\n지원되는 ISO-8859-1 문자의 전체 목록 이름은 대소문자를 구분하므로 대문자를 원할 경우 이름도 대문자로 시작해야 합니다.\n\nCHARACTER   ENTITY NAME   ENTITY NUMBER   DESCRIPTION\n                                          Space\n!                         !               Exclamation mark\n\"                         \"               Quotation mark\n#                         #               Number sign\n$                         $               Dollar sign\n%                         %               Percent sign\n&           &             &               Ampersand\n'                         '               Apostrophe\n(                         (               Opening/Left Parenthesis\n)                         )               Closing/Right Parenthesis\n*                         *               Asterisk\n+                         +               Plus sign\n,                         ,               Comma\n-                         -               Hyphen\n.                         .               Period\n/                         /               Slash\n0                         0               Digit 0\n1                         1               Digit 1\n2                         2               Digit 2\n3                         3               Digit 3\n4                         4               Digit 4\n5                         5               Digit 5\n6                         6               Digit 6\n7                         7               Digit 7\n8                         8               Digit 8\n9                         9               Digit 9\n:                         :               Colon\n;                         ;               Semicolon\n<           <             <               Less-than\n=                         =               Equals sign\n>           >             >               Greater than\n?                         ?               Question mark\n@                         @               At sign\nA                         A               Uppercase A\nB                         B               Uppercase B\nC                         C               Uppercase C\nD                         D               Uppercase D\nE                         E               Uppercase E\nF                         F               Uppercase F\nG                         G               Uppercase G\nH                         H               Uppercase H\nI                         I               Uppercase I\nJ                         J               Uppercase J\nK                         K               Uppercase K\nL                         L               Uppercase L\nM                         M               Uppercase M\nN                         N               Uppercase N\nO                         O               Uppercase O\nP                         P               Uppercase P\nQ                         Q               Uppercase Q\nR                         R               Uppercase R\nS                         S               Uppercase S\nT                         T               Uppercase T\nU                         U               Uppercase U\nV                         V               Uppercase V\nW                         W               Uppercase W\nX                         X               Uppercase X\nY                         Y               Uppercase Y\nZ                         Z               Uppercase Z\n[                         [               Opening/Left square bracket\n\\                         \\               Backslash\n]                         ]               Closing/Right square bracket\n^                         ^               Caret\n_                         _               Underscore\n`                         `               Grave accent\na                         a               Lowercase a\nb                         b               Lowercase b\nc                         c               Lowercase c\nd                         d               Lowercase d\ne                         e               Lowercase e\nf                         f               Lowercase f\ng                         g               Lowercase g\nh                         h               Lowercase h\ni                         i               Lowercase i\nj                         j               Lowercase j\nk                         k               Lowercase k\nl                         l               Lowercase l\nm                         m               Lowercase m\nn                         n               Lowercase n\no                         o               Lowercase o\np                         p               Lowercase p\nq                         q               Lowercase q\nr                         r               Lowercase r\ns                         s               Lowercase s\nt                         t               Lowercase t\nu                         u               Lowercase u\nv                         v               Lowercase v\nw                         w               Lowercase w\nx                         x               Lowercase x\ny                         y               Lowercase y\nz                         z               Lowercase z\n{                         {               Opening/Left curly brace\n|                         |               Vertical bar\n}                         }               Closing/Right curly brace\n~                         ~               Tilde\n\n\nISO-8859-1 Symbols#\n\nHTML에서 지원되는 ISO-8859-1 기호의 전체 목록입니다.\n\nSYMBOL   ENTITY NAME   ENTITY NUMBER   DESCRIPTION\n                                       Non-breaking space\n¡        ¡             ¡               Inverted exclamation mark\n¢        ¢             ¢               Cent\n£        £             £               Pound\n¤        ¤             ¤               Currency\n¥        ¥             ¥               Yen\n¦        ¦             ¦               Broken vertical bar\n§        §             §               Section\n¨        ¨             ¨               Spacing diaeresis\n©        ©             ©               Copyright\nª        ª             ª               Feminine ordinal indicator\n«        «             «               Opening/Left angle quotation mark\n¬        ¬             ¬               Negation\n­        ­             ­               Soft hyphen\n®        ®             ®               Registered trademark\n¯        ¯             ¯               Spacing macron\n°        °             °               Degree\n±        ±             ±               Plus or minus\n²        ²             ²               Superscript 2\n³        ³             ³               Superscript 3\n´        ´             ´               Spacing acute\nµ        µ             µ               Micro\n¶        ¶             ¶               Paragraph\n¸        ¸             ¸               Spacing cedilla\n¹        ¹             ¹               Superscript 1\nº        º             º               Masculine ordinal indicator\n»        »             »               Closing/Right angle quotation mark\n¼        ¼             ¼               Fraction 1/4\n½        ½             ½               Fraction 1/2\n¾        ¾             ¾               Fraction 3/4\n¿        ¿             ¿               Inverted question mark\n×        ×             ×               Multiplication\n÷        ÷             ÷               Divide\n\n\nMath Symbols#\n\nHTML에서 지원되는 모든 수학 기호의 전체 목록입니다.\n\nSYMBOL   ENTITY NAME   ENTITY NUMBER   DESCRIPTION\n∀        ∀             ∀               For all\n∂        ∂             ∂               Part\n∃        ∃             ∃               Exist\n∅        ∅             ∅               Empty\n∇        ∇             ∇               Nabla\n∈        ∈             ∈               Is in\n∉        ∉             ∉               Not in\n∋        ∋             ∋               Ni\n∏        ∏             ∏               Product\n∑        ∑             ∑               Sum\n−        −             −               Minus\n∗        ∗             ∗               Asterisk (Lowast)\n√        √             √               Square root\n∝        ∝             ∝               Proportional to\n∞        ∞             ∞               Infinity\n∠        ∠             ∠               Angle\n∧        ∧             ∧               And\n∨        ∨             ∨               Or\n∩        ∩             ∩               Cap\n∪        ∪             ∪               Cup\n∫        ∫             ∫               Integral\n∴        ∴             ∴               Therefore\n∼        ∼             ∼               Similar to\n≅        ≅             ≅               Congurent to\n≈        ≈             ≈               Almost equal\n≠        ≠             ≠               Not equal\n≡        ≡             ≡               Equivalent\n≤        ≤             ≤               Less or equal\n≥        ≥             ≥               Greater or equal\n⊂        ⊂             ⊂               Subset of\n⊃        ⊃             ⊃               Superset of\n⊄        ⊄             ⊄               Not subset of\n⊆        ⊆             ⊆               Subset or equal\n⊇        ⊇             ⊇               Superset or equal\n⊕        ⊕             ⊕               Circled plus\n⊗        ⊗             ⊗               Circled times\n⊥        ⊥             ⊥               Perpendicular\n⋅        ⋅             ⋅               Dot operator\n\n\nGreek Letters#\n\nHTML에서 지원되는 모든 그리스 문자의 전체 목록입니다.\n\nLETTER   ENTITY NAME   ENTITY NUMBER   DESCRIPTION\nΑ        Α             Α               Alpha\nΒ        Β             Β               Beta\nΓ        Γ             Γ               Gamma\nΔ        Δ             Δ               Delta\nΕ        Ε             Ε               Epsilon\nΖ        Ζ             Ζ               Zeta\nΗ        Η             Η               Eta\nΘ        Θ             Θ               Theta\nΙ        Ι             Ι               Iota\nΚ        Κ             Κ               Kappa\nΛ        Λ             Λ               Lambda\nΜ        Μ             Μ               Mu\nΝ        Ν             Ν               Nu\nΞ        Ξ             Ξ               Xi\nΟ        Ο             Ο               Omicron\nΠ        Π             Π               Pi\nΡ        Ρ             Ρ               Rho\nΣ        Σ             Σ               Sigma\nΤ        Τ             Τ               Tau\nΥ        Υ             Υ               Upsilon\nΦ        Φ             Φ               Phi\nΧ        Χ             Χ               Chi\nΨ        Ψ             Ψ               Psi\nΩ        Ω             Ω               Omega\nα        α             α               alpha\nβ        β             β               beta\nγ        γ             γ               gamma\nδ        δ             δ               delta\nε        ε             ε               epsilon\nζ        ζ             ζ               zeta\nη        η             η               eta\nθ        θ             θ               theta\nι        ι             ι               iota\nκ        κ             κ               kappa\nλ        λ             λ               lambda\nμ        μ             μ               mu\nν        ν             ν               nu\nξ        ξ             ξ               xi\nο        ο             ο               omicron\nπ        π             π               pi\nρ        ρ             ρ               rho\nς        ς             ς               sigmaf\nσ        σ             σ               sigma\nτ        τ             τ               tau\nυ        υ             υ               upsilon\nφ        φ             φ               phi\nχ        χ             χ               chi\nψ        ψ             ψ               psi\nω        ω             ω               omega\nϑ        ϑ             ϑ               Theta symbol\nϒ        ϒ             ϒ               Upsilon symbol\nϖ        ϖ             ϖ               Pi symbol\n\n\nMiscellaneous HTML entities#\n\n기타 HTML 엔터티 목록입니다.\n\nSYMBOL   ENTITY NAME   ENTITY NUMBER   DESCRIPTION\nŒ        Œ             Œ               Uppercase ligature OE\nœ        œ             œ               Lowercase ligature OE\nŠ        Š             Š               Uppercase S with caron\nš        š             š               Lowercase S with caron\nŸ        Ÿ             Ÿ               Capital Y with diaeres\nƒ        ƒ             ƒ               Lowercase with hook\nˆ        ˆ             ˆ               Circumflex accent\n˜        ˜             ˜               Tilde\n                                       En space\n                                       Em space\n                                       Thin space\n‌        ‌             ‌               Zero width non-joiner\n‍        ‍             ‍               Zero width joiner\n‎        ‎             ‎               Left-to-right mark\n‏        ‏             ‏               Right-to-left mark\n–        –             –               En dash\n—        —             —               Em dash\n‘        ‘             ‘               Left single quotation mark\n’        ’             ’               Right single quotation mark\n‚        ‚             ‚               Single low-9 quotation mark\n“        “             “               Left double quotation mark\n”        ”             ”               Right double quotation mark\n„        „             „               Double low-9 quotation mark\n†        †             †               Dagger\n‡        ‡             ‡               Double dagger\n•        •             •               Bullet\n…        …             …               Horizontal ellipsis\n‰        ‰             ‰               Per mille\n′        ′             ′               Minutes (Degrees)\n″        ″             ″               Seconds (Degrees)\n‹        ‹             ‹               Single left angle quotation\n›        ›             ›               Single right angle quotation\n‾        ‾             ‾               Overline\n€        €             €               Euro\n™        ™             ™               Trademark\n←        ←             ←               Left arrow\n↑        ↑             ↑               Up arrow\n→        →             →               Right arrow\n↓        ↓             ↓               Down arrow\n↔        ↔             ↔               Left right arrow\n↵        ↵             ↵               Carriage return arrow\n⌈        ⌈             ⌈               Left ceiling\n⌉        ⌉             ⌉               Right ceiling\n⌊        ⌊             ⌊               Left floor\n⌋        ⌋             ⌋               Right floor\n◊        ◊             ◊               Lozenge\n♠        ♠             ♠               Spade\n♣        ♣             ♣               Club\n♥        ♥             ♥               Heart\n♦        ♦             ♦               Diamond","routePath":"/note/html/entity","lang":"","toc":[{"text":"ASCII Characters (Printable)","id":"ascii-characters-printable","depth":2,"charIndex":3},{"text":"ISO 8859-1 Characters","id":"iso-8859-1-characters","depth":2,"charIndex":5281},{"text":"ISO-8859-1 Symbols","id":"iso-8859-1-symbols","depth":2,"charIndex":10560},{"text":"Math Symbols","id":"math-symbols","depth":2,"charIndex":12458},{"text":"Greek Letters","id":"greek-letters","depth":2,"charIndex":14414},{"text":"Miscellaneous HTML entities","id":"miscellaneous-html-entities","depth":2,"charIndex":16838}],"frontmatter":{},"version":""},{"title":"IndexedDB","content":"#\n\n\n特点#\n\n * 键值对储存。\n * 异步\n * 支持事物(transaction)\n * 同源限制\n * 储存空间大\n * 支持二进制\n\n\n基本概念#\n\n * 数据库：IDBDatabase 对象\n * 对象仓库：IDBObjectStore 对象\n * 索引： IDBIndex 对象\n * 事务： IDBTransaction 对象\n * 操作请求：IDBRequest 对象\n * 指针： IDBCursor 对象\n * 主键集合：IDBKeyRange 对象\n\n\n打开数据库#\n\nconst request = window.indexedDB.open(\"dbname\", 1);\n// error事件表示打开数据库失败。\nrequest.onerror = function (event) {\n  console.log(\"数据库打开报错\");\n};\n// success事件表示成功打开数据库。\nrequest.onsuccess = function (event) {\n  console.log(request.result);\n  console.log(\"数据库打开成功\");\n};\n// 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。\nrequest.onupgradeneeded = function (event) {\n  console.log(event.target.result);\n};\n\n\n\n新建数据库#\n\nrequest.onupgradeneeded = function (event) {\n  const db = event.target.result;\n  const objectStore = db.createObjectStore(\"person\", { keyPath: \"id\" });\n\n  // 自动生成主键\n  // const objectStore = db.createObjectStore('person', { autoIncrement: true });\n\n  // 创建索引\n  objectStore.createIndex(\"name\", \"name\", { unique: false });\n  objectStore.createIndex(\"email\", \"email\", { unique: true });\n};\n\n\n\n新增数据#\n\n通过 objectStore 对象的 add()方法，向表格写入一条记录。\n\nfunction add() {\n  var request = db\n    .transaction([\"person\"], \"readwrite\")\n    .objectStore(\"person\")\n    .add({ id: 1, name: \"张三\", age: 24, email: \"zhangsan@example.com\" });\n\n  request.onsuccess = function (event) {\n    console.log(\"数据写入成功\");\n  };\n\n  request.onerror = function (event) {\n    console.log(\"数据写入失败\");\n  };\n}\n\n\n\n读取数据#\n\n读取数据也是通过事务完成。 objectStore.get()方法用于读取数据，参数是主键的值。\n\nfunction read() {\n  var transaction = db.transaction([\"person\"]);\n  var objectStore = transaction.objectStore(\"person\");\n  var request = objectStore.get(1);\n\n  request.onerror = function (event) {\n    console.log(\"事务失败\");\n  };\n\n  request.onsuccess = function (event) {\n    if (request.result) {\n      console.log(request.result);\n    } else {\n      console.log(\"未获得数据记录\");\n    }\n  };\n}\n\n\n\n遍历数据#\n\n新建指针对象的 openCursor()方法是一个异步操作，所以要监听 success 事件。\n\nfunction readAll() {\n  var objectStore = db.transaction(\"person\").objectStore(\"person\");\n\n  objectStore.openCursor().onsuccess = function (event) {\n    var cursor = event.target.result;\n\n    if (cursor) {\n      console.log(cursor);\n      cursor.continue();\n    } else {\n      console.log(\"没有更多数据了！\");\n    }\n  };\n}\n\n\n\n更新数据#\n\nput()方法自动更新了主键为 1 的记录。\n\nfunction update() {\n  var request = db\n    .transaction([\"person\"], \"readwrite\")\n    .objectStore(\"person\")\n    .put({ id: 1, name: \"李四\", age: 35, email: \"lisi@example.com\" });\n\n  request.onsuccess = function (event) {\n    console.log(\"数据更新成功\");\n  };\n\n  request.onerror = function (event) {\n    console.log(\"数据更新失败\");\n  };\n}\n\n\n\n删除数据#\n\nIDBObjectStore.delete()方法用于删除记录。\n\nfunction remove() {\n  var request = db.transaction([\"person\"], \"readwrite\").objectStore(\"person\").delete(1);\n\n  request.onsuccess = function (event) {\n    console.log(\"数据删除成功\");\n  };\n}\n\n\n\n使用索引#\n\nvar transaction = db.transaction([\"person\"], \"readonly\");\nvar store = transaction.objectStore(\"person\");\nvar index = store.index(\"name\");\nvar request = index.get(\"李四\");\n\nrequest.onsuccess = function (e) {\n  var result = e.target.result;\n  if (result) {\n    // ...\n  } else {\n    // ...\n  }\n};\n\n\n\nhtml#\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n  </head>\n\n  <body>\n    <div id=\"app\">\n      <button class=\"add\">add</button>\n      <button class=\"get\">get</button>\n      <button class=\"getall\">getall</button>\n\n      <button class=\"put\">put</button>\n\n      <button class=\"del\">del</button>\n    </div>\n    <script src=\"https://code.jquery.com/jquery-3.5.0.min.js\"></script>\n    <script>\n      $(function () {\n        let db;\n\n        const request = window.indexedDB.open(\"dbname\", 2);\n        // error事件表示打开数据库失败。\n        request.onerror = function (event) {\n          console.log(\"数据库打开报错\");\n        };\n        // success事件表示成功打开数据库。\n        request.onsuccess = function (event) {\n          db = request.result;\n          console.log(request.result);\n          console.log(\"数据库打开成功\");\n        };\n        // 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。\n        request.onupgradeneeded = function (event) {\n          console.log(event.target.result);\n          db = event.target.result;\n          if (!db.objectStoreNames.contains(\"person\")) {\n            const objectStore = db.createObjectStore(\"person\", { keyPath: \"id\" });\n            objectStore.createIndex(\"name\", \"name\", { unique: false });\n            objectStore.createIndex(\"email\", \"email\", { unique: true });\n          }\n          console.log(111);\n        };\n\n        $(\".add\").click(function () {\n          let req = db\n            .transaction([\"person\"], \"readwrite\")\n            .objectStore(\"person\")\n            .add({ id: new Date().getTime(), name: \"张三\", age: 24, email: `${new Date().getTime()}+a@.com` });\n\n          req.onsuccess = function (event) {\n            console.log(\"数据写入成功\");\n          };\n\n          req.onerror = function (event) {\n            console.log(\"数据写入失败\");\n          };\n        });\n\n        $(\".get\").click(function () {\n          var transaction = db.transaction([\"person\"]);\n          var objectStore = transaction.objectStore(\"person\");\n          var req = objectStore.get(1);\n\n          req.onerror = function (event) {\n            console.log(\"事务失败\");\n          };\n\n          req.onsuccess = function (event) {\n            if (req.result) {\n              console.log(req.result);\n            } else {\n              console.log(\"未获得数据记录\");\n            }\n          };\n        });\n\n        $(\".getall\").click(function () {\n          var objectStore = db.transaction([\"person\"], \"readwrite\").objectStore(\"person\");\n\n          objectStore.openCursor().onsuccess = function (event) {\n            var cursor = event.target.result;\n\n            if (cursor) {\n              console.log(cursor);\n              cursor.continue();\n            } else {\n              console.log(\"没有更多数据了！\");\n            }\n          };\n        });\n\n        $(\".put\").click(function () {\n          var req = db.transaction([\"person\"], \"readwrite\").objectStore(\"person\").put({ id: 1, name: \"李四\" });\n\n          req.onsuccess = function (event) {\n            console.log(\"数据更新成功\");\n          };\n\n          req.onerror = function (event) {\n            console.log(\"数据更新失败\");\n          };\n        });\n\n        $(\".del\").click(function () {\n          var req = db.transaction([\"person\"], \"readwrite\").objectStore(\"person\").delete(1587451687741);\n\n          req.onsuccess = function (event) {\n            console.log(\"数据删除成功\");\n          };\n        });\n      });\n    </script>\n  </body>\n</html>\n","routePath":"/note/html/indexedDB","lang":"","toc":[{"text":"特点","id":"特点","depth":3,"charIndex":3},{"text":"基本概念","id":"基本概念","depth":3,"charIndex":73},{"text":"打开数据库","id":"打开数据库","depth":3,"charIndex":239},{"text":"新建数据库","id":"新建数据库","depth":3,"charIndex":645},{"text":"新增数据","id":"新增数据","depth":3,"charIndex":1042},{"text":"读取数据","id":"读取数据","depth":3,"charIndex":1417},{"text":"遍历数据","id":"遍历数据","depth":3,"charIndex":1863},{"text":"更新数据","id":"更新数据","depth":3,"charIndex":2236},{"text":"删除数据","id":"删除数据","depth":3,"charIndex":2595},{"text":"使用索引","id":"使用索引","depth":3,"charIndex":2824},{"text":"html","id":"html","depth":3,"charIndex":3127}],"frontmatter":{},"version":""},{"title":"Web Storage","content":"#\n\n\nlocalStorage, sessionStorage#\n\nlocalStorage.setItem(\"myCat\", \"Tom\");\nlocalStorage.getItem(\"myCat\");\nlocalStorage.removeItem(\"myCat\");\nlocalStorage.clear();\n\n\n\nsetItem 값 모니터링#\n\nconst orignalSetItem = localStorage.setItem;\n\nlocalStorage.setItem = function (key, newValue) {\n  let setItemEvent = new Event(\"setItemEvent\");\n  setItemEvent.value = localStorage.getItem(key); // 필요에 따라 사용.\n  setItemEvent.newValue = newValue;\n  setItemEvent.key = key;\n  window.dispatchEvent(setItemEvent);\n  orignalSetItem.apply(this, arguments);\n};\n\nwindow.addEventListener(\"setItemEvent\", function (e) {\n  console.log(e);\n});\n\n\n\ncookie#\n\n// 读取Cookie\ndocument.cookie;\n\n// 基本\ndocument.cookie = \"name=Raymond\";\n// 动态使用\ndocument.cookie = \"name=\" + encodeURIComponent(name);\n// 创建2个cookie\ndocument.cookie = \"name=Raymond\";\ndocument.cookie = \"age=43\";\n// 设置过期\ndocument.cookie = \"name=Raymond; expires=Fri, 31 Dec 9999 23:59:59 GMT\";\n// 设置子域名访问\ndocument.cookie = \"name=Raymond; domail=app.guryong.cc\";\n\n// 删除Cookie 只需把时间设置为过去的时间\ndocument.cookie = \"name=Raymond; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n","routePath":"/note/html/storage","lang":"","toc":[{"text":"localStorage, sessionStorage","id":"localstorage-sessionstorage","depth":2,"charIndex":3},{"text":"setItem 값 모니터링","id":"setitem-값-모니터링","depth":2,"charIndex":162},{"text":"cookie","id":"cookie","depth":3,"charIndex":612}],"frontmatter":{},"version":""},{"title":"Markup Tag","content":"#\n\nElements 이 페이지는 태그를 사용해 만들 수 있는 모든 HTML 요소의 목록을 제공합니다. 필요로 하는 요소를 쉽게 찾을 수 있도록\n기능별로 분류했으며, 각각의 요소 참조 페이지 사이드바에서는 사전 순으로 정렬된 목록도 확인할 수 있습니다.\n\n\n메인 루트#\n\n요소     설명\nhtml   HTML 문서의 루트(최상위 요소)를 나타내므로 root 요소라고도 합니다. 다른 모든 요소는 이 요소의\n       자손이어야 합니다.\n\n\n문서 메타데이터#\n\n메타데이터는 스타일, 스크립트, 각종 소프트웨어검색 엔진, 브라우저 등의 탐색 및 렌더링을 도와줄 데이터 등 페이지에 대한 정보를 가집니다.\n스타일과 스크립트 메타데이터는 페이지 안에서 정의할 수도 있고, 해당하는 정보를 가진 다른 파일로 링크할 수도 있습니다.\n\n요소      설명\nbase    문서의 모든 상대 URL에 사용할 기본 URL을 지정합니다. 문서에는 이러한 요소가 하나만 있을 수\n        있습니다.\nhead    제목 스크립트 및 스타일 시트와 같은 문서에 대한 기계 판독 가능 정보(메타데이터)를 포함합니다.\nlink    현재 문서와 외부 리소스 간의 관계를 지정합니다. 이 요소는 CSS에 연결하는 데 가장 일반적으로 사용되지만\n        무엇보다도 사이트 아이콘(\"favicon\" 스타일 아이콘과 홈 화면용 아이콘 및 모바일 장치의 앱)을\n        설정하는 데도 사용됩니다.\nmeta    base, link, script, style, title과 같은 다른 메타관련 요소로 나타낼 수 없는\n        메타데이터를 나타냅니다.\nstyle   문서 또는 문서의 일부에 대한 스타일 정보를 포함합니다. 이 요소를 포함하는 문서의 내용에 적용되는 CSS를\n        포함합니다\ntitle   browser의 제목 표시줄 또는 페이지의 탭에 표시되는 문서의 제목을 정의합니다. 텍스트만 포함합니다.\n        요소 내의 태그는 무시됩니다.\n\n\n섹션 루트#\n\n요소     설명\nbody   HTML 문서의 내용을 나타냅니다. 문서에는 이러한 요소가 하나만 있을 수 있습니다.\n\n\n콘텐츠 섹션#\n\n콘텐츠 섹션 요소를 사용하면 문서 콘텐츠를 논리적 조각으로 구성할 수 있습니다. 섹션 요소를 사용하여 머리글 및 바닥글 탐색, 콘텐츠 섹션을\n식별하는 머리글 요소를 포함하여 페이지 콘텐츠에 대한 광범위한 개요를 만듭니다.\n\n요소                       설명\naddress                  가까운 HTML 요소의 사람, 단체, 조직 등에 대한 연락처 정보를 나타냅니다.\narticle                  문서, 페이지, 애플리케이션, 또는 사이트 안에서 독립적으로 구분해 배포하거나 재사용할 수 있는 구획을\n                         나타냅니다. 사용 예제로 게시판과 블로그 글, 매거진이나 뉴스 기사 등이 있습니다.\naside                    문서의 주요 내용과 간접적으로만 연관된 부분을 나타냅니다. 주로 사이드바 혹은 콜아웃 박스로 표현합니다.\nfooter                   가장 가까운 섹션 콘텐츠나 섹션 루트의 푸터를 나타냅니다. 푸터는 일반적으로 섹션의 작성자, 저작권 정보,\n                         관련 문서 등의 내용을 담습니다.\nheader                   소개 및 탐색에 도움을 주는 콘텐츠를 나타냅니다. 제목, 로고, 검색 폼, 작성자 이름 등의 요소도 포함할\n                         수 있습니다.\nh1, h2, h3, h4, h5, h6   6단계의 구획 제목을 나타냅니다. 구획 단계는 h1이 가장 높고 h6은 가장 낮습니다.\nmain                     문서 body의 주요 콘텐츠를 나타냅니다. 주요 콘텐츠 영역은 문서의 핵심 주제나 앱의 핵심 기능에\n                         직접적으로 연결됐거나 확장하는 콘텐츠로 이루어집니다.\nnav                      문서의 부분 중 현재 페이지 내, 또는 다른 페이지로의 링크를 보여주는 구획을 나타냅니다. 자주 쓰이는\n                         예제는 메뉴, 목차, 색인입니다.\nsection                  HTML 문서의 독립적인 구획을 나타내며, 더 적합한 의미를 가진 요소가 없을 때 사용합니다. 보통\n                         <section>은 제목을 포함하지만, 항상 그런 것은 아닙니다.\n\n\n텍스트 콘텐츠#\n\nHTML 텍스트 콘텐츠를 사용하여 여는 body와 닫는 </body> 태그 사이의 블록이나 콘텐츠 구획을 정리할 수 있습니다. 해당 콘텐츠의\n목적이나 구조 판별에 사용하므로 접근성과 SEO에 중요합니다.\n\n요소           설명\nblockquote   안쪽의 텍스트가 긴 인용문임을 나타냅니다. 주로 들여쓰기를 한 것으로 그려집니다. 인용문의 출처 URL은\n             cite 속성으로, 출처 텍스트는 cite 요소로 제공할 수 있습니다.\ndd           설명 목록(dl)에서 선행 용어(dt)에 대한 설명, 정의 또는 값을 제공합니다.\ndiv          유동 콘텐츠의 일반 컨테이너입니다. CSS를 사용하여 어떤 식으로든 스타일을 지정할 때까지 콘텐츠나\n             레이아웃에 영향을 미치지 않습니다(예: 스타일이 직접 적용되거나 flexbox와 같은 일종의 레이아웃 모델이\n             적용됨) 부모 요소.\ndl           설명 목록을 나타냅니다. <dl>은 dt로 표기한 용어와 dd 요소로 표기한 설명 그룹의 목록을 감싸서 설명\n             목록을 생성합니다. 주로 용어사전 구현이나 메타데이터(키-값 쌍 목록)를 표시할 때 사용합니다.\ndt           설명 혹은 정의 리스트에서 용어를 나타냅니다. dl 요소 안에 위치해야 합니다. 보통 dd 요소가\n             뒤따르지만, 여러 개의 요소를 연속해 배치하면 바로 다음 dd 요소로 한꺼번에 서술할 수 있습니다.\nfigcaption   부모 figure 요소가 포함하는 다른 콘텐츠에 대한 설명 혹은 범례를 나타냅니다.\nfigure       독립적인 콘텐츠를 표현합니다. figcaption 요소를 사용해 설명을 붙일 수 있습니다. 피규어, 설명,\n             콘텐츠는 하나의 단위로 참조됩니다.\nhr           이야기 장면 전환, 구획 내 주제 변경 등, 문단 레벨 요소에서 주제의 분리를 나타냅니다.\nli           목록의 항목을 나타냅니다. 반드시 정렬 목록(ol), 비정렬 목록 ul, 혹은 메뉴(menu) 안에 위치해야\n             합니다. 메뉴와 비정렬 목록에서는 보통 불릿으로 항목을 나타내고, 정렬 목록에서는 숫자나 문자를 사용한\n             오름차순 카운터로 나타냅니다.\nmenu         사용자가 수행하거나 하는 명령 묶음을 말합니다. 이것은 스크린 위에 나오는 목록 메뉴와 눌려진 버튼 아래에\n             나오는 것과 같은 맥락 메뉴를 포함합니다.\nol           정렬된 목록을 나타냅니다. 보통 숫자 목록으로 표현합니다.\np            하나의 문단을 나타냅니다. 시각적인 매체에서, 문단은 보통 인접 블록과의 여백과 첫 줄의 들여쓰기로\n             구분하지만, HTML에서 문단은 이미지나 입력 폼 등 서로 관련있는 콘텐츠 무엇이나 될 수 있습니다.\npre          미리 서식을 지정한 텍스트를 나타내며, HTML에 작성한 내용 그대로 표현합니다. 텍스트는 보통 고정폭\n             글꼴을 사용해 렌더링하고, 요소 내 공백문자를 그대로 유지합니다.\nul           정렬되지 않은 목록을 나타냅니다. 보통 불릿으로 표현합니다.\n\n\n인라인 텍스트 시멘틱#\n\nHTML 인라인 텍스트 시멘틱을 사용해서 단어, 줄, 혹은 아무 부분의 의미나 구조, 스타일을 정의할 수 있습니다.\n\n요소       설명\na        href 특성을 통해 다른 페이지나 같은 페이지의 어느 위치, 파일, 이메일 주소와 그 외 다른 URL로\n         연결할 수 있는 하이퍼링크를 만듭니다. <a> 안의 콘텐츠는 링크 목적지의 설명을 나타내야 합니다.\nabbr     준말 또는 머리글자를 나타냅니다. 선택 속성인 title을 사용하면 준말의 전체 뜻이나 설명을 제공할 수\n         있습니다. title 속성은 전체 설명만을 가져야 하며 다른건 포함할 수 없습니다.\nb        독자의 주의를 요소의 콘텐츠로 끌기 위한 용도로 사용합니다. 그 외의 다른 특별한 중요도는 주어지지\n         않습니다. 원래는 \"굵은 글씨 요소\"로 불렸으며, 대부분의 브라우저도 여전히 텍스트를 굵은 글씨체로\n         강조합니다. 그러나 <b>를 사용해 텍스트를 꾸미면 안됩니다. 대신 CSS font-weight를 사용해\n         굵은 글씨체를 적용하거나, strong 요소를 사용해 특별히 중요한 텍스트를 나타내세요.\nbdi      포함된 텍스트를 주변 텍스트와 분리하여 처리하도록 브라우저의 양방향 알고리즘에 지시합니다. 웹 사이트가 일부\n         텍스트를 동적으로 삽입하고 삽입되는 텍스트의 방향성을 모를 때 특히 유용합니다.\nbdo      현재 텍스트의 쓰기 방향을 덮어쓰고 다른 방향으로 렌더링 할 때 사용합니다.\nbr       텍스트 안에 줄바꿈(캐리지 리턴)을 생성합니다. 주소나 시조 등 줄의 구분이 중요한 내용을 작성할 때\n         유용합니다.\ncite     저작물의 출처를 표기할 때 사용하며, 제목을 반드시 포함해야 합니다. 적절한 맥락 아래에서는 출처를 축약해서\n         표기할 수 있습니다.\ncode     짧은 코드 조각을 나타내는 스타일을 사용해 자신의 콘텐츠를 표시합니다. 기본 스타일은 사용자 에이전트의\n         고정폭 글씨체입니다.\ndata     주어진 콘텐츠를 기계가 읽을 수 있는 해석본과 연결합니다. 콘텐츠가 시간 혹은 날짜 관련 정보라면 대신\n         time 요소를 사용하세요.\ndfn      현재 맥락이나 문장에서 정의하고 있는 용어를 나타냅니다. <dfn>에서 가장 가까운 p, dt/dd 쌍,\n         section 조상 요소를 용어 정의로 간주합니다.\nem       텍스트의 강세를 나타냅니다. <em> 요소를 중첩하면 더 큰 강세를 뜻하게 됩니다.\ni        텍스트에서 어떤 이유로 주위와 구분해야 하는 부분을 나타냅니다. 기술 용어, 외국어 구절, 등장인물의 생각\n         등을 예시로 들 수 있습니다. 보통 기울임꼴로 표시합니다.\nkbd      키보드 입력, 음성 입력 등 임의의 장치를 사용한 사용자의 입력을 나타냅니다. 관례에 따라 사용자 에이전트의\n         고정폭 글꼴로 표시하지만, HTML 표준은 그런 점을 강제하지 않습니다.\nmark     현재 맥락에 관련이 깊거나 중요해 표시 또는 하이라이트한 부분을 나타냅니다.\nq        둘러싼 텍스트가 짧은 인라인 인용문이라는것을 나타냅니다. 대부분의 브라우저에서는 앞과 뒤에 따옴표를 붙여\n         표현합니다. <q>는 줄 바꿈이 없는 짧은 경우에 적합합니다. 긴 인용문은 blockquote 요소를\n         사용하세요.\nrp       ruby 요소를 사용한 루비 주석을 지원하지 않는 경우 보여줄 괄호를 제공할 때 사용합니다. rt 요소를\n         감싸는 여는 괄호와 닫는 괄호를 각각의 <rp> 요소로 나타내야 합니다.\nrt       동아시아 문자의 루비 주석에서 발음, 번역 등을 나타내는 텍스트 부분을 지정합니다.\nruby     루비 주석을 나타냅니다. 루비 주석은 동아시아 문자의 발음을 표기할 때 사용합니다.\ns        글자에 취소선, 즉 글자를 가로지르는 선을 그립니다. <s> 요소를 사용해 이제 관계 없거나 더 이상\n         정확하지 않은 부분을 나타내세요. 그러나, <s>는 문서의 편집 기록을 나타내는 용도로는 적합하지 않습니다.\n         상황에 따라 del과 ins 요소를 대신 사용하세요.\nsamp     컴퓨터 프로그램 출력의 예시(혹은 인용문)를 나타냅니다. 보통 브라우저의 기본 고정폭 글씨체(보통\n         Courier, Lucida Console)를 사용해 렌더링합니다.\nsmall    덧붙이는 글이나, 저작권과 법률 표기 등의 작은 텍스트를 나타냅니다. 기본 상태에서 <small>은 자신의\n         콘텐츠를 한 사이즈 작은 글꼴(small에서 x-small 등)로 표시하지만, 스타일을 적용한 후에도 글씨\n         크기가 작을 필요는 없습니다.\nspan     구문 콘텐츠를 위한 통용 인라인 컨테이너로, 본질적으로는 아무것도 나타내지 않습니다. 스타일을 적용하기\n         위해서, 또는 lang 등 어떤 특성의 값을 서로 공유하는 요소를 묶을 때 사용할 수 있습니다. 적절한\n         의미를 가진 다른 요소가 없을 때에만 사용해야 합니다. <span>은 div와 매우 유사하지만, div는\n         블록 레벨 요소인 반면 <span>은 인라인 요소입니다.\nstrong   중대하거나 긴급한 콘텐츠를 나타냅니다. 보통 브라우저는 굵은 글씨로 표시합니다.\nsub      활자 배치를 아래 첨자로 해야 하는 인라인 텍스트를 지정합니다. 아래 첨자는 보통 더 작은 글씨 크기를\n         가지고, 기준선을 아래로 내려 렌더링 합니다.\nsup      활자 배치를 위 첨자로 해야 하는 인라인 텍스트를 지정합니다. 위 첨자는 보통 더 작은 글씨 크기를 가지고,\n         기준선을 위로 올려 렌더링 합니다.\ntime     시간의 특정 지점 또는 구간을 나타냅니다. datetime 특성의 값을 지정해 보다 적절한 검색 결과나,\n         알림 같은 특정 기능을 구현할 때 사용할 수 있습니다.\nu        글자로 표현하지 않는 주석을 가진 것으로 렌더링 해야 하는 텍스트를 나타냅니다. 기본값에서는 단순한 밑줄로\n         표시하지만 CSS를 사용해 바꿀 수 있습니다.\nvar      수학 표현 또는 프로그래밍에서 변수의 이름을 나타냅니다. 보통 현재 글씨체의 기울임꼴로 표시하지만,\n         브라우저마다 다를 수 있습니다.\nwbr      현재 요소의 줄 바꿈 규칙을 무시하고 브라우저가 줄을 바꿀 수 있는 위치를 나타냅니다.\n\n\n이미지 & 멀티미디어#\n\nHTML은 사진, 오디오, 비디오 등 다양한 멀티미디어 리소스를 지원합니다..\n\n요소      설명\narea    이미지의 핫스팟 영역을 정의하고 하이퍼링크를 추가할 수 있습니다. map 요소 안에서만 사용할 수 있습니다.\naudio   문서에 소리 콘텐츠를 포함할 때 사용합니다. src 특성 또는 source 요소를 사용해 한 개 이상의\n        오디오 소스를 지정할 수 있으며, 다수를 지정한 경우 가장 적절한 소스를 브라우저가 고릅니다.\n        MediaStream을 사용하면 미디어 스트림을 바라볼 수도 있습니다.\nimg     문서에 이미지를 넣습니다.\nmap     area 요소와 함께 이미지 맵(클릭 가능한 링크 영역)을 정의할 때 사용합니다.\ntrack   미디어 요소(audio, video)의 자식으로서, 자막 등 시간별 텍스트 트랙(시간 기반 데이터)를 지정할\n        때 사용합니다. 트랙은 WebVTT(Web Video Text Tracks, .vtt 파일) 또는 Timed\n        Text Markup Language(TTML)형식을 사용해야 합니다.\nvideo   비디오 플레이백을 지원하는 미디어 플레이어를 문서에 삽입합니다. 오디오 콘텐츠에도 사용할 수 있으나,\n        audio 요소가 사용자 경험에 좀 더 적합합니다.\n\n\n내장 콘텐츠#\n\nHTML은 일반적인 멀티미디어 콘텐츠 외에도 다양한 종류의 기타 콘텐츠를 포함할 수 있습니다.\n\n요소        설명\nembed     외부 어플리케이션이나 대화형 컨텐츠와의 통합점을 나타냅니다.\niframe    중첩 브라우징 맥락을 나타내는 요소로, 현재 문서 안에 다른 HTML 페이지를 삽입합니다.\nobject    이미지나, 중첩된 브라우저 컨텍스트, 플러그인에 의해 다뤄질수 있는 리소스와 같은 외부 리소스를 나타냅니다.\npicture   0개 이상의 source 요소와 하나의 img 요소를 포함하여 다양한 디스플레이/장치 시나리오에 대한\n          이미지의 대체 버전을 제공합니다.\nportal    새 페이지로의 원활한 탐색을 위해 다른 HTML 페이지를 현재 페이지에 포함할 수 있습니다.\nsource    그림, 오디오 요소 또는 비디오 요소에 대한 여러 미디어 리소스를 지정합니다. 이는 콘텐츠가 없고 닫는\n          태그가 없음을 의미하는 무효 요소입니다. 일반적으로 이미지 파일 형식과 미디어 파일 형식에 대한 서로 다른\n          지원을 제공하는 광범위한 브라우저와의 호환성을 제공하기 위해 여러 파일 형식으로 동일한 미디어 콘텐츠를\n          제공하는 데 사용됩니다.\n\n\nSVG와 MathML#\n\nsvg 및 math 요소를 사용하여 SVG 및 MathML 콘텐츠를 HTML 문서에 직접 삽입할 수 있습니다.\n\n요소     설명\nsvg    새 좌표계 및 뷰포트를 정의하는 컨테이너입니다. SVG 문서의 가장 바깥쪽 요소로 사용되지만 SVG 또는\n       HTML 문서 내부에 SVG 조각을 포함하는 데에도 사용할 수 있습니다.\nmath   MathML의 최상위 요소입니다. 모든 유효한 MathML 인스턴스는 여기에 래핑되어야 합니다. 또한 두\n       번째 <math> 요소를 다른 요소에 중첩해서는 안 되지만 그 안에 임의의 수의 다른 자식 요소를 포함할 수\n       있습니다.\n\n\n스크립트#\n\nHTML은 동적인 콘텐츠와 웹 어플리케이션을 위해 스크립트 언어, 그 중에서도 주로 JavaScript를 지원합니다. 특정 요소가 이런 기능을\n가지고 있습니다.\n\n요소         설명\ncanvas     캔버스 스크립팅 API 또는 WebGL API와 함께 사용해 그래픽과 애니메이션을 그릴 수 있습니다.\nnoscript   페이지의 스크립트 유형을 지원하지 않거나, 브라우저가 스크립트를 비활성화한 경우 보여줄 HTML 구획을\n           정의합니다.\nscript     데이터와 실행 가능한 코드를 문서에 포함할 때 사용하며 보통 JavaScript 코드와 함께 씁니다.\n           WebGL의 GLSL 셰이더 프로그래밍 언어, JSON 등 다른 언어와도 사용할 수 있습니다.\n\n\n수정사항 표시#\n\n텍스트의 특정 부분이 수정됐다는 것을 표시할 수 있습니다.\n\n요소    설명\ndel   문서에서 제거된 텍스트의 범위를 나타냅니다. 문서나 소스 코드의 변경점 추적 등에 사용할 수 있습니다.\n      ins 요소를 추가된 텍스트의 범위를 나타낼 수 있습니다.\nins   문서에 추가된 텍스트의 범위를 나타냅니다. del 요소를 사용하면 삭제된 텍스트의 범위를 나타낼 수\n      있습니다.\n\n\n표 콘텐츠#\n\n표 형식의 데이터를 생성하고 처리할 때 사용합니다.\n\n요소         설명\ncaption    표의 설명 또는 제목을 나타냅니다.\ncol        표의 열을 나타내며, 열에 속하는 칸에 공통된 의미를 부여할 때 사용합니다. colgroup 안에서 찾을 수\n           있습니다.\ncolgroup   표의 열을 묶는 그룹을 정의합니다.\ntable      행과 열로 이루어진 표를 나타냅니다.\ntbody      표의 여러 행(tr)을 묶어서 표 본문을 구성합니다.\ntd         데이터를 포함하는 표의 셀을 정의합니다. 이것은 표 모델에 참여합니다.\ntfoot      테이블의 열을 요약하는 행들의 집합입니다.\nth         테이블 셀 그룹의 헤더로 셀을 정의합니다. 이 그룹의 정확한 특성은 scope 및 headers 속성으로\n           정의됩니다.\nthead      테이블 열의 헤드를 정의하는 일련의 행을 정의합니다.\ntr         테이블의 셀 행을 정의합니다. 그런 다음 td(데이터 셀) 및 th(헤더 셀) 요소를 혼합하여 행의 셀을\n           설정할 수 있습니다.ents.\n\n\n양식#\n\nHTML은 여러가지 입력 가능한 요소를 제공합니다. 이런 요소를 서로 조합하면 사용자가 내용을 채우고, 웹사이트나 어플리케이션에 제출할 수\n있습니다. HTML 폼 안내서에 더욱 다양한 내용이 있습니다.\n\n요소         설명\nbutton     클릭 가능한 버튼을 나타냅니다. 버튼은 양식 내부는 물론 간단한 표준 버튼 기능이 필요한 곳이라면 문서\n           어디에나 배치할 수 있습니다. 기본값의 HTML 버튼은 사용자 에이전트의 호스트 플랫폼과 비슷한 디자인을\n           따라가지만, 외형은 CSS로 변경할 수 있습니다.\ndatalist   다른 컨트롤에서 고를 수 있는 가능한, 혹은 추천하는 선택지를 나타내는 option 요소 여럿을 담습니다.\nfieldset   웹 양식의 여러 컨트롤과 레이블(label)을 묶을 때 사용합니다.\nform       정보를 제출하기 위한 대화형 컨트롤을 포함하는 문서 구획을 나타냅니다.\ninput      웹 기반 양식에서 사용자의 데이터를 받을 수 있는 대화형 컨트롤을 생성합니다. 사용자 에이전트에 따라서\n           다양한 종류의 입력 데이터 유형과 컨트롤 위젯이 존재합니다. 입력 유형과 특성의 다양한 조합 가능성으로\n           인해, <input> 요소는 HTML에서 제일 강력하고 복잡한 요소 중 하나입니다.\nlabel      사용자 인터페이스 항목의 설명을 나타냅니다.\nlegend     부모 fieldset 콘텐츠의 설명을 나타냅니다.\nmeter      특정 범위 내에서의 스칼라 값, 또는 백분율 값을 나타냅니다.\noptgroup   select 요소의 옵션을 묶을 수 있습니다.\noption     select, optgroup, datalist 요소의 항목을 정의합니다. 그러므로, <option>을\n           사용해 팝업 메뉴 등 목록에서 하나의 항목을 나타낼 수 있습니다.\noutput     웹 사이트나 앱에서 계산이나 사용자 행동의 결과를 삽입할 수 있는 컨테이너 요소입니다.\nprogress   어느 작업의 완료 정도를 나타내며, 주로 진행 표시줄의 형태를 띕니다.\nselect     옵션 메뉴를 제공하는 컨트롤을 나타냅니다.\ntextarea   멀티라인 일반 텍스트 편집 컨트롤을 나타냅니다.\n\n\n대화형 요소#\n\nHTML은 상호작용 가능한 사용자 인터페이스 객체를 만들 때 사용할 수 있는 요소를 지원합니다.\n\n요소        설명\ndetails   \"열림\" 상태일 때만 내부 정보를 보여주는 정보 공개 위젯을 생성합니다. 요약이나 레이블은 summary\n          요소를 통해 제공할 수 있습니다.\ndialog    닫을 수 있는 경고, 검사기, 창 등 대화 상자 및 기타 다른 상호작용 가능한 컴포넌트를 나타냅니다.\nsummary   (\"상세\") 요소의 공개 상자에 대한 요약, 캡션 또는 범례를 지정한다. <요약> 요소를 클릭하면 부모\n          <상세> 요소의 상태가 열리거나 닫힌다.\n\n\n웹 컴포넌트#\n\n웹 컴포넌트는 완전히 새로운 형태의 요소를 생성한 후 일반적인 HTML처럼 사용할 수 있는 기술입니다. 또한 표준 HTML 요소의 맞춤 버전을\n만들 수도 있습니다.\n\n요소         설명\nslot       웹 컴포넌트 사용자가 자신만의 마크업으로 채워 별도의 DOM 트리를 생성하고, 컴포넌트와 함께 표현할 수\n           있는 웹 컴포넌트 내부의 플레이스홀더입니다.\ntemplate   페이지를 불러온 순간 즉시 그려지지는 않지만, 이후 JavaScript를 사용해 인스턴스를 생성할 수 있는\n           HTML 코드를 담을 방법을 제공합니다.\n\n\n폐기됐거나 사용하지 않는 요소들#\n\n> 경고: 다음은 더 이상 사용하지 않고, 사용해서도 안되는 오래된 HTML 요소입니다. 새로운 프로젝트에서 절대 사용해서는 안되고, 오래된\n> 프로젝트에서도 가능한 빨리 대체해야 합니다. 아래 목록은 정보성 목적으로만 존재합니다.\n\n요소          설명\nacronym     작성자가 단어의 두문자어 또는 약어를 구성하는 일련의 문자를 명확하게 표시할 수 있습니다.\napplet      문서에 Java 애플릿을 포함합니다. 이 요소는 object를 위해 더 이상 사용되지 않습니다.\nbgsound     페이지가 사용되는 동안 백그라운드에서 재생되도록 사운드 파일을 설정합니다. 대신 audio를 사용하세요.\nbig         포함된 텍스트를 주변 텍스트보다 한 수준 더 큰 글꼴 크기로 렌더링합니다(예: 'medium'은\n            'large'가 됨). 크기는 브라우저의 최대 허용 글꼴 크기로 제한됩니다.\ncenter      포함하는 요소 내에서 수평 중앙에 블록 수준 또는 인라인 콘텐츠를 표시합니다.\ncontent     Web Components 기술 제품군의 구식 부분은 삽입 지점으로 Shadow DOM 내부에서 사용되었으며\n            일반 HTML에서는 사용되지 않았습니다. 이제 slot 요소로 대체되어 Shadow DOM을 삽입할 수 있는\n            DOM의 지점을 생성합니다.\ndir         잠재적으로 사용자 에이전트에 의해 적용된 스타일 및 아이콘이 있는 파일 및/또는 폴더의 디렉토리에 대한\n            컨테이너입니다. 이 오래된 요소를 사용하지 마십시오. 대신 파일 목록을 포함하여 목록에 ul 요소를 사용해야\n            합니다.\nfont        콘텐츠의 글꼴 크기, 색상 및 면을 정의합니다.\nframe       다른 HTML 문서를 표시할 수 있는 특정 영역을 정의합니다. 프레임은 frameset 내에서 사용해야\n            합니다.\nframeset    frame 요소를 포함하는 데 사용됩니다.\nimage       img 요소에 대한 오래되고 제대로 지원되지 않는 전구체입니다. 사용해서는 안됩니다.\nmarquee     텍스트의 스크롤 영역을 삽입하는 데 사용됩니다. 속성을 사용하여 텍스트가 콘텐츠 영역의 가장자리에 도달할 때\n            발생하는 상황을 제어할 수 있습니다.\nmenuitem    사용자가 팝업 메뉴를 통해 호출할 수 있는 명령을 나타냅니다. 여기에는 상황에 맞는 메뉴와 메뉴 버튼에\n            연결될 수 있는 메뉴가 포함됩니다.\nnobr        포함된 텍스트가 여러 줄에 걸쳐 자동으로 줄바꿈되지 않도록 방지하여 잠재적으로 사용자가 텍스트의 전체 너비를\n            보기 위해 가로로 스크롤해야 합니다.\nnoembed     embed 요소를 지원하지 않거나 작성자가 사용하려는 embedded content 유형을 지원하지 않는\n            브라우저에 대한 대안 또는 \"대체\" 콘텐츠를 제공하는 더 이상 사용되지 않는 비표준 방식입니다. 이 요소는\n            object 요소의 여는 태그와 닫는 태그 사이에 대체 콘텐츠를 배치하기 위해 HTML 4.01 이상에서 더\n            이상 사용되지 않습니다.\nnoframes    frame 요소를 지원하지 않거나 지원하지 않는 브라우저에 표시할 콘텐츠를 제공합니다. 가장 일반적으로\n            사용되는 브라우저는 프레임을 지원하지만 텍스트 모드 브라우저뿐만 아니라 일부 모바일 브라우저를 포함한 특정\n            특수 용도 브라우저를 포함하여 예외가 있습니다.\nparam       object 요소에 대한 매개변수를 정의합니다.\nplaintext   object 요소의 매개변수를 정의합니다.\nrb          ruby 주석의 기본 텍스트 구성 요소, 즉 주석이 추가되는 텍스트를 구분하는 데 사용됩니다. 하나의\n            <rb> 요소는 기본 텍스트의 각 개별 원자 세그먼트를 래핑해야 합니다.\nrtc         ruby 표기의 기반 텍스트 구성요소(루비 주석을 적용하려는 글자)를 나눌 때 사용합니다. 하나의 <rb>\n            요소는 기반 텍스트에서의 최소 단위를 하나 감싸야 합니다.\nshadow      rb 요소가 표시하는 문자의 의미에 대한 주석을 나타냅니다. <rb>는 발음(rt)과 의미(<rtc>) 둘\n            다 가질 수 있습니다.\nspacer      페이지에 빈 공간을 삽입할 수 있습니다. 웹 디자이너가 실제로 이미지를 사용하지 않고 웹 페이지에 공백을\n            추가하는 데 사용했던 단일 픽셀 레이아웃 이미지와 동일한 효과를 달성하기 위해 Netscape가\n            고안했습니다. 그러나 <spacer>는 더 이상 주요 브라우저에서 지원되지 않으며 이제 간단한 CSS를\n            사용하여 동일한 효과를 얻을 수 있습니다.\nstrike      텍스트 위에 취소선(수평선)을 그립니다.\ntt          사용자 에이전트 기본 모노스페이스 글꼴을 사용하여 표시되는 인라인 텍스트를 생성합니다. 이 요소는\n            텔레타이프, 텍스트 전용 화면 또는 라인 프린터와 같은 고정 너비 디스플레이에 표시되는 텍스트를 렌더링하기\n            위해 만들어졌습니다.\nxmp         시작 태그와 끝 태그 사이의 HTML을 해석하지 않고 고정 폭 글꼴을 사용하여 텍스트를 렌더링합니다.\n            HTML2 사양에서는 한 줄에 80자를 허용할 만큼 충분히 넓게 렌더링해야 한다고 권장했습니다.","routePath":"/note/html/tag","lang":"","toc":[{"text":"메인 루트","id":"메인-루트","depth":2,"charIndex":143},{"text":"문서 메타데이터","id":"문서-메타데이터","depth":2,"charIndex":247},{"text":"섹션 루트","id":"섹션-루트","depth":2,"charIndex":980},{"text":"콘텐츠 섹션","id":"콘텐츠-섹션","depth":2,"charIndex":1055},{"text":"텍스트 콘텐츠","id":"텍스트-콘텐츠","depth":2,"charIndex":2255},{"text":"인라인 텍스트 시멘틱","id":"인라인-텍스트-시멘틱","depth":2,"charIndex":3896},{"text":"이미지 & 멀티미디어","id":"이미지--멀티미디어","depth":2,"charIndex":7168},{"text":"내장 콘텐츠","id":"내장-콘텐츠","depth":2,"charIndex":7849},{"text":"SVG와 MathML","id":"svg와-mathml","depth":2,"charIndex":8491},{"text":"스크립트","id":"스크립트","depth":2,"charIndex":8841},{"text":"수정사항 표시","id":"수정사항-표시","depth":2,"charIndex":9242},{"text":"표 콘텐츠","id":"표-콘텐츠","depth":2,"charIndex":9474},{"text":"양식","id":"양식","depth":2,"charIndex":10065},{"text":"대화형 요소","id":"대화형-요소","depth":2,"charIndex":11204},{"text":"웹 컴포넌트","id":"웹-컴포넌트","depth":2,"charIndex":11549},{"text":"폐기됐거나 사용하지 않는 요소들","id":"폐기됐거나-사용하지-않는-요소들","depth":2,"charIndex":11878}],"frontmatter":{},"version":""},{"title":"关键性能指标","content":"#\n\n\n连接性能#\n\n\n延迟#\n\n延迟是指 IP 数据包从一个网络端点到另一个网络端点所话费的时间。与之相关的是往返延时(RTT - Rount-Trip Time),\n它是延迟的时间的两倍。延迟是制约 Web 性能的主要瓶颈，尤其对于 HTTP 这样的协议，因为其中包含大量往返于服务器的请求\n\n(一些移动设备为节省电力，可能暂时关闭移动数据信号。如果设备需要临时唤醒移动数据设备，建立新连接时还要增加数秒的延迟)\n\n\n宽带#\n\n只要宽带没有饱和，两个网络端点之间的连接会一次处理尽可能多的数据量。依据 Web 页面饮用资源的大小和网络连接的传输能力，宽带可能会成为性能的瓶颈\n\n\nDNS 查询#\n\n在客户端能够获取 Web 页面钱，它需要通过域名系统把主机名称转换成 IP 地址，DNS 相当于互联网上的电话号码薄。获取的 HTML\n页面中所引用；哦你给的各个不同余名也需要转换；幸运的事，一个域名只需转换一次\n\n\n建立连接时间#\n\n在客户端和服务器之间建立连接需要往返数据应答， 成为‘三次握手’。\n\n\nTLS(Transport Layer Security)协商时间#\n\n如果客户端发起 HTTPS 连接，它需要进行 TLS 协商; TLS 用来取代 SSL(Secure Sockets\nLayer)。除了服务器和客户端的计算处理耗时之外，TLS 还会造成额外的往返传输\n\n\n单点故障(SPOF - Single Point Of Failure)#\n\nWeb 页面上引用的某个资源，如果它出问题，将延迟整个页面的加载(甚至导致页面出错)。\n\n\n服务器或内容#\n\n\nTTFB(Time To First Byte)#\n\n客户端从开始定位到 Web\n页面，直接收到主体页面响应的第一字节所耗费的时间。它包含了之前连接性能各种耗时，还要加上服务器的处理时间。对于主体页面上的资源，TTFB\n测量的是从浏览器发起请求至收到其第一字节之间的耗时。\n\n\nContent Download#\n\n等同于被请求资源的最后字节到达时间。\n\n\n开始渲染时间(Time to First Meaningful Paint)#\n\n客户端的屏幕上什么时候开始现实内容？这个指标测量的是用户看到空白页面的时长\n\n\n文档加载完成时间#\n\n这是客户端浏览器认为页面加载完毕的时间\n\n\n额外考虑#\n\n * 更多的字节\n * 更多的资源\n * 更高的复杂度\n * 更多的域名\n * 更多的 TCP socket\n\n\n网络#\n\n减少 http 请求#\n\n * 合并 js\n\n * 合并 css\n\n * css sprite\n\n * base64\n\n减少资源大小#\n\n * html, css, js minify\n * gzip 压缩\n * image minify\n * 不滥用字体\n\n缓存#\n\n * DNS 缓存\n\n<link rel=\"dns-prefetch\" href=\"//ajax.googleapis.com\" />\n\n\n * http 缓存(Cache-Control, E-tag)\n\n * 部署 CDN\n\n * 使用长缓存\n\n * 避免重定向\n\n * TCP 连接(参考: https://istlsfastyet.com/)\n\n<link rel=\"precontent\" href=\"//fonts.google.com\" crossorigin />\n\n\n * 避免阻塞 CSS/JS\n\n\n浏览器渲染#\n\n\nDOM 优化#\n\n * 避免进行繁琐的 DOM 操作\n * 复杂的 UI 元素, 设置 position 为 absolute 或者 fixed\n * requestAnimationFrame 代替 setTimeout\n * 适当使用 canvas\n * 使用事件代理\n\n\n样式优化#\n\n * 尽量避免内联样式\n * 禁用 css Expression\n * 尽量使用 css 动画\n\n\nhtml 优化#\n\n * css 文件放头部, js 放底部或者异步处理\n\n\n图片优化#\n\n * Lazyload\n\n\n异步#\n\n * 常用数据缓存","routePath":"/note/performance/metric","lang":"","toc":[{"text":"连接性能","id":"连接性能","depth":2,"charIndex":3},{"text":"延迟","id":"延迟","depth":3,"charIndex":11},{"text":"宽带","id":"宽带","depth":3,"charIndex":210},{"text":"DNS 查询","id":"dns-查询","depth":3,"charIndex":291},{"text":"建立连接时间","id":"建立连接时间","depth":3,"charIndex":409},{"text":"TLS(Transport Layer Security)协商时间","id":"tlstransport-layer-security协商时间","depth":3,"charIndex":454},{"text":"单点故障(SPOF - Single Point Of Failure)","id":"单点故障spof---single-point-of-failure","depth":3,"charIndex":593},{"text":"服务器或内容","id":"服务器或内容","depth":2,"charIndex":678},{"text":"TTFB(Time To First Byte)","id":"ttfbtime-to-first-byte","depth":3,"charIndex":688},{"text":"Content Download","id":"content-download","depth":3,"charIndex":827},{"text":"开始渲染时间(Time to First Meaningful Paint)","id":"开始渲染时间time-to-first-meaningful-paint","depth":3,"charIndex":867},{"text":"文档加载完成时间","id":"文档加载完成时间","depth":3,"charIndex":948},{"text":"额外考虑","id":"额外考虑","depth":2,"charIndex":981},{"text":"网络","id":"网络","depth":2,"charIndex":1045},{"text":"减少 http 请求","id":"减少-http-请求","depth":4,"charIndex":1050},{"text":"减少资源大小","id":"减少资源大小","depth":4,"charIndex":1110},{"text":"缓存","id":"缓存","depth":4,"charIndex":1180},{"text":"浏览器渲染","id":"浏览器渲染","depth":2,"charIndex":1445},{"text":"DOM 优化","id":"dom-优化","depth":3,"charIndex":1454},{"text":"样式优化","id":"样式优化","depth":3,"charIndex":1593},{"text":"html 优化","id":"html-优化","depth":3,"charIndex":1650},{"text":"图片优化","id":"图片优化","depth":3,"charIndex":1689},{"text":"异步","id":"异步","depth":3,"charIndex":1710}],"frontmatter":{},"version":""},{"title":"RAIL","content":"#\n\nRAIL(Response Animation Idle Load)의 성능의 핵심은 '사용자에게 초점을 맞추세요. 최종 목표는 사이트가 특정 장치에서\n빠르게 작동하도록 만드는 것이 아니라 사용자를 행복하게 만드는 것'입니다.\n\n\nResponse#\n\n100ms 이내에 사용자 입력을 승인하여 즉시 사용자에게 응답합니다.\n\n\nAnimation#\n\n애니메이션을 적용할 때, 각 프레임을 16ms 미만으로 렌더링하여 일관성을 유지하고 버벅거림을 방지하세요.\n\n\nIdle#\n\n기본 JavaScript 스레드를 사용하는 경우, 50ms 미만의 시간 동안 청크로 작업하여 사용자 상호작용을 위한 스레드를 확보합니다.\n\n\nLoad#\n\n5초 이내에 상호작용 가능한 콘텐츠를 제공합니다.\n\n\n참고#\n\n * https://web.dev/articles/rail?hl=ko#focus_on_the_user","routePath":"/note/performance/rail","lang":"","toc":[{"text":"Response","id":"response","depth":2,"charIndex":127},{"text":"Animation","id":"animation","depth":2,"charIndex":179},{"text":"Idle","id":"idle","depth":2,"charIndex":253},{"text":"Load","id":"load","depth":2,"charIndex":339},{"text":"참고","id":"참고","depth":3,"charIndex":376}],"frontmatter":{},"version":""},{"title":"Hooks","content":"#\n\n\nuseState#\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  return <h1 onClick={() => setCount(count + 1)}>{count}</h1>;\n};\n\n\n\nuseReducer#\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"increment\":\n      return { count: state.count + 1 };\n    case \"decrement\":\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\n    </>\n  );\n}\n\n\n\nuseContext#\n\n\n\nconst Context = createContext({ theme: \"light\" });\n\nconst Child = () => {\n  const { theme } = useContext(Context);\n  return <>{theme}</>;\n};\n\nconst Parent = () => {\n  return <Child />;\n};\n\nconst App = () => {\n  return (\n    <Context.Provider value={{ theme: \"dark\" }}>\n      <Parent />\n    </Context.Provider>\n  );\n};\n\nexport default App;\n\n\n\neffect관련#\n\n\nuseEffect#\n\nconst App = () => {\n  useEffect(() => {\n    console.log(111);\n  }, []);\n  return <div>title</div>;\n};\n\n\n\nuseLayoutEffect#\n\nconst App = () => {\n  useLayoutEffect(() => {\n    console.log(111);\n  }, []);\n  return <div>title</div>;\n};\n\n\n\nuseInsertionEffect#\n\nconst App = () => {\n  useInsertionEffect(() => {\n    console.log(111);\n  }, []);\n  return <div>title</div>;\n};\n\n\n\nuseEffectEvent#\n\n\n\n\n\nref관련#\n\n\nuseRef#\n\n\n\nconst Child = forwardRef((props: any, ref: any) => {\n  return <input ref={ref} />;\n});\n\nconst Parent = () => {\n  const inputRef = (useRef < HTMLInputElement) | (null > null);\n  const onClick = () => {\n    if (inputRef.current) {\n      inputRef.current.value = \"reset\";\n    }\n  };\n  return (\n    <>\n      <Child ref={inputRef} />\n      <button onClick={onClick}>reset</button>\n    </>\n  );\n};\n\nconst App = () => {\n  return <Parent />;\n};\n\nexport default App;\n\n\n\nuseImperativeHandle#\n\n\n\n\n\n성능관련#\n\n\nuseMemo#\n\nconst App = () => {\n  const title = useMemo(() => \"dao\", []);\n  return <div>{title}</div>;\n};\n\n\n\nuseCallback#\n\nconst App = () => {\n  const setTitle = useCallback(() => {\n    console.log(111);\n  }, []);\n  return (\n    <button\n      type=\"button\"\n      onClick={setTitle}\n    >\n      +\n    </button>\n  );\n};\n\n\n\nuseMemoCache#\n\n\n\n\n\n디버깅관련#\n\n\nuseDebugValue#\n\n\n\n\n\nconcurrent 동시성모드#\n\n\nuseTransition#\n\nconst App = () => {\n  const [value, setValue] = useState(\"\");\n  const [isPending, startTransition] = useTransition();\n\n  const onChange = (e: ChangeEvent<HTMLInputElement>) => {\n    // 긴급처리건.\n    setValue(e.target.value);\n    startTransition(() => {\n      // 후순위 처리.\n      setContent(e.target.value);\n    });\n  };\n  return (\n    <>\n      <input\n        value={value}\n        onChange={onChange}\n      />\n      <div>{value.length}</div>\n    </>\n  );\n};\n\n\n\nuseDeferredValue#\n\nconst App = () => {\n  const [value, setValue] = useState(\"\");\n  const lowValue = useDeferredValue(value.length);\n\n  const onChange = (e: ChangeEvent<HTMLInputElement>) => {\n    setValue(e.target.value);\n  };\n\n  return (\n    <>\n      <input\n        value={value}\n        onChange={onChange}\n      />\n      <div>{lowValue}</div>\n    </>\n  );\n};\n\n\n\nuseSyncExternalStore(useMutableSource)#\n\n// todoStore.js\nlet nextId = 0;\nlet todos = [{ id: nextId++, text: \"Todo #1\" }];\nlet listeners = [];\n\nexport const todosStore = {\n  addTodo() {\n    todos = [...todos, { id: nextId++, text: \"Todo #\" + nextId }];\n    emitChange();\n  },\n  subscribe(listener) {\n    listeners = [...listeners, listener];\n    return () => {\n      listeners = listeners.filter((l) => l !== listener);\n    };\n  },\n  getSnapshot() {\n    return todos;\n  },\n};\n\nfunction emitChange() {\n  for (let listener of listeners) {\n    listener();\n  }\n}\n\n// App.jsx\nconst App = () => {\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n  return (\n    <>\n      <button onClick={todosStore.addTodo}>Add todo</button>\n      <hr />\n      <ul>\n        {todos.map((todo) => (\n          <li key={todo.id}>{todo.text}</li>\n        ))}\n      </ul>\n    </>\n  );\n};\n\n\n\nRSC(React Server Component)#\n\n\nuseId#\n\n// 여러번 불러오는 컴포넌트일 경우 아래와 같이 필요함.\nconst App = () => {\n  const inputId = useId();\n\n  return (\n    <>\n      <input id={`${inputId}-firstName`} />\n      <input id={`${inputId}-lastName`} />\n    </>\n  );\n};\n// ssr일경우 생성한 id가 다른경우가 있음.\n// 1. 서버단 생성시 id=\"1\" 생성\n// 2. <div id=\"1\"></div>을 client에게 전달\n// 3. csr랭딩시 hydrate를 통해서 id=\"2\" 로 처리.\n\n\n\nuse#\n\n\n\n\n\nuseCacheRefresh#\n\n\n\n\n\nuseOptimistic#\n\n\n\n\n\nuseFormStatus(react-dom)#\n\n\n","routePath":"/note/react/hooks","lang":"","toc":[{"text":"useState","id":"usestate","depth":3,"charIndex":3},{"text":"useReducer","id":"usereducer","depth":3,"charIndex":144},{"text":"useContext","id":"usecontext","depth":3,"charIndex":716},{"text":"effect관련","id":"effect관련","depth":2,"charIndex":1073},{"text":"useEffect","id":"useeffect","depth":3,"charIndex":1085},{"text":"useLayoutEffect","id":"uselayouteffect","depth":3,"charIndex":1202},{"text":"useInsertionEffect","id":"useinsertioneffect","depth":3,"charIndex":1331},{"text":"useEffectEvent","id":"useeffectevent","depth":3,"charIndex":1466},{"text":"ref관련","id":"ref관련","depth":2,"charIndex":1487},{"text":"useRef","id":"useref","depth":3,"charIndex":1496},{"text":"useImperativeHandle","id":"useimperativehandle","depth":3,"charIndex":1968},{"text":"성능관련","id":"성능관련","depth":2,"charIndex":1994},{"text":"useMemo","id":"usememo","depth":3,"charIndex":2002},{"text":"useCallback","id":"usecallback","depth":3,"charIndex":2109},{"text":"useMemoCache","id":"usememocache","depth":3,"charIndex":2321},{"text":"디버깅관련","id":"디버깅관련","depth":2,"charIndex":2340},{"text":"useDebugValue","id":"usedebugvalue","depth":3,"charIndex":2349},{"text":"concurrent 동시성모드","id":"concurrent-동시성모드","depth":2,"charIndex":2369},{"text":"useTransition","id":"usetransition","depth":3,"charIndex":2389},{"text":"useDeferredValue","id":"usedeferredvalue","depth":3,"charIndex":2860},{"text":"useSyncExternalStore(useMutableSource)","id":"usesyncexternalstoreusemutablesource","depth":3,"charIndex":3225},{"text":"RSC(React Server Component)","id":"rscreact-server-component","depth":2,"charIndex":4121},{"text":"useId","id":"useid","depth":3,"charIndex":4152},{"text":"use","id":"use","depth":3,"charIndex":4494},{"text":"useCacheRefresh","id":"usecacherefresh","depth":3,"charIndex":4504},{"text":"useOptimistic","id":"useoptimistic","depth":3,"charIndex":4526},{"text":"useFormStatus(react-dom)","id":"useformstatusreact-dom","depth":3,"charIndex":4546}],"frontmatter":{},"version":""},{"title":"","content":"函数组件 (Function component)#\n\nfunction Greeting(props) {\n  return <div>Hi {props.name}!</div>;\n}\nGreeting.defaultProps = {\n  name: \"Guest\",\n};\n\n\n属性解构 (Destructuring props)#\n\nfunction Greeting({ name = \"dao\" }) {\n  return <div>Hi {props.name}!</div>;\n}\n\n\nJSX 中的属性展开 (JSX spread attributes)#\n\nfunction Greeting({ name, ...restProps }) {\n  return <div {...restProps}>Hi {name}!</div>;\n}\n\n\n合并解构属性和其它值 (Merge destructured props with other values)#\n\nfunction MyButton(props) {\n  return (\n    <button\n      className=\"btn\"\n      {...props}\n    />\n  );\n}\n\n\n条件渲染 (Conditional rendering)#\n\n// 如果\n{\n  condition && <span>Rendered when `truthy`</span>;\n}\n// 除非\n{\n  condition || <span>Rendered when `falsy`</span>;\n}\n// 如果-否则\n{\n  condition ? <span>Rendered when `truthy`</span> : <span>Rendered when `falsy`</span>;\n}\n\n\n渲染属性 (Render prop)#\n\nconst Width = ({ children }) => children(500);\n<Width>{(width) => <div>window is {width}</div>}</Width>;\n\n\n代理组件 (Proxy component)#\n\nconst Button = props => <button type=\"button\" {...props}>\n\n\n样式组件 (Style component)#\n\n\nconst PrimaryBtn = props => <Btn {...props} primary />;\n\nconst Btn = ({ className, primary, ...props }) => (\n  <button\n    type=\"button\"\n    className={classnames(\"btn\", primary && \"btn-primary\", className)}\n    {...props}\n  />\n);\n\n<PrimaryBtn />\n<Btn primary />\n\n\n组织事件 (Event switch)#\n\nhandleEvent({type}) {\n  switch(type) {\n    case \"click\":\n      return require(\"./actions/doStuff\")(/* action dates */)\n    case \"mouseenter\":\n      return this.setState({ hovered: true })\n    case \"mouseleave\":\n      return this.setState({ hovered: false })\n    default:\n      return console.warn(`No case for event type \"${type}\"`)\n  }\n}\n\n\n布局组件 (Layout component)#\n\n<HorizontalSplit\n  leftSide={<SomeSmartComponent />}\n  rightSide={<AnotherSmartComponent />}\n/>;\nconst HorizontalSplit = ({ leftSide, rightSide }) => (\n  <FlexContainer>\n    <div>{leftSide}</div>\n    <div>{rightSide}</div>\n  </FlexContainer>\n);\n\n\n容器组件 (Container component)#\n\n容器用来获取数据然后渲染到子组件上，仅仅如此。 —Jason Bonta\n\nconst CommentList = ({ comments }) => (\n  <ul>\n    {comments.map(comment => (\n      <li>\n        {comment.body}-{comment.author}\n      </li>\n    ))}\n  </ul>\n);\n\nconst CommentListContainer = () => {\n  useEffect(() => {\n    $.ajax({\n      url: \"/my-comments.json\",\n      dataType: 'json',\n      success: comments =>\n        this.setState({comments: comments});\n    })\n  },[])\n\n  return <CommentList comments={this.state.comments} />\n}\n\n\n高阶组件 (Higher-order component)#\n\n * 接受一个或多个组件作为输入\n * 输出一个组件\n\nconst WrapContainer = (Component) => {\n  return () => (\n    <Container>\n      <Component />\n    </Container>\n  );\n};\n\n\n受控组件#\n\ninput 的 value 和 state 同步\n\nsub Components#\n\nconst ListGroup = ({ children }) => <ul>{children}</ul>;\nconst List = () => (\n  <Fragment>\n    <li>1</li>\n    <li>2</li>\n  </Fragment>\n);\n\nList.group = ListGroup;\n\nconst App = () => (\n  <List.group>\n    <List />\n  </List.group>\n);\n\n\ncontext#\n\nconst ContextCounter = React.createContext();\n\nconst App = () => (\n  <ContextCounter.Provider value={0}>\n    <Child />\n  </ContextCounter.Provider>\n);\n\nconst Child = () => {\n  const count = useContext(ContextCounter);\n  return <h1>{count}</h1>;\n};\n\n\ncreatePortal#\n\n\n\nconst Po = ({ children }) => {\n  return createPortal(children, document.getElementById(\"modal\"));\n};\n\nexport default Po;\n\n\nProfiler#\n\n\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n\n  const onRender = (id, phase, actualDuration, baseDuration, startTime, commitTime, interactions) => {\n    // id: string - 发生提交的 Profiler 树的 id。 如果有多个 profiler，它能用来分辨树的哪一部分发生了“提交”。\n    // phase: \"mount\" | \"update\" - 判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。\n    // actualDuration: number - 本次更新在渲染 Profiler 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。（例如 React.memo，useMemo，shouldComponentUpdate）。 理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。\n    // baseDuration: number - 在 Profiler 树中最近一次每一个组件 render 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。\n    // startTime: number - 本次更新中 React 开始渲染的时间戳。\n    // commitTime: number - 本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。\n    // interactions: Set - 当更新被制定时，“interactions” 的集合会被追踪。（例如当 render 或者 setState 被调用时）。\n  };\n\n  return (\n    <Profiler\n      id=\"App\"\n      onRender={onRender}\n    >\n      <div>{count}</div>\n      <button onClick={() => setCount(count + 1)}>sc</button>\n    </Profiler>\n  );\n};\n\nexport default App;\n","routePath":"/note/react/pattern","lang":"","toc":[{"text":"函数组件 (Function component)","id":"函数组件-function-component","depth":4,"charIndex":-1},{"text":"属性解构 (Destructuring props)","id":"属性解构-destructuring-props","depth":4,"charIndex":142},{"text":"JSX 中的属性展开 (JSX spread attributes)","id":"jsx-中的属性展开-jsx-spread-attributes","depth":4,"charIndex":251},{"text":"合并解构属性和其它值 (Merge destructured props with other values)","id":"合并解构属性和其它值-merge-destructured-props-with-other-values","depth":4,"charIndex":383},{"text":"条件渲染 (Conditional rendering)","id":"条件渲染-conditional-rendering","depth":4,"charIndex":546},{"text":"渲染属性 (Render prop)","id":"渲染属性-render-prop","depth":4,"charIndex":803},{"text":"代理组件 (Proxy component)","id":"代理组件-proxy-component","depth":4,"charIndex":931},{"text":"样式组件 (Style component)","id":"样式组件-style-component","depth":4,"charIndex":1016},{"text":"组织事件 (Event switch)","id":"组织事件-event-switch","depth":4,"charIndex":1307},{"text":"布局组件 (Layout component)","id":"布局组件-layout-component","depth":4,"charIndex":1670},{"text":"容器组件 (Container component)","id":"容器组件-container-component","depth":4,"charIndex":1943},{"text":"高阶组件 (Higher-order component)","id":"高阶组件-higher-order-component","depth":4,"charIndex":2445},{"text":"受控组件","id":"受控组件","depth":4,"charIndex":2624},{"text":"sub Components","id":"sub-components","depth":4,"charIndex":2657},{"text":"context","id":"context","depth":4,"charIndex":2907},{"text":"createPortal","id":"createportal","depth":4,"charIndex":3167},{"text":"Profiler","id":"profiler","depth":4,"charIndex":3307}],"frontmatter":{},"version":""},{"title":"React성능 최적화","content":"#\n\n\nDiff Algorithm (VDOM)#\n\n1. Tree diff 동일레벨(depth) 요소끼리 비교#\n\n// 전부 교체\n<section>\n\t<div className=\"content\">hello</div>\n</section>\n<div className=\"content\">hello</div>\n\n\n2. component 비교#\n\n// 전부 교체\nconst About = () => <div>About</div>;\nconst Main = () => <div>About</div>;\n\nvisible ? <About /> : <Main />;\n\n\n3. Element Type 비교#\n\n// 전부 교체\n<section>\n\t<div className=\"content\">hello</div>\n</section>\n<div>\n\t<div className=\"content\">hello</div>\n</div>\n\n// Element가 동일하니 다음 단계로 pass\n<div>\n\t<section className=\"content\">hello</section>\n</div>\n<div>\n\t<div className=\"content\">hello</div>\n</div>\n\n\n\n4. Element Props 비교#\n\n// Element가 동일할 경우 props 변경된 부분만 교체, 순서 중요하지 않음. 스타일 obj도 마찬가지.\n<div style={{width: 40}} id=\"a\">\n\t<div className=\"content\">hello</div>\n</div>\n<div style={{width: 70, height: 30}} id=\"b\">\n\t<div className=\"content\">hello</div>\n</div>\n\n// style값이 동일하더라도 변경은 없지만 내부적으로 변화를 비교함\n<div style={{width: 40}}>\n\t<div className=\"content\">hello</div>\n</div>\n<div style={{width: 40}}>\n\t<div className=\"content\">hello</div>\n</div>\n\n\n5. key(우선순위 제일 높음.)#\n\n// key설정 하지 않으면 null로 처리.\n<div></div>\n<div id=\"a\"></div>\n\n// key 다르면 판단하지 않고 교체.\n<div key=\"1\">123</div>\n<div key=\"2\">123</div>\n\n// key & type(component, element포함)이 동일한 경우 vdom(fiber) 노드를 그대로 사용. (업데이트와 생성의 차이))\n// 전부 교체.\n<div key=\"1\">123</div>\n<p key=\"1\">123</p>\n\n\n6. 멀티노드 비교#\n\n 1. 1단계(비교)\n\n// newChildNode, oldChildNode 동시 끝나는 경우(Update 처리)\n// old\n<ul>\n<li key=\"0\" className=\"normal\">0</li>\n<li key=\"1\" className=\"normal\">1</li>\n<li key=\"2\" className=\"normal\">2</li>\n</ul>\n// new\n<ul>\n<li key=\"0\" className=\"bold\">0</li>\n<li key=\"1\" className=\"bold\">1</li>\n<li key=\"2\" className=\"bold\">2</li>\n</ul>\n//\n// newChildNode 순회가 먼저 끝나는 경우(Vdom Delection 처리)\n// old\n<ul>\n<li key=\"0\">0</li>\n<li key=\"1\">1</li>\n<li key=\"2\">2</li> <!-- Delection 처리 -->\n</ul>\n// new\n<ul>\n<li key=\"0\">0</li>\n<li key=\"1\">1</li>\n</ul>\n//\n// oldChildNode 순회가 먼저 끝나는 경우(Vdom Placement 처리)\n// old\n<ul>\n<li key=\"0\">0</li>\n<li key=\"1\">1</li>\n</ul>\n// new\n<ul>\n<li key=\"0\">0</li>\n<li key=\"1\">1</li>\n<li key=\"2\">2</li> <!-- Placement 처리 -->\n</ul>\n//\n// key가 동일하고 type이 다를 경우 oldChildNode Deletion처리.\n// old\n<ul>\n<li key=\"0\">0</li>\n<li key=\"1\">1</li> <!-- Delection 처리 -->\n<li key=\"2\">2</li>\n</ul>\n// new\n<ul>\n<li key=\"0\">0</li>\n<div key=\"1\">1</div>\n<li key=\"2\">2</li>\n</ul>\n//\n// oldChildNode, newChildNode모두 남아 있는 경우(key가 다른 부분이 있으면 바로 다음단계.)\n// old\n<ul>\n<li key=\"0\">0</li>\n<li key=\"1\">1</li>\n<li key=\"2\">2</li>\n</ul>\n// new\n<ul>\n<li key=\"0\">0</li>\n<li key=\"2\">2</li>\n<li key=\"1\">1</li>\n</ul>\n\n\n 2. 2단계(교체)\n\n- 빠른 처리를 위해서 남아있는 oldChildNode를 map객체에 [key]: fiber(vdom) 추가한다.\n- placeChild 실행\n    1. lastPlacedIndex = 0\n    2. oldIndex ≥ lastPlaceIndex 일때 이동하지 않고 lastPlaceIndex = oldIndex로 설정.\n    3. oldIndex < lastPlaceIndex 일때 맨 뒤로 이동.\n    4. map객체에 관련된 데이터가 없을 경우 Placement\n    5. oldChildNode순회후 newChildNode랑 매핑되지 않는 부분은 Deletion 처리\n\n// old\n<ul>\n<li key=\"a\">a</li>\n<li key=\"b\">b</li>\n<li key=\"c\">c</li>\n<li key=\"d\">d</li>\n</ul>\n// new\n<ul>\n<li key=\"d\">d</li>\n<li key=\"a\">a</li>\n<li key=\"b\">b</li>\n<li key=\"c\">c</li>\n</ul>\n// lastPlacedIndex = 0;\n// D가 oldChildNode에서의 index가 3임\n// 3 >= lastPlaceIndex 이므로 이동이 필요 없음. lastPlaceIndex = 3으로 지정\n// A가 oldChildNode에서의 index가 0임\n// 1 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.\n// B가 oldChildNode에서의 index가 1임\n// 2 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.\n// C가 oldChildNode에서의 index가 2임\n// 2 < 3(lastPlaceIndex) 이므로 맨뒤로 이동.\n\n\n\nReact render하는 조건(bailout조건)#\n\n * oldProps === newProps\n * context 값의 변화가 있는지?\n * workInProgress.type === current.type (only Dev mode, live-reload)\n * state변화가 있는지 ?? 업데이트 EffectTag가 존재한지, 존재하면 이번 priority 업데이트 task에 포함 되는건지 ?\n\n\n최적화 유형#\n\n 1. PureComponent,shouldComponentUpdate\n 2. React.memo로 캐시(PureComponent로 만들고 싶을때 사용.)\n\n// React는 기본적으로 state변경시 해당 컴포넌트 및 자식 컴포넌트 전부 rerender한다.\n// bailout로직중 newProps === oldProps 여야만 컴포넌트를 랜딩하지 않는다.\n// 하위 컴포넌트에 React.memo 적용시 알고리즘을 실행해서 랭딩한다.\n// 자주 변하는 값은 필요없지만 업데이트가 적거나 static한 컴포넌트는 필요하다.\n// 컴포넌트 자체에서 props, state, context변화가 없고 부모의 부모의 .....  key값이 변화가 없는데 rerender된다.\n\n\n\nconst EffectComponent = () => {\n  console.log(\"render effect Component\");\n  return <>effect Component</>;\n};\n\n// const a = <EffectComponent />\n\n// const diff = (prevProps, nextProps) => {\n//   console.log(prevProps === nextProps);\n//   return prevProps === nextProps;\n// }\n\n// const MemoEffectComponent = React.memo(EffectComponent, diff);\n\nconst App = () => {\n  const [count, setCount] = useState(0); // state또는 context를 건드렸기 때문.\n  const onChange = (e) => {\n    setCount(count + 1);\n  };\n\n  // const b = useMemo(() => <EffectComponent />, [])\n\n  return (\n    <>\n      <h2>Register</h2>\n      <input onChange={onChange} />\n      <p>{count}</p>\n      <EffectComponent />\n      {/* {a} */}\n      {/* <MemoEffectComponent /> */}\n    </>\n  );\n};\n\nexport default App;\n\n\n 3. useMemo, useCallback로 캐시\n\n\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  const handleCount = useCallback(() => {\n    setCount((count) => count + 1);\n  }, []);\n\n  const handleCount2 = useCallback(() => {\n    setCount(count + 1);\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>{count}</h1>\n      <button onClick={handleCount}>+1</button>\n      <button onClick={handleCount2}>+1</button>\n    </div>\n  );\n}\n\n\n 4. inlineObject 사용금지\n\n// bad\n<div style={{width: 200}}></div>\n// good\nconst style = {width:200}\n<div style={style}></div>\n\n\n 5. 익명함수 사용금지.\n\n// bad\n<button onClick={() => {...}}>123</button>\n\n// good\nconst onClick = () => {...};\n<button onClick={onClick}>123</button>\n\n\n 6. key활용\n 7. React.Fragment사용\n\n// bad\n<div>\n  <p>1</p>\n  <p>2</p>\n</div>\n\n// good\n<React.Fragment>\n  <p>1</p>\n  <p>2</p>\n<React.Fragment/>\n\n\n 8.  lazyload(suspense) with webpack\n 9.  transtion(react18)\n 10. immer 사용(구조공유)\n 11. useLayoutEffect, useInsertionEffect에 오래 실행되는 스크립트 사용하지 말것.(useEffect와 달리\n     sync로 실행됨.)\n\n\nReact Design#\n\n * 변화(props, state, context)랑 불변을 분리해서 처리.\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      {/* Title 컴포넌트 분리 */}\n      <h1>h1</h1>\n\n      {/* 이부분 분리 필요 */}\n      <p>{count}</p>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      {/* 이부분 분리 필요 */}\n    </>\n  );\n};\n\n\n * 자주 랜더되는 컴포넌트를 찾고 그 parent노드를 찾아 가면서 최적화.\n\n\n시험단계#\n\n * React forget(React without memo)\n * Offscreen API\n   https://vuejs.org/guide/built-ins/keep-alive.html#include-exclude\n\n\n참고링크#\n\n * https://ko.reactjs.org/docs/reconciliation.html#the-diffing-algorithm\n * https://github.com/facebook/react/blob/bd081376665f5f081dcf4bf72f06b7e563c804\n   6d/packages/react-reconciler/src/ReactChildFiber.old.js#L736\n * https://zhuanlan.zhihu.com/p/20346379\n * https://react.iamkasong.com/diff/multi.html","routePath":"/note/react/performance","lang":"","toc":[{"text":"Diff Algorithm (VDOM)","id":"diff-algorithm-vdom","depth":2,"charIndex":3},{"text":"1. Tree diff 동일레벨(depth) 요소끼리 비교","id":"1-tree-diff-동일레벨depth-요소끼리-비교","depth":4,"charIndex":27},{"text":"2. component 비교","id":"2-component-비교","depth":4,"charIndex":169},{"text":"3. Element Type 비교","id":"3-element-type-비교","depth":4,"charIndex":306},{"text":"4. Element Props 비교","id":"4-element-props-비교","depth":4,"charIndex":589},{"text":"5. key(우선순위 제일 높음.)","id":"5-key우선순위-제일-높음","depth":4,"charIndex":1028},{"text":"6. 멀티노드 비교","id":"6-멀티노드-비교","depth":4,"charIndex":1316},{"text":"React render하는 조건(bailout조건)","id":"react-render하는-조건bailout조건","depth":2,"charIndex":3367},{"text":"최적화 유형","id":"최적화-유형","depth":2,"charIndex":3596},{"text":"React Design","id":"react-design","depth":2,"charIndex":5791},{"text":"시험단계","id":"시험단계","depth":3,"charIndex":6171},{"text":"참고링크","id":"참고링크","depth":3,"charIndex":6302}],"frontmatter":{},"version":""},{"title":"리액트 특징","content":"#\n\n\nReact강점?#\n\n지속가능한 인터랙티브(consistently interactive), 즉 time slice(concurent)\n\n프레임워크 비교에서 리액트가 후순위로 밀려나는 이유는 consistently interactive가 성능에서 제외되었기 때문이다.(링크참고)\n\nreact legacy\n\n\n\nreact concurrent\n\n\n\n\n\n\nAOT(A Head Of Time) vs JIT(Just In Time)#\n\n * AOT\n   * 소스코드를 미리 컴파일\n   * 정적이다\n   * svelte\n * JIT\n   * 런타임 환경에 필요한 부분만 컴파일\n   * 유연하다\n   * react(jsx, react render fn은 완전 동적이여서 최적화가 어려움.)\n\n\nAlgebraic Effect(OCaml)#\n\n * functional programing중 개념.\n * 부작용(effect)을 함수 내부에서 분리\n * React 개발시 useState 같은 경우 내부적으로 어떻게 처리하는지 신경쓰지 않아도 되고 어떤 데이터를 반환하는지 만 알고 코드\n   작성하면 된다.\n\nconst getTotal = () => {\n  const a = getPrice1(); // effect\n  const b = getPrice2(); // effect\n  return a + b;\n};\n// getTotal실행시 바로 결과 가져오게 처리.\n\nconst Total = () => {\n  const a = usePrice(1); // async\n  const b = usePrice(2); // async\n  return <div>{a + b}</div>;\n};\n// <Total />\n\n\n\n참고#\n\n * https://yeoulcoding.me/124\n * https://overreacted.io/algebraic-effects-for-the-rest-of-us/\n * https://github.com/halfnelson/svelte-it-will-scale\n * https://krausest.github.io/js-framework-benchmark/2022/table_chrome_103.0.506\n   0.53_osx.html\n * https://web.dev/i18n/ko/interactive/\n * https://maxkim-j.github.io/posts/suspense-argibraic-effect\n * https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/index.js:152-160","routePath":"/note/react/sources/01","lang":"","toc":[{"text":"React강점?","id":"react강점","depth":3,"charIndex":3},{"text":"AOT(A Head Of Time) vs JIT(Just In Time)","id":"aota-head-of-time-vs-jitjust-in-time","depth":3,"charIndex":197},{"text":"Algebraic Effect(OCaml)","id":"algebraic-effectocaml","depth":3,"charIndex":384},{"text":"참고","id":"참고","depth":3,"charIndex":841}],"frontmatter":{},"version":""},{"title":"Fiber","content":"#\n\n\n용어#\n\nFiber Architecture\n\nFiber Node, Fiber Tree, FiberRoot, rootFiber\n\nFiber Reconciler는 Fiber Node 기반으로 실현\n\n\nVdom에 대한 이해?#\n\n 1. Fiber 객체 자체가 Vdom이다.\n 2. vitrual DOM은 React.createElement()로 return된 객체. fiber는 vdom 을 realdom으로 실현하는\n    일부분.\n\n\nFiber 아키텍처의 의미#\n\nfiber는 node단위를 한개 workUnit으로 비동기 이고 중단 가능한 업데이트를 실현(concurrent 모드, timeSlice실현.)\n\n\n데이터 구조#\n\n// https://github.com/facebook/react/blob/16.8.6/packages/react-reconciler/src/ReactFiber.js\nfunction FiberNode(tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode) {\n  this.tag = tag; // fiber 대응하는 컴포넌트 유형 Function/Class/Host\n  this.key = key;\n  this.elementType = null; // type이랑 동일 하지만 일부 제외(예: React.memo사용시 제외)\n  this.type = null; // FC=>함수자체, CC=>클래스, HostComponent=>tagName\n  this.stateNode = null;\n\n  // 다른 fiber 연결용\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n\n  this.index = 0; // fiber관련 dom insert할때 인덱스.\n  this.ref = null;\n\n  // update 관련된 상태 관련 정보 저장.\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // 부작용에 대한 내용 저장.\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  // 우선순위 관련 처리\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  // 해당 fiber 업데이트시 연관된 작업의 fiber(workInProgressFiber => currentFiber)\n  this.alternate = null;\n}\n\n\n\nFiber DoubleBuffer#\n\n예를들어 canvas에서 화면을 그릴때 매프레임마다 ctx.clearRect로 이전 화면을 지운다.\n\n새로 그리는 화면 컴퓨팅 시간이 많이 필요할 경우 흰색 화면만 보여주는 경우(Flickering)가 있다.\n\n해당문제를 해결하기 위해서 메모리(cpu, gpu)에서 다음화면을 그릴때 까지 이전화면을 보여주고 화면이 완성된 후에 ctx.clearRect로\n이전화면을 지우고 새화면을 교체해준다.\n\n이와같이 메모리에서 구성하고 바로 교체 해주는 방식을 DoubleBuffer라고 한다.\n\ncurrent fiber ⇒ workInProgress fiber(alternate)\n\n\nRoot#\n\nfiberRoot(변하지 않음.) > rootFiber > App > div\n\n\n\n\nJSX to Fiber#\n\nJSX ⇒ BABEL ⇒ React.createElement ⇒ ReactElement ⇒ ReactDom.render ⇒\nReactDOM.legacyCreateRootFromDOMContainer ⇒ createFiberRoot\n\n\nfiber 생성순서#\n\n\n\n*React 자식요소가 only textNode일 경우 별도 fiber생성 하지 않는다. (isDirectTextChild)\n\n<div><!-- 1 -->\n  <header/><!-- 2 -->\n    <h1><!-- 3 -->\n      page Title<!-- 4 -->\n      <span></span><!-- 5 -->\n    </h1>\n    <input /><!-- 6 -->\n  </header>\n  <div>contents</div><!-- 7 -->\n  <footer><!-- 8 -->\n    <div><!-- 9 -->\n      <p>copyright</p><!-- 10 -->\n      <p>email: aa@bb.com</p><!-- 11 -->\n    </div>\n    <p>footer</p><!-- 12 -->\n  </footer>\n</div>\n\n\n\n참고#\n\n * https://github.com/acdlite/react-fiber-architecture\n * https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reco\n   nciliation-algorithm-in-react\n * https://www.youtube.com/watch?v=ZCuYPiUIONs","routePath":"/note/react/sources/02","lang":"","toc":[{"text":"용어","id":"용어","depth":3,"charIndex":3},{"text":"Vdom에 대한 이해?","id":"vdom에-대한-이해","depth":3,"charIndex":113},{"text":"Fiber 아키텍처의 의미","id":"fiber-아키텍처의-의미","depth":3,"charIndex":245},{"text":"데이터 구조","id":"데이터-구조","depth":3,"charIndex":345},{"text":"Fiber **DoubleBuffer**","id":"fiber-doublebuffer","depth":3,"charIndex":-1},{"text":"Root","id":"root","depth":3,"charIndex":1777},{"text":"JSX to Fiber","id":"jsx-to-fiber","depth":3,"charIndex":1831},{"text":"fiber 생성순서","id":"fiber-생성순서","depth":3,"charIndex":1977},{"text":"참고","id":"참고","depth":3,"charIndex":2433}],"frontmatter":{},"version":""},{"title":"Reconciler","content":"#\n\n\n역할#\n\n * Function또는 class컴포넌트의 render 함수를 실행해서 jsx를 vdom으로 변경\n * 새로운 vdom과 기존 vdom을 비교한다.\n * diff통해서 변화한 부분을 체크한다.\n * renderer를 통해서 DOM을 화면에 뿌려준다.\n\n\nfiber관련 태그 설명.#\n\n * type\n   * FunctionComponent ⇒ 함수자체\n   * ClassComponent ⇒ 클래스\n   * HostComponent ⇒ tagName\n * tag\n   * FunctionComponent\n   * ClassComponent\n   * HostComponent\n * effectTag\n   * Placement\n   * Update\n   * PlacementAndUpdate\n   * Deletion\n   * Passive\n * effectList(firstEffect, nextEffect, lastEffect)\n * stateNode => DOM객체 저장.\n\n\n과정#\n\n * render\n   * beginWork\n   * completeWork\n * commit\n   * before Mutation\n   * mutation\n   * layout\n\n\nrender단계#\n\n\nbeginWork#\n\n * (mount)fiber.tag에 따라 서로 다른 Fiber노드 생성.\n * (update) 만약 current가 최적화 될수 있다면 current를 그대로 사용(Diff)\n * fiber에 EffectTag생성\n\n\ncompleteWork#\n\n * (mount)fiber.stateNode에 관련된 DOM노드 생성\n * (mount)children DOM노드를 생성된 fiber.stateNode DOM노드에 insert\n * (mount) props 처리\n * (update) fiber.updateQueue처리\n * (update) props diff 처리후 fiber.pendingProps에 저장.\n * effectTag 생성된 fiber에 대해서 effectList에 추가.\n\n\ncommit#\n\n\ncommit start#\n\neffectList중 Passive 태그가 존재할 경우 flushPassiveEffects(Immediate) 실행.\n\n\nbefore mutation (commitBeforeMutationEffects)#\n\n * DOM노드 랜더/삭제후 focus, blur 관련 로직처리.\n * getSnapshotBeforeUpdate(ClassComponent)\n * flashPassiveEffects (Normal)\n\n\nmutation (commitMutationEffects)#\n\n * effectTag에 따라 처리\n   * Placement\n   * Update\n     * FunctionComponent\n       * effectList에서 모든 useLayoutEffect의 destory 함수 실행.\n     * HostComponent\n       * fiber.updateQueue중 대응하는 내용 화면에 랜딩.\n       * fiber.pendingProps내용 화면에 랜딩\n   * Deletion\n\n\nlayout (commitLayoutEffects)#\n\n * 라이프사이클 및 hook 실행\n   * FunctionComponent\n     * useLayoutEffect 콜백 함수 실행.(sync)\n     * useEffect destor 함수와 콜백함수 초기화(async)\n   * classComponent\n     * componentDidMount, componentDidUpdate\n     * this.setState의 콜백함수 실행.\n   * HostRoot\n     * render fn 콜백함수 실행.\n * DOM Instance에 따라 ref업데이트\n * current Fiber 트리 변환\n\n\nlayout After#\n\n * fushPassiveEffects 실행(useEffect destor 및 useEffect callback)\n * flushSyncCallbackQueue 실행(예: useLayoutEffect 내부에 사용한 setState)\n\n\nhostConfig 외부 API(react-dom 빌드시 해당 부분 함께 빌드)#\n\n\n\nconst hostConfig = {\n  now: Date.now,\n  getRootHostContext: () => {},\n  clearContainer: () => {},\n  prepareForCommit: () => {},\n  resetAfterCommit: () => {},\n  getChildHostContext: () => {},\n  shouldSetTextContent: () => {},\n  createInstance: () => {},\n  createTextInstance: () => {},\n  appendInitialChild: () => {},\n  appendChild: () => {},\n  finalizeInitialChildren: () => {},\n  supportsMutation: true,\n  appendChildToContainer: () => {},\n  prepareUpdate = () => {},\n  commitUpdate = () => {},\n  commitTextUpdate = () => {},\n  removeChild = () => {},\n}\nconst ReactReconcilerInst = ReactReconciler(hostConfig);\n\nexport const render = (reactElement, domElement, callback) => {\n\n  if (!domElement._rootContainer) {\n    console.log(ReactReconcilerInst);\n    domElement._rootContainer = ReactReconcilerInst.createContainer(domElement);\n  }\n  // 컨테이너 업데이트\n  return ReactReconcilerInst.updateContainer(reactElement, domElement._rootContainer, null, callback);\n}\n\nexport default {\n  render\n}\n// \"react-reconciler\": \"0.26.2\",\n// \"react\": \"17.0.2\",\n\n\n\neffectList => subtreeFlags#\n\n * effectList인 경우\n\n\n\n * subtreeFlags\n\n\n\n * B의 effect는 Passive이고 bubble을 통해서 A로 이동, A.subtreeFlags에 Passive포함.\n * E의 effect는 Placement이고 bubble통해서 D로 이동, D.subtreeFlags에 Placement포함.\n * D.subtreeFlags에 Placement가 bubble통해서 C로 이동\n * C의 effect는 Update이고, C.subtreeFlags의 Placement가 bubble통해서 A로\n * A.subtreeFlags는 Passive、Placement、Update를 포함.\n * commit단계에서 모든 tree를 순회하면서 처리.\n\nhttps://gist.github.com/jl917/059c3c47a521914cb8ed8fa2b5ff8569\n\n\n참고#\n\n * https://velog.io/@dev-mish-mash/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%A1%B\n   0%ED%99%94Reconciliation-%EA%B3%BC%EC%A0%95-%EC%A0%95%EB%A6%AC\n * https://beta-reactjs-org-git-effects-fbopensource.vercel.app/learn/render-and\n   -commit\n * https://agent-hunt.medium.com/hello-world-custom-react-renderer-9a95b7cd04bc","routePath":"/note/react/sources/03","lang":"","toc":[{"text":"역할","id":"역할","depth":3,"charIndex":3},{"text":"fiber관련 태그 설명.","id":"fiber관련-태그-설명","depth":3,"charIndex":151},{"text":"과정","id":"과정","depth":3,"charIndex":500},{"text":"render단계","id":"render단계","depth":2,"charIndex":607},{"text":"beginWork","id":"beginwork","depth":3,"charIndex":619},{"text":"completeWork","id":"completework","depth":3,"charIndex":754},{"text":"commit","id":"commit","depth":2,"charIndex":1018},{"text":"commit start","id":"commit-start","depth":3,"charIndex":1028},{"text":"before mutation (commitBeforeMutationEffects)","id":"before-mutation-commitbeforemutationeffects","depth":3,"charIndex":1111},{"text":"mutation (commitMutationEffects)","id":"mutation-commitmutationeffects","depth":3,"charIndex":1273},{"text":"layout (commitLayoutEffects)","id":"layout-commitlayouteffects","depth":3,"charIndex":1555},{"text":"layout After","id":"layout-after","depth":3,"charIndex":1901},{"text":"hostConfig 외부 API(react-dom 빌드시 해당 부분 함께 빌드)","id":"hostconfig-외부-apireact-dom-빌드시-해당-부분-함께-빌드","depth":2,"charIndex":2048},{"text":"effectList => subtreeFlags","id":"effectlist--subtreeflags","depth":3,"charIndex":3141},{"text":"참고","id":"참고","depth":3,"charIndex":3610}],"frontmatter":{},"version":""},{"title":"Update","content":"#\n\n\nUpdate 활성화#\n\n * ReactDOM.render\n * this.setState\n * this.forceUpdate\n * useState\n * useReducer\n\n\nUpdate 프로세스#\n\nthis.update.enqueueSetState 통해서 Update를 생성하고 실행한다.\n\nUpdate 활성화\n    |\n    v\nshared.pending 생성\n    |\n    v\n....\n    |\n    v\nupdateQueue 처리(completeWork)\n    |\n    v\n...\n\n\n\nUpdate객체#\n\n// ClassComponent, HostRoot\nconst update = {\n  eventTime: \"\",\n  lane: \"\",\n  suspenseConfig: \"\",\n  tag: UpdateState, // CaptureUpdate, ForceUpdate, ReplaceState, UpdateState\n  payload: null, // ClassComponent this.setState args[0], HostRoot ReactDOM.render args[0]\n  callback: null, // ClassComponent this.setState args[1], HostRoot ReactDOM.render args[2]\n  next: null,\n};\n\n// FunctionComponent\nconst update = {\n  eventTime: \"\",\n  lane: \"\",\n  suspenseConfig: \"\",\n  action: \"\", // ????\n  eagerReducer: null, // useState는 basicStateReducer사용.\n  eagerState: null, // 리듀서를 통해 action의 결과값을 얻는다. basicStateReducer(baseState, action)\n  next: null,\n};\n\nfunction basicStateReducer(state, action) {\n  return typeof action === \"function\" ? action(state) : action;\n}\n\n\n\nUpdate Queue#\n\n * baseState: 메모리에 임시 저장되는 값.\n * memoizedState: 화면에 노출되는 값\n * shared.pending: 업데이트 활성화시 임시 저장하고 우선순위에 적합한 Update만 firstBaseUpdate뒤에 추가.\n\n// ClassComponent\nconst Fiber = {\n  updateQueue: {\n    baseState: '',\n    firstBaseUpdate: Update,\n    lastBaseUpdate: Update,\n    shared: {\n      pending: Updates\n    }\n    effects: [] // update.callback 이 존재하는 경우만 배열에 추가\n  }\n  memoizedState: stateValue\n}\n\n// FunctionComponent\nconst Fiber = {\n  memoizedState: { // Hook\n    memoizedState: stateValue,\n    baseState: '',\n    baseQueue: Update,\n    queue: Updates,\n    next, // Hook list\n  }\n}\n\n\n\nupdate 종류별#\n\n\n단일 Task#\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  const onClick = () => setCount(count + 1);\n  return <div onClick={onClick}>{count}</div>;\n};\n\n\n\nbatchUpdate#\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  const onClick1 = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n  const onClick2 = () => {\n    setCount((baseState) => baseState + 1);\n    setCount((baseState) => baseState + 1);\n    setCount(count + 1);\n    setCount((baseState) => baseState + 1);\n  };\n  const onClick3 = () => {\n    setTimeout(() => {\n      // concurrent mode일 경우 배치됨, legacy mode일 경우 3번 랜딩됨.\n      setCount(count + 1);\n      setCount(count + 1);\n      setCount(count + 1);\n    }, 0);\n  };\n  return (\n    <>\n      <h1>{count}</h1>\n      <div onClick={onClick1}>click1</div>\n      <div onClick={onClick2}>click2</div>\n      <div onClick={onClick3}>click3</div>\n    </>\n  );\n};\n\n\n\nhigh priority task#\n\nconst arr = [];\narr.length = 6000;\narr.fill(0);\n\nconst App = () => {\n  const btnRef = useRef(null);\n  const [count, setCount] = useState(0);\n  const onClick = () => {\n    setCount((count) => count + 1);\n  };\n\n  useEffect(() => {\n    // 레거시 모드에서는 10, 11로 화면에 노출\n    // 동시성 모드에서는 1, 11로 화면에 노출(1차 우선순위 높은거 실행, 2차 순차적으로 실행.)\n    // [10_2, x+1_1]\n    setTimeout(() => {\n      setCount(count + 10);\n    }, 2000);\n    setTimeout(() => {\n      btnRef.current.click();\n    }, 2000);\n  }, []);\n  return (\n    <>\n      <h1>{count}</h1>\n      <div\n        onClick={onClick}\n        ref={btnRef}\n      >\n        click1\n      </div>\n      {arr.map(() => (\n        <div>{count}</div>\n      ))}\n    </>\n  );\n};\n\n\n\n복합적인 경우#\n\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n\n\n\n참고#\n\n * https://wonism.github.io/react-updater/\n * https://github.com/facebook/react/blob/main/packages/react-reconciler/src/Rea\n   ctFiberClassUpdateQueue.old.js","routePath":"/note/react/sources/04","lang":"","toc":[{"text":"Update 활성화","id":"update-활성화","depth":3,"charIndex":3},{"text":"Update 프로세스","id":"update-프로세스","depth":3,"charIndex":100},{"text":"Update객체","id":"update객체","depth":3,"charIndex":284},{"text":"Update Queue","id":"update-queue","depth":3,"charIndex":1053},{"text":"update 종류별","id":"update-종류별","depth":2,"charIndex":1652},{"text":"단일 Task","id":"단일-task","depth":3,"charIndex":1666},{"text":"batchUpdate","id":"batchupdate","depth":3,"charIndex":1835},{"text":"high priority task","id":"high-priority-task","depth":3,"charIndex":2600},{"text":"복합적인 경우","id":"복합적인-경우","depth":3,"charIndex":3320},{"text":"참고","id":"참고","depth":3,"charIndex":4045}],"frontmatter":{},"version":""},{"title":"기초문법","content":"#\n\n\n요약#\n\nhello world#\n\nfn main() {\n    let s = \"hello world\";\n    println!(\"{}\", s); // println! macro   标准输出macro 可以完成编译器格式检查， 更加安全\n}\n\n\n타입지정#\n\nfn Foo(input1: i32, input2: u32) -> i32 {\n  ...\n}\n\n\nuse#\n\nuse std::prelude::*; // std rust에서 제공하는 standard 유틸\n\n\nFormat#\n\nfn main() {\n    println!(\"{}\", 1); // default\n    println!(\"{:o}\", 9); // 八进制\n    println!(\"{:x}\", 255); // 十六进制 小写\n    println!(\"{:X}\", 255); // 十六进制 大写\n    println!(\"{:p}\", &0); // pointer\n    println!(\"{:b}\", 15); // 二进制\n    println!(\"{:e}\", 10000f32); // 科学计数 小写\n    println!(\"{:E}\", 10000f32); // 科学计数 大写\n    println!(\"{:?}\", \"test\"); // debug\n    println!(\"{:#?}\", (\"test1\", \"test2\")); // 带换行和缩进的debug\n    println!(\"{a} {b} {b}\", a = \"x\", b = \"y\"); // 命名参数\n}\n\n\n변수선언#\n\nlet num: i32 = 100;\nlet num = 100i32;\n\nlet x = 5;\nx = 10; // error\n\nlet mut x = 5;\nx = 10;\n\nlet x:i32;\nx = 1;\n\nlet (mut a, mut b) = (1,2);\nlet Point {x: ref a, y: ref b} = p;\n\nstatic GLOBAL:i32 = 0;\n\n\n기본 데이터 유형#\n\nlet empty: () = (); // unit type\nlet boolean: bool = true;\nlet t1: char = 'x';\n// u8 ~ u128\nlet i1: i8 = -128; // -128~127\nlet i2: u8 = 255; // 0~255\n// f32, f64\nlet f1: f32 = 123.0;\nlet f2 = 123.0f32;\n\n\n복합 데이 유형#\n\n// tuple\nlet a = (1i32, false);\nlet b = (a, (1i32, 2i32));\nlet a = (0,);\nlet b: i32 = (0); // 표현식, tuple 아님\n\n// struct\nstruct Point {\n  x: i32,\n  y: i32,\n}\nlet p = Point {x: 0, y: 0};\nprintln!(\"point is at {} {}\",p.x, p.y);\n\n// struct: 생략 가능\nlet x = 10;\nlet y = 20;\nlet p = Point {x, y};\n\n// struct: px, py alias로 바인딩 가능\nlet p = Point { x: 0, y: 1 };\nlet Point { x: px, y: py } = p;\n\n// struct: destruct도 가능\nlet Point {x, y} = p;\n\n// struct: 语法糖, default 지정 가능\nstruct Point3d {\n  x: i32,\n  y: i32,\n  z: i32,\n}\nfn default() -> Point3d {\n  Point3d { x: 0, y: 0, z: 0 }\n}\nlet origin = Point3d { x: 4, ..default() };\n\n// tuple struct\nstruct T(i32);\nlet v1 = T(1);\nlet v2 = T{0: 1};\n\n// enum\nenum Number {\n    Int(i32),\n    Float(f32),\n}\n// Number::Int로 enum구성원에 접근\nfn read_num(num: &Number) {\n    match num {\n        &Number::Int(value) => println!(\"integer {}\", value),\n        &Number::Float(value) => println!(\"float {}\", value),\n    }\n}\nfn main() {\n    let n: Number = Number::Int(10);\n    read_num(&n);\n}\n// index\nenum Animal {\n    dog = 1, // 선언하지 않으면 0\n    cat = 200,\n    tiger,\n}\n\nlet x = Animal::tiger as isize;\nprintln!(\"{}\", x) // 201\n\n\nExpression#\n\nlet x = 100;\nlet y = 10;\nlet t = true;\nlet f = false;\n\nprintln!(\"{}\", x + y);\nprintln!(\"{}\", x - y);\nprintln!(\"{}\", x * y);\nprintln!(\"{}\", x / y);\nprintln!(\"{}\", x % y);\nprintln!(\"{}\", x == y);\nprintln!(\"{}\", x != y);\nprintln!(\"{}\", x < y);\nprintln!(\"{}\", x > y);\nprintln!(\"{}\", x >= y);\nprintln!(\"{}\", x <= y);\nprintln!(\"{}\", t && f);\nprintln!(\"{}\", t || f);\nprintln!(\"{}\", !t);\n\nlet mut y1 = 40;\nlet mut y2 = 40;\nlet mut y3 = 40;\nlet mut y4 = 40;\nlet mut y5 = 40;\ny1 += 10;\ny2 -= 10;\ny3 *= 10;\ny4 /= 10;\ny5 %= 10;\nprintln!(\"{}\", y1);\nprintln!(\"{}\", y2);\nprintln!(\"{}\", y3);\nprintln!(\"{}\", y4);\nprintln!(\"{}\", y5);\n\n\nlet x: () = {\n    println!(\"hello x\");\n};\nx;\nlet y: i32 = {\n    println!(\"hello y\");\n    30\n};\nprintln!(\"{}\", y);\n\n\nif else#\n\nfn func(n: i32) -> bool {\n    if n < 0 {\n        println!(\"{} is negative\", n);\n    } else if n > 0 {\n        println!(\"{} is positive\", n);\n    } else {\n        println!(\"{} is zero\", n);\n    }\n    return n > 0;\n}\nlet x = func(-3);\nprintln!(\"{}\", x)\n\n\nloop#\n\nlet mut count = 0u32;\n\nloop {\n    count += 1;\n    if count == 3 {\n        println!(\"three\");\n        continue;\n    }\n\n    println!(\"{}\", count);\n    if count >= 5 {\n        println!(\"OK\");\n        break;\n    }\n}\n\n\nwhile#\n\nlet mut count = 0u32;\n\nwhile count < 101 {\n    if count % 15 == 0 {\n        println!(\"fizzbuzz\");\n    } else if count % 3 == 0 {\n        println!(\"fizz\");\n    } else if count % 5 == 0 {\n        println!(\"buzz\");\n    } else {\n        println!(\"{}\", count);\n    }\n    count += 1;\n}\n\n\nfor#\n\nlet array = &[1, 2, 3, 4, 5];\nfor i in array {\n    println!(\"is {}\", i);\n}\n\n\n함수#\n\n// 일반\nfn add(t: (i32, i32)) -> i32 {\n    t.0 + t.1\n}\nfn add2((a, b): (i32, i32)) -> i32 {\n    a + b\n}\nprintln!(\"{}\", add((1, 2)));\nprintln!(\"{}\", add2((3, 4)))\n\n// return이 없는 경우 unit ()\nfn empty(a: i32) -> () {\n    a+a;\n}\n\n// 함수에 값을 할당해서 사용(타입이 동일할 때에만 할당 가능)\n// let mut f = add as fn((i32, i32)) -> i32;\nlet mut f: fn((i32, i32)) -> i32 = add;\nf = add2;\n\nprintln!(\"{}\", f((1, 3)))\n\n// main함수 args\nfn main() {\n    for arg in std::env::args() {\n        println!(\"{}\", arg);\n    }\n    std::process::exit(0);\n}\n// ./004 test1 opt2\n// ./004\n// test1\n// opt2\n\n// const 함수 컴파일 단계에서 실행하는 함수라서 제한이 많음,\n// 제한이 있을수 있으니 조심해서 사용\nconst fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nlet total: i32 = add(1, 2);\nlet total2: i32 = add(3, 4);\nprintln!(\"{}\", total);\nprintln!(\"{}\", total2);\n\n// 재귀 함수\n// 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n// rust1.19 버전까지 trail call 최적화가 되지 않음.\nfn fib(index: u32) -> u64 {\n    if index == 1 || index == 2 { 1 } else { fib(index - 1) + fib(index - 2) }\n}\n\nlet f8 = fib(8);\nprintln!(\"{}\", f8)\n\n\ntrait#\n\n// method\ntrait Shape {\n    fn area(&self) -> f64;\n}\nstruct Circle {\n    radius: f64,\n}\n\nimpl Shape for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * self.radius * self.radius\n    }\n}\n\nlet c = Circle { radius: 2f64 };\nprintln!(\"{}\", c.area());\n\n// static method\nstruct T(i32);\nimpl T {\n    fn func(this: &Self) {\n        println!(\"{}\", this.0)\n    }\n}\n\nlet x = T(42);\nT::func(&x);\n\n// extend method\ntrait Double {\n    fn double(&self) -> Self;\n}\nimpl Double for i32 {\n    fn double(&self) -> i32 {\n        *self * 2\n    }\n}\n\nlet x: i32 = (10).double();\nprintln!(\"{}\", x)\n\n// fully qualified syntax(universal function call syntax)\ntrait Cook {\n    fn start(&self);\n}\ntrait Wash {\n    fn start(&self);\n}\nstruct Chef;\nimpl Cook for Chef {\n    fn start(&self) {\n        println!(\"Cook::start\");\n    }\n}\nimpl Wash for Chef {\n    fn start(&self) {\n        println!(\"Wash::start\");\n    }\n}\n\nlet me = Chef;\n<Cook>::start(&me);\n<Chef as Wash>::start(&me);\n\n// alias\npub trait Service {\n    type Request;\n    type Response;\n    type Error;\n    type Future: Future<Item=Self::Response, Error=Self::Error>;\n    fn call(&self, req: Self::Request) -> Self::Future;\n}\n\ntrait HttpService = Service<Request = http::Request, Response = http::Response, Error = http::Error>;\n\n\narray#\n\nlet v = [1,2,3];\n// 크기 반드시 지정, 가변 크기는 std Vec/LinkedList 사용\nlet xs: [i32; 5] = [1, 2, 3, 4, 5];\nprintln!(\"{:?}\", xs)\n\n// 기본값 으로 fill처리\nlet xs: [i32; 5] = [0; 5];\nprintln!(\"{:?}\", xs)\n\n// 2depth\nlet v: [[i32;2];3 ] = [[0,0],[0,0],[0,0]]\n\n// range\nlet r = 1..10;\nfor i in r {\n    println!(\"{}\", i);\n}\n\n\nstring#\n\nlet greeting: &str = \"Hello\";\nlet substr: &str = &greeting[2..];\nprintln!(\"{}\", greeting);\nprintln!(\"{}\", substr);\n\nlet mut s = String::from(\"Hello\");\ns.push(' ');\ns.push_str(\"World\");\nprintln!(\"{}\", s)\n\n\nmatch#\n\nenum Direction {\n    East,\n    West,\n    South,\n    North,\n}\n\nfn print(x: Direction) {\n    match x {\n        Direction::East => {\n            println!(\"East\");\n        }\n        Direction::West => {\n            println!(\"West\");\n        }\n        Direction::South => {\n            println!(\"South\");\n        }\n        Direction::North => {\n            println!(\"North\");\n        }\n    }\n}\n\nfn print2(y: Direction) {\n    match y {\n        Direction::East => {\n            println!(\"East\");\n        }\n        _ => {\n            println!(\"Other\");\n        }\n    }\n}\n\nfn print3(x: Direction) {\n    match x {\n        Direction::East => 10\n        Direction::West => 20\n        Direction::South => 30\n        Direction::North => 40\n    }\n}\n\nlet x = Direction::East;\nlet y = Direction::West;\nprint(x);\nprint2(y);\nprint3(x);\n\n\n_#\n\nstruct P(i32, i32, i32);\nfn calc(P(x, _, y): P) -> i32 {\n    x * x + y * y\n}\nlet t = P(1, 2, 3);\nprintln!(\"{}\", calc(t));\n","routePath":"/note/rust/001","lang":"","toc":[{"text":"요약","id":"요약","depth":2,"charIndex":3},{"text":"hello world","id":"hello-world","depth":4,"charIndex":8},{"text":"타입지정","id":"타입지정","depth":4,"charIndex":136},{"text":"use","id":"use","depth":4,"charIndex":195},{"text":"Format","id":"format","depth":4,"charIndex":255},{"text":"변수선언","id":"변수선언","depth":4,"charIndex":731},{"text":"기본 데이터 유형","id":"기본-데이터-유형","depth":4,"charIndex":939},{"text":"복합 데이 유형","id":"복합-데이-유형","depth":4,"charIndex":1155},{"text":"Expression","id":"expression","depth":4,"charIndex":2310},{"text":"if else","id":"if-else","depth":4,"charIndex":3057},{"text":"loop","id":"loop","depth":4,"charIndex":3320},{"text":"while","id":"while","depth":4,"charIndex":3541},{"text":"for","id":"for","depth":4,"charIndex":3831},{"text":"함수","id":"함수","depth":4,"charIndex":3914},{"text":"trait","id":"trait","depth":4,"charIndex":4920},{"text":"array","id":"array","depth":4,"charIndex":6208},{"text":"string","id":"string","depth":4,"charIndex":6517},{"text":"match","id":"match","depth":4,"charIndex":6731},{"text":"_","id":"_","depth":4,"charIndex":7558}],"frontmatter":{},"version":""},{"title":"개념","content":"#\n\n&str String차이점#\n\nString유형은 메모리공간 관리가 가능하다.","routePath":"/note/rust/002","lang":"","toc":[{"text":"&str String차이점","id":"str-string차이점","depth":4,"charIndex":2}],"frontmatter":{},"version":""},{"title":"유틸/팁","content":"#\n\n\nplugin#\n\n * vscode plugin(rust-analyzer)\n\n\n주의사항#\n\n * 시도해 보는 사고방식을 피하라\n * 완전히 새로운 언어여서 어려움에 부딛힐 준비를 해라\n * 책을 보고 깊게 공부하라\n * Linked List, Graph로 연습하지 말아라\n * 컴파일 오류를 잘 읽어보라\n * 다른언어의 bp를 rust에 적용하지 말라\n\n// str[n]으로 n번째 텍스트 가져오기\ns.chars().nth(n);\n","routePath":"/note/rust/003","lang":"","toc":[{"text":"plugin","id":"plugin","depth":3,"charIndex":3},{"text":"주의사항","id":"주의사항","depth":3,"charIndex":46}],"frontmatter":{},"version":""},{"title":"SEO","content":"#\n\n\nHTML부분#\n\n * Meta Title 태그 최적화\n * Meta description최적화\n * Semantic 마크업\n   * Heading 태그 구조 최적화\n   * image alt 속성\n   * anchor 텍스트를 작성\n     * 외부링크일 경우 rel=\"nofollow\" 추가\n * 절대 경로 사용\n * 불필요한 내용 제거.\n\n\nURL#\n\n * 최대한 짧고 간단하게\n * 키워드 포함\n * 소문자 사용\n * 특수문자 및 공백 사용 금지 또는 인코딩 처리\n * https사용\n\n\n기타#\n\n * sitemap.xml 사이트맵 작성\n * robots.txt에 의한 크롤링제어\n * 검색엔진 수동 등록\n * 사이트 랜더링 최적화","routePath":"/note/seo/","lang":"","toc":[{"text":"HTML부분","id":"html부분","depth":2,"charIndex":3},{"text":"URL","id":"url","depth":2,"charIndex":196},{"text":"기타","id":"기타","depth":2,"charIndex":279}],"frontmatter":{},"version":""},{"title":"基础","content":"#\n\n// Text.svelte\n<p>\n  this is Text Component\n</p>\n\n// App.svelte\n<script>\n  \n  const name = 'google'\n  const src = 'https://www.google.com/logos/doodles/2020/december-holidays-days-2-30-6753651837108830.3-law.gif'\n  const htmlText = '<strong>html</strong> parsing sample'\n</script>\n<div>\n  <h1 class=\"heading\">\n    hello {name}\n  </h1>\n  <div>\n    <img src={src} alt=\"{name} logo\" />\n  </div>\n  <p>\n    {@html htmlText}\n  </p>\n  <Text />\n</div>\n\n<style>\n  .heading{color:#ff0000}\n</style>\n\n\n// index.js\n\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\t// we'll learn about props later\n\t\tanswer: 42\n\t}\n});\n\n\n交互#\n\n<script>\n\tlet count = 0;\n  $: doubled = count * 2;\n\tconst handleClick = () => count += 1;\n</script>\n<button on:click={handleClick}>\n\tClick\n</button>\n<!-- 推荐， 重复使用该组建时很友好 -->\n<p>\n\t{count} {doubled}\n</p>\n<!-- 不使用也可以 -->\n<p>\n\t{count} {count * 2}\n</p>\n\n\n<script>\n\tlet count = 0;\n\tlet count2 = 0;\n  // 监听count更改时执行, 有声明就监听\n\t$: console.log(`the count is ${count}`);\n  // 可以大括号打包\n  $: {\n    console.log(`the count is ${count}`);\n  }\n  // 也可以添加条件\n  $: if(count > 10){\n    console.log('count max')\n    count = 9\n  }\n\n\tfunction handleClick() {\n\t\tcount += 1;\n\t}\n\tfunction handleClick2() {\n\t\tcount2 += 1;\n\t}\n</script>\n\n<button on:click={handleClick}>\n\tClicked {count} {count === 1 ? 'time' : 'times'}\n</button>\n\n<button on:click={handleClick2}>\n\tClicked {count2} {count2 === 1 ? 'time' : 'times'}\n</button>\n\n\n<script>\n\tlet numbers = [1,2,3,4];\n  $: length = numbers.length;\n  const addNumber = () => {\n    numbers = [...numbers, numbers.length + 1]\n    // 直接push 他不会导致组建更新\n    // nums.push(numbers.length + 1)\n  }\n</script>\n<button @on:click={addNumber}>\n  click {length}\n</button>\n\n\nProps#\n\n<!-- App.svelte -->\n<script>\n\t\n  const p1 = {\n    name: 'dao',\n    age: 20,\n  }\n</script>\n<People name=\"dao\" age={20} />\n<People {...p1} />\n\n<!-- People.svelte -->\n<script>\n  export const name = 'lang'; // default value\n  export const age;\n</script>\n<p>\n  name: {name}<br/>\n  age: {age}\n</p>\n\n\nLogic#\n\n<script>\nlet isLogined = false;\nconst toggle = () => {\n\tisLogined = !isLogined;\n}\nconst list = [\n  {\n    id: 'un01', name: 'dao', age: 12,\n  },\n  {\n    id: 'un02', name: 'lang', age: 22,\n  },\n]\n</script>\n<button on:click={toggle}>\n\t{#if !isLogined}login{/if}\n\t{#if isLogined}logout{/if}\n</button>\n<button on:click={toggle}>\n\t{#if !isLogined}login\n\t{:else}logout{/if}\n</button>\n<ul>\n  {#each list as item, i (item.id)} <!-- 相当于react key -->\n  \t<li>{i} - {item.name}, {item.age}</li>\n  {/each}\n</ul>\n\n\nPromise#\n\n<script>\n\tconst getUser = async () => {\n\t\tconst response = await fetch('https://randomuser.me/api/');\n\t\tif(response.status === 200){\n\t\t\treturn response.json()\n\t\t}\n\t}\n</script>\n\n{#await getUser()}\n\t<div>loading...</div>\n\t{:then data}\n\t<div>\n\t\t{data.results[0].gender} - {data.results[0].name.first}, {data.results[0].name.last}\n\t</div>\n\t{:catch error}\n\t<div>\n\t\t{error.message}\n\t</div>\n{/await}\n\n\nEvent#\n\n<script>\n\tlet count = 0;\n\tconst setCount = () => {\n\t\tcount += 1;\n\t}\n</script>\n<h1>\n\t{count}\n</h1>\n<button on:click|once={setCount}>\n\tclick\n</button>\n<!-- 在某些框架中，出于性能原因，您可能会看到一些避免内联事件处理程序的建议，尤其是在循环内部。 该建议不适用于Svelte，无论您选择哪种形式，编译器都将始终做正确的事情。 -->\n<button on:click={() => count += 1}>\n\tclick\n</button>\n\n\nEvent Modifiers#\n\n                  \npreventDefault    运行处理程序之前调用event.preventDefault（）。 例如，对客户端表单处理有用。\nstopPropagation   调用event.stopPropagation（），以防止事件到达下一个元素\npassive           改进了触摸/滚轮事件的滚动性能（Svelte会在安全的地方自动添加它）\nnonpassive        显式设置为passive：false\ncapture           在捕获阶段而不是冒泡阶段（）触发处理程序\nonce              首次运行处理程序后将其删除\nself              仅当event.target是元素本身时才触发处理程序\n\nComponent Event#\n\n与DOM事件不同，组件事件不会冒泡。 如果要在某个深度嵌套的组件上侦听事件，则中间组件必须转发该事件。\n\n<!-- App.svelte -->\n<script>\n\t\n\tlet name = 'lang';\n\tlet age = 5;\n\tconst getName = (event) => {\n\t\tname = event.detail.name;\n\t\tage = event.detail.age;\n\t}\n</script>\n<People on:getName={getName} />\n<PeopleOuter on:getName={getName} />\n<div>\n\t{name} {age}\n</div>\n\n<!-- People.svelte -->\n<script>\n\t\n\tconst dispatch = createEventDispatcher();\n\tconst setName = () => {\n\t\tdispatch('getName', {\n\t\t\tname: 'daolang',\n\t\t\tage: 12\n\t\t})\n\t}\n</script>\n<button on:click={setName}>\nclick\n</button>\n\n<!-- PeopleOuter.svelte -->\n<script>\n  \n</script>\n<People on:getName />\n\n\n\nForm binding#\n\n<script>\n\tlet formObj = {\n\t\tusername: '',\n\t\tage: 10,\n\t\tagree: false,\n\t\tgender: 'male',\n\t\tcountry: 'korea',\n\t\tmessage: '',\n\t}\n</script>\n\n<form>\n\t<h3>Input</h3>\n\t<label>username <input bind:value={formObj.username} /></label>\n\t<h3>Range</h3>\n\t<label>age <input bind:value={formObj.age} type=\"range\" min={0} max={99} />{formObj.age}</label>\n\t<h3>Radio</h3>\n\t<label>male <input type=\"radio\" bind:group={formObj.gender} value=\"male\" /></label>\n\t<label>famale <input type=\"radio\" bind:group={formObj.gender} value=\"female\" /></label>\n\t<h3>Radio</h3>\n\t<select bind:value={formObj.country}>\n\t\t<option value=\"china\">china</option>\n\t\t<option value=\"japan\">japan</option>\n\t\t<option value=\"korea\">korea</option>\n\t</select>\n\t<h3>Textarea</h3>\n\t<textarea bind:value={formObj.message} />\n</form>\n\n\nComponent binding#\n\n<!-- App.svelte -->\n<script>\n\t\n  let pin = ''\n  $: view = pin || 'enter pin'\n\t\n  const handleSubmit = () => {\n    alert(`submit ${pin}`)\n  }\n</script>\n<h1>{view}\n</h1>\n<Pad bind:value={pin} on:submit={handleSubmit} />\n<!-- Pad.svelte -->\n<script>\n\t\n\texport let value = ''\n\tconst dispatch = createEventDispatcher();\n\tconst clickNum = (e) => value += e.target.innerText;\n\tconst clickClear = () => value = '';\n\tconst clickSubmit = () => dispatch('submit')\n</script>\n\n<div>\n\t<button on:click={clickNum}>1</button>\n\t<button on:click={clickNum}>2</button>\n\t<button on:click={clickNum}>3</button>\n\t<button on:click={clickNum}>4</button>\n\t<button on:click={clickNum}>5</button>\n\t<button on:click={clickNum}>6</button>\n\t<button on:click={clickNum}>7</button>\n\t<button on:click={clickNum}>8</button>\n\t<button on:click={clickNum}>9</button>\n\t<button on:click={clickClear}>clear</button>\n\t<button on:click={clickNum}>0</button>\n\t<button on:click={clickSubmit}>submit</button>\n</div>\n\n\nLifecycle#\n\n 1. beforeUpdate\n 2. render\n 3. onMount\n 4. afterUpdate\n 5. onDestroy\n 6. unMount(onMount return function)\n\n<!-- App.svelte -->\n<script>\n\t\n\tlet isShow = true\n\tconst toggle = () => isShow = !isShow;\n</script>\n<button on:click={toggle}>\n\tclick\n</button>\n{#if isShow}\n<Sub />\n{/if}\n\n<!-- Sub.svelte -->\n<script>\n\t\n\tlet status = 'sub page'\n\tonMount(() => {\n\t\tconsole.log('mount')\n\t\treturn () => {\n\t\t\tconsole.log('unmount')\n\t\t}\n\t})\n\t// 销毁时运行 unmount 之前\n\tonDestroy(() => {\t\n\t\tconsole.log('destroy')\n\t})\n\t// 数据更新前\n\tbeforeUpdate(() => {\n\t\tconsole.log('before update')\n\t})\n\t// 数据更新后\n\tafterUpdate(() => {\n\t\tconsole.log('after update')\n\t})\n\t\n\tconst setContents = () => {\n\t\tstatus = `sub page ${+new Date()}`\n\t}\n</script>\n\n<p>\n\t<span style=\"display: none\">{console.log('render')}</span>\n\t{status}\n</p>\n<button on:click={setContents}>\n\tupdate page contents\n</button>\n\n\n在Svelte中更新组件状态时，它不会立即更新DOM。 而是等到下一个微任务，看是否还有其他需要应用的更改，包括其他组件。\n这样做避免了不必要的工作，并使浏览器可以更有效地对事物进行批处理。","routePath":"/note/svelte/01","lang":"","toc":[{"text":"交互","id":"交互","depth":4,"charIndex":619},{"text":"Props","id":"props","depth":4,"charIndex":1696},{"text":"Logic","id":"logic","depth":4,"charIndex":1998},{"text":"Promise","id":"promise","depth":4,"charIndex":2506},{"text":"Event","id":"event","depth":4,"charIndex":2911},{"text":"Event Modifiers","id":"event-modifiers","depth":4,"charIndex":3218},{"text":"Component Event","id":"component-event","depth":4,"charIndex":3588},{"text":"Form binding","id":"form-binding","depth":4,"charIndex":4213},{"text":"Component binding","id":"component-binding","depth":4,"charIndex":5011},{"text":"Lifecycle","id":"lifecycle","depth":4,"charIndex":6004}],"frontmatter":{},"version":""},{"title":"Stores","content":"#\n\n<!-- App.svelte -->\n<script>\n\n\nconst increment = () => {\n  count.update((v) => v + 1);\n};\nconst reset = () => {\n  count.set(0);\n};\n</script>\n\n<p>\n\t{$count} * 2 = {$count2}\n</p>\n\n<button on:click=\"{increment}\">\n\tincrement\n</button>\n<button on:click=\"{reset}\">\n\treset\n</button>\n\n\n// store.js\n\n\nexport const count = writable(0);\nexport const count2 = derived(count, (value) => value * 2);\n\n\nCustom#\n\n<!-- App.svelte -->\n<script>\n\n</script>\n\n<p>\n\t{$count}\n</p>\n\n<button on:click=\"{count.increment}\">\n\tincrement\n</button>\n<button on:click=\"{count.decrement}\">\n\tincrement\n</button>\n<button on:click=\"{count.reset}\">\n\treset\n</button>\n\n\n\n\nfunction createCount() {\n  const { subscribe, set, update } = writable(0);\n\n  return {\n    subscribe,\n    increment: () => {},\n    decrement: () => {},\n    reset: () => {},\n  };\n}\n\nexport const count = createCount();\n\n\nSlot#\n\n<!-- App.svelte -->\n<script>\n\n\n</script>\n\n<!-- basic -->\n<Box>slot</Box>\n<!-- default -->\n<Box />\n<!-- name -->\n<Box2>\n\t<span slot=\"heading\">title</span>\n</Box2>\n<Box2>\n\t<span slot=\"content\">div balabala</span>\n</Box2>\n\n<!-- Box.svelte -->\n<div>\n\t<slot>\n\t\t<p>default value</p>\n\t</slot>\n</div>\n\n<!-- Box2.svelte -->\n<div>\n\t<h1>\n\t\t<slot name=\"heading\" />\n\t</h1>\n\t<p>\n\t\t<slot name=\"content\" />\n\t</p>\n</div>\n","routePath":"/note/svelte/02","lang":"","toc":[{"text":"Custom","id":"custom","depth":4,"charIndex":390},{"text":"Slot","id":"slot","depth":4,"charIndex":852}],"frontmatter":{},"version":""},{"title":"测试","content":"#\n\n\n测试种类#\n\n * 单元测试(Unit Test)\n   \n   每个模块或者函数进行测试\n\n * 集成测试(Integration Testing)\n   \n   验证每个单元之间传递的正确性和实现性\n\n * 用户验收测试(User Acceptance Test)\n   \n   根据环境来进行功能以及性能的测试\n\n * 系统测试(System Testing)\n   \n   用户自己来测试是否达到需求\n\n * 黑盒测试(数据驱动测试)\n   \n   不需要知道软件的具体代码， 数据的输入和输出\n\n * 白盒测试(单元测试)\n   \n   程序员自己根据代码来写实现\n\n\n测试工具#\n\n\nClient/Server 自动化#\n\n * qtp\n * winrunner(IBM)\n * autoit\n\n\n功能测试#\n\n * jest(vitest)\n * Coverage\n * Unit Test\n * Integration Test (Module Integration Test)\n\n\n界面测试#\n\n * cypress\n * pupptter\n\n\n兼容性#\n\n * 跨浏览器(包括手机端) https://www.browserstack.com/\n * 软件环境(版本环境)\n * 硬件环境\n * 系统环境\n\n\n性能测试#\n\n * loadrunner\n * lighthouse https://developers.google.com/web/tools/lighthouse/\n * pagespeed https://developers.google.com/speed/pagespeed/insights/\n\nbrew install wrk\nwrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html\n\nnpm install -g loadtest\nloadtest http://localhost:8054/test -t 20 -c 100\n\n\n\n接口测试#\n\n * Jmeter\n * postman\n * SoapUI\n\n\n网络测试#\n\n * lxia\n * wireshark\n * tc\n * iperf\n * tcpping\n\n\nweb 安全测试#\n\n * appscan\n * Netsparker community Edition\n * Websecurify\n * Wapiti\n * N-Stalker Free Version\n * Scrawlr\n * Watcher\n * WebScrab\n * 授权测试\n\n\n抓包#\n\n * fiddler\n\n * burpsuite\n\n * reqable\n\n\n其他#\n\n\n提升产品质量#\n\n * 编写测试用例并且加强对应的一个评审\n * 加强对需求的理解\n * 加强对问题的跟进\n * 交叉测试\n\n\nMock 的好处#\n\n 1. 由于其他系统模块出错引起本模块的测试错误，我们可以采用 mock 隔离，避免干预；\n 2. 开发过程中，只要交互双方定义好接口，团队之间可以并行工作，进程互不影响；\n 3. 依赖系统无法响应，或者响应异常时，可以用 mock Object 代替，快速反应，不会影响测试进度；\n 4. 提前接入测试，提供测试效率，当接口定义好后，测试人员就可以创建 Mock，把接口添加到自动化测试环境，提前开始测试，起到测试驱动开发效果；\n 5. 可以有效的增加覆盖，接口涉及入参，或者业务逻辑复杂的情况，某些场景无法通过正常手段进行操作，可以通过 mock 虚拟模拟；\n\n\n易用性 - Easy of Use#\n\n * 符合标准和规范\n * 直观\n * 一致\n * 灵活\n * 舒适\n * 正确\n * 实用","routePath":"/note/test/","lang":"","toc":[{"text":"测试种类","id":"测试种类","depth":2,"charIndex":3},{"text":"测试工具","id":"测试工具","depth":2,"charIndex":293},{"text":"Client/Server 自动化","id":"clientserver-自动化","depth":3,"charIndex":301},{"text":"功能测试","id":"功能测试","depth":3,"charIndex":358},{"text":"界面测试","id":"界面测试","depth":3,"charIndex":454},{"text":"兼容性","id":"兼容性","depth":3,"charIndex":486},{"text":"性能测试","id":"性能测试","depth":3,"charIndex":569},{"text":"接口测试","id":"接口测试","depth":3,"charIndex":874},{"text":"网络测试","id":"网络测试","depth":3,"charIndex":914},{"text":"web 安全测试","id":"web-安全测试","depth":3,"charIndex":970},{"text":"抓包","id":"抓包","depth":3,"charIndex":1119},{"text":"其他","id":"其他","depth":2,"charIndex":1163},{"text":"提升产品质量","id":"提升产品质量","depth":3,"charIndex":1169},{"text":"Mock 的好处","id":"mock-的好处","depth":3,"charIndex":1233},{"text":"易用性 - Easy of Use","id":"易用性---easy-of-use","depth":3,"charIndex":1528}],"frontmatter":{},"version":""},{"title":"Jest","content":"#\n\n\nInstall#\n\nnpm i --save-dev jest\n# 如果你在代码中使用了新的语法特性，而当前 Node 版本不支持，则需要使用 Babel 进行转义。\nnpm i --save-dev babel-jest @babel/core @babel/preset-env\nnpm i --save-dev identity-obj-proxy\nnpm i --save-dev react-test-renderer\nnpm i --save-dev enzyme enzyme-adapter-react-16 enzyme-to-json\nnpm i --save-dev @testing-library/react\n\n\n\n.babelrc.js#\n\nconst config = {\n  presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n  plugins: [],\n};\nif (process.env.NODE_ENV === \"production\") {\n  config.presets.push([\n    \"minify\",\n    {\n      removeConsole: true,\n    },\n  ]);\n}\nmodule.exports = config;\n\n\n\njest.config.js#\n\nmodule.exports = {\n  testEnvironment: \"node\",\n  transform: {\n    \"^.+\\\\.jsx?$\": \"babel-jest\",\n  },\n  moduleNameMapper: {\n    \"\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$\": \"./mocks/fileMock.js\",\n    \"\\\\.(css|less|styl)$\": \"identity-obj-proxy\",\n  },\n  snapshotSerializers: [\"enzyme-to-json/serializer\"],\n  setupFiles: [\"./setupTest.js\"],\n};\n\n\nVScode - https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest\n\nts-jest - https://github.com/kulshekhar/ts-jest\n\n\nmocks/fileMock.js#\n\nmodule.exports = '';\n\n\n\nsetupTest.js#\n\n\n\nconfigure({ adapter: new Adapter() });\n\n\n\n基本用法#\n\n\ndescribe(\"测试描述\", () => {\n  test(\"dao\", () => {\n    expect(fn(\"dao\")).toEqual(\"daodao\");\n  });\n  test(\"lang\", () => {\n    expect(fn(\"lang\")).toEqual(\"langdao\");\n  });\n});\n\n// 异步\n// .resolves\ntest(\"resolves to lemon\", () => {\n  // make sure to add a return statement\n  return expect(Promise.resolve(\"lemon\")).resolves.toBe(\"lemon\");\n});\n// .rejects\ntest(\"rejects to octopus\", () => {\n  // make sure to add a return statement\n  return expect(Promise.reject(new Error(\"octopus\"))).rejects.toThrow(\"octopus\");\n});\n\n\n\n比较#\n\ntoBe 使用 Object.is 判断是否严格相等。\n\ntoEqual 递归检查对象或数组的每个字段。\n\ntoBeNull 只匹配 null。\n\ntoBeUndefined 只匹配 undefined。\n\ntoBeDefined 只匹配非 undefined。\n\ntoBeTruthy 只匹配真。\n\ntoBeFalsy 只匹配假。\n\ntoBeGreaterThan 实际值大于期望。\n\ntoBeGreaterThanOrEqual 实际值大于或等于期望值\n\ntoBeLessThan 实际值小于期望值。\n\ntoBeLessThanOrEqual 实际值小于或等于期望值。\n\ntoBeCloseTo 比较浮点数的值，避免误差。\n\ntoMatch 正则匹配。\n\ntoContain 判断数组中是否包含指定项。\n\n.toHaveProperty(keyPath, value) 判断对象中是否包含指定属性。\n\ntoThrow 判断是否抛出指定的异常。\n\ntoBeInstanceOf 判断对象是否是某个类的实例，底层使用 instanceof。\n\n\nextends sample#\n\nconst expect = require(\"expect\");\n\nconst toMatchAllText = (props, textList) => {\n  let isMatchText = true;\n  let noMatchtextList = [];\n  for (const text of textList) {\n    try {\n      props.getByText(text);\n    } catch {\n      isMatchText = false;\n      noMatchtextList.push(text);\n    }\n  }\n  if (isMatchText) {\n    return {\n      message: () => \"success\",\n      pass: true,\n    };\n  }\n  return {\n    message: () => `not match some text \"${noMatchtextList.join(\", \")}\"`,\n    pass: false,\n  };\n};\n\nexpect.extend({ toMatchAllText: toMatchAllText });\n\n// expect(props.getByTestId('01').innerHTML).toMatchAllText('헤딩 타이틀');\n","routePath":"/note/test/jest","lang":"","toc":[{"text":"Install","id":"install","depth":3,"charIndex":3},{"text":".babelrc.js","id":"babelrcjs","depth":3,"charIndex":324},{"text":"jest.config.js","id":"jestconfigjs","depth":3,"charIndex":589},{"text":"mocks/fileMock.js","id":"mocksfilemockjs","depth":3,"charIndex":1117},{"text":"setupTest.js","id":"setuptestjs","depth":3,"charIndex":1161},{"text":"基本用法","id":"基本用法","depth":3,"charIndex":1220},{"text":"比较","id":"比较","depth":3,"charIndex":1740},{"text":"extends sample","id":"extends-sample","depth":3,"charIndex":2218}],"frontmatter":{},"version":""},{"title":"React Test Sample","content":"#\n\n\nbasic#\n\n// Button.jsx\n\n\n\nconst Button = ({ text = \"버튼\" }) => {\n  const [isActive, setActive] = useState(false);\n  return (\n    <button\n      type=\"button\"\n      className={isActive ? s.active : \"\"}\n      onClick={() => setActive(!isActive)}\n    >\n      {text}\n    </button>\n  );\n};\n\nexport default Button;\n\n// Button.test.js\n\n\n\n\ndescribe(\"测试组件\", () => {\n  const component = shallow(<Button text=\"확인\" />);\n\n  test(\"default componet\", () => {\n    expect(component).toMatchSnapshot();\n    expect(component.props().className).toEqual(\"\");\n  });\n  test(\"component clicked\", () => {\n    expect(component).toMatchSnapshot();\n    component.find(\"button\").at(0).simulate(\"click\");\n    expect(component.props().className).toEqual(\"active\");\n  });\n});\n\n\n\nredux#\n\n// page1/redux.jsx\nexport const NEXT_COUNT = \"NEXT_COUNT\";\nexport const PREV_COUNT = \"PREV_COUNT\";\n\nexport const setCount = (type) => ({\n  type: type === \"next\" ? NEXT_COUNT : PREV_COUNT,\n});\n\nexport const countReducer = (state = 0, action) => {\n  if (action.type === NEXT_COUNT) {\n    return state + 1;\n  }\n  if (action.type === PREV_COUNT) {\n    return state - 1;\n  }\n  return state;\n};\n\n// page1/redux.test.js\n\n\ndescribe(\"PAGE1 测试redux\", () => {\n  test(\"action creator test\", () => {\n    expect(setCount(\"next\")).toEqual({ type: NEXT_COUNT });\n    expect(setCount(\"prev\")).toEqual({ type: PREV_COUNT });\n  });\n\n  test(\"reducer test\", () => {\n    expect(countReducer(0, { type: NEXT_COUNT })).toEqual(1);\n    expect(countReducer(10, { type: NEXT_COUNT })).toEqual(11);\n    expect(countReducer(-10, { type: NEXT_COUNT })).toEqual(-9);\n\n    expect(countReducer(0, { type: PREV_COUNT })).toEqual(-1);\n    expect(countReducer(10, { type: PREV_COUNT })).toEqual(9);\n    expect(countReducer(-10, { type: PREV_COUNT })).toEqual(-11);\n  });\n});\n","routePath":"/note/test/react","lang":"","toc":[{"text":"basic","id":"basic","depth":3,"charIndex":3},{"text":"redux","id":"redux","depth":3,"charIndex":747}],"frontmatter":{},"version":""},{"title":"测试最佳实践(中文)","content":"#\n\n一段测试代码需要做到让人一眼就能看出其目的。\n\n\n方法#\n\n * 3 个部分(测试什么/什么环境/期望结果)\n * AAA 模式构造内容(Arrange/Act/Assert 准备/执行/断言)\n * 描述期望(Bdd 形式断言) https://jestjs.io/docs/expect#expectextendmatchers\n * TDD\n * UI 与功能分离(AAA)\n * 测试用例标签(npx jest -t=#dao)\n\n\nmock#\n\n * 优先使用真实数据， 特定情况下使用 mock\n * mock 尽量与真实数据同步\n * 工具\n   * sinon\n   * test double\n   * https://www.npmjs.com/package/faker\n\n\ntype#\n\n * 基于属性的测试， 测试输入的多种组合\n\n\nDOM Tip#\n\n * 使用不太容易改变的属性去查询 HTML 元素\n\n\n避免#\n\n * 坚持 public 方法, 减少 private 方法\n * 尽量使用最短的 Snapshot\n * 尽量避免全局的 fixtures 和 seeds(每条测试需要在它自己的 DB 行中运行避免互相污染)\n * 不要 catch 错误而是 expect\n * 不要 sleep，使用框架内置的对 async\n   事件的支持。并且尝试提效。(https://testing-library.com/docs/guide-disappearance/)\n\n\n手动道具#\n\n * lighthouse https://developers.google.com/web/tools/lighthouse/\n * pagespeed https://developers.google.com/speed/pagespeed/insights/\n\n\nE2E (https://github.com/puppeteer/puppeteer)#\n\n * 写几个跨越整个系统的端到端测试\n * 通过复用登录凭证提速 E2E 测试\n * 创建一个 E2E 冒烟测试，仅仅走一遍网站地图\n\n\n测试报告#\n\n * 将测试以实时协作文档的形式公开(Storybook)\n   https://storybook.js.org/addons/@storybook/addon-jest\n * 检查覆盖率报告，以发现未覆盖的区域和其他奇怪的地方(coverage)\n * 使用「变异测试」度量逻辑覆盖率????\n * 使用 Test linter 防止测试代码问题\n\n\nCI 以及其他#\n\n * 丰富你的 linter 并丢弃有 lint 问题的构建\n * 通过本地的开发 CI 来缩短反馈循环(husky)\n * 在真实的生产环境镜像中执行端到端测试\n * 并行测试工作\n * 使用许可证和抄袭检查避免法务问题 (https://www.npmjs.com/package/license-checker)\n * 持续检查有漏洞的依赖\n * 自动升级依赖????\n * 使用多个 Node 版本执行同一个 CI 流程(质量检查是用于发现意外，你覆盖的部分越多，你就越可能尽早地发现问题。 在开发包或运行具有各种配置和\n   Node 版本的多客户生产环境时，CI 必须在所有配置的组合上运行测试管道。)","routePath":"/note/test/test","lang":"","toc":[{"text":"方法","id":"方法","depth":2,"charIndex":27},{"text":"mock","id":"mock","depth":2,"charIndex":223},{"text":"type","id":"type","depth":2,"charIndex":351},{"text":"DOM Tip","id":"dom-tip","depth":2,"charIndex":382},{"text":"避免","id":"避免","depth":2,"charIndex":420},{"text":"手动道具","id":"手动道具","depth":2,"charIndex":656},{"text":"E2E (https://github.com/puppeteer/puppeteer)","id":"e2e-httpsgithubcompuppeteerpuppeteer","depth":2,"charIndex":800},{"text":"测试报告","id":"测试报告","depth":2,"charIndex":916},{"text":"CI 以及其他","id":"ci-以及其他","depth":2,"charIndex":1101}],"frontmatter":{},"version":""},{"title":"테스트 베스트 프래틱스","content":"#\n\n한구간 테스트 코드로 한눈에 목적을 이해할수 있게 해야한다.\n\n\n방법#\n\n * 3개부분(무엇을 테스트 할것인가?/어떤 환경에서 진행되는가?/기대하는 결과는?)\n * AAA구조로 내용 구성(Arrange/Act/Assert 준비/실행/주장)\n * except 요약하기 (Bdd 형식의 expect)\n   https://jestjs.io/docs/expect#expectextendmatchers\n * TDD\n * UI와 기능 분리(AAA)\n * 테스트 케이스 태그(npx jest -t=#dao)\n\n\nmock#\n\n * 우선 real데이터를 사용, 특정경우에만 mock사용\n * mock데이터는 real데이터와 일치\n * 도구\n   * sinon\n   * test double\n   * https://www.npmjs.com/package/faker\n\n\ntype#\n\n * 속성 기반 테스트, 여러조합 입력\n\n\nDOM Tip#\n\n * static한 속성을 활용해서 HTML 요소에 접근\n\n\n주의사항#\n\n * public fn에 대해서만 테스트 하고 private fn은 최소한 으로 진행\n * Snapshot 요소는 작을수록 좋음.\n * 전역에 사용되는 fixtures와seeds는 피하자(매개 테스트는 독립적인 환경에서 실행)\n * 에러를 expect 권장, catch금지\n * no sleep, 프레임워크내 async\n   적극활용,(https://testing-library.com/docs/guide-disappearance/)\n\n\n수동도구#\n\n * lighthouse https://developers.google.com/web/tools/lighthouse/\n * pagespeed https://developers.google.com/speed/pagespeed/insights/\n\n\nE2E (https://github.com/puppeteer/puppeteer)#\n\n * 몇개 크로스시스템 테스트 케이스 작성.\n * 로그인 token을 중복 활용해서 E2E 진행\n * E2E Smoke Test를 통해서 사이트맵 한번씩 접근.\n\n\n테스트 보고서#\n\n * 테스트 결과를 실시간으로 확인할수 있는 시스템 구축(Storybook)\n   https://storybook.js.org/addons/@storybook/addon-jest\n * Coverage 결과를 기준으로 미확인 부분 및 이상한 부분 찾기\n * 使用「变异测试」度量逻辑覆盖率???? 4.3\n * test코드도 lint를 통해서 코드 품질 향상.","routePath":"/note/test/test_kr","lang":"","toc":[{"text":"방법","id":"방법","depth":2,"charIndex":38},{"text":"mock","id":"mock","depth":2,"charIndex":281},{"text":"type","id":"type","depth":2,"charIndex":422},{"text":"DOM Tip","id":"dom-tip","depth":2,"charIndex":453},{"text":"주의사항","id":"주의사항","depth":2,"charIndex":497},{"text":"수동도구","id":"수동도구","depth":2,"charIndex":749},{"text":"E2E (https://github.com/puppeteer/puppeteer)","id":"e2e-httpsgithubcompuppeteerpuppeteer","depth":2,"charIndex":893},{"text":"테스트 보고서","id":"테스트-보고서","depth":2,"charIndex":1032}],"frontmatter":{},"version":""},{"title":"vitest","content":"#\n\nvite.config.js#\n\n\n\n\n\nexport default defineConfig({\n  root: \"./src\",\n  build: {\n    outDir: \"../dist\",\n    emptyOutDir: true,\n  },\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: \"jsdom\",\n    setupFiles: \"./test/setup.ts\",\n    css: true,\n  },\n});\n\n\n\npackage.json#\n\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  },\n  \"devDependencies\": {\n    \"@testing-library/react\": \"^13.3.0\",\n    \"@vitejs/plugin-react\": \"^1.1.4\",\n    \"jsdom\": \"^20.0.0\",\n    \"vite\": \"^2.7.13\",\n    \"vitest\": \"^0.22.1\"\n  }\n}\n\n\n\nsrc/test/setup.ts#\n\n\n\nconst toMatchAllText = (props, textList) => {\n  let isMatchText = true;\n  let noMatchtextList = [];\n\n  for (const text of textList) {\n    if (!props.innerHTML.includes(text)) {\n      isMatchText = false;\n      noMatchtextList.push(text);\n    }\n  }\n  if (isMatchText) {\n    return {\n      message: () => \"success\",\n      pass: true,\n    };\n  }\n  return {\n    message: () => `not match some text \"${noMatchtextList.join(\", \")}\"`,\n    pass: false,\n  };\n};\n\nexpect.extend({ toMatchAllText });\n","routePath":"/note/test/vitest","lang":"","toc":[{"text":"vite.config.js","id":"viteconfigjs","depth":4,"charIndex":2},{"text":"package.json","id":"packagejson","depth":3,"charIndex":354},{"text":"src/test/setup.ts","id":"srctestsetupts","depth":3,"charIndex":635}],"frontmatter":{},"version":""},{"title":"Git","content":"#\n\n\nrevert#\n\ngit revert OLDER_COMMIT^..NEWER_COMMIT\ngit revert -n xxx^..yyy -m 1\n\ngit revert --quit\n\n\n\n커밋 취소#\n\ngit reset --soft HEAD^\n\n\n\n대소문자 이슈#\n\ngit config core.ignorecase false\n\n\n\n커밋 날짜 변경#\n\n# 최근 커밋을 어제의 현재 시간으로 변경하기\ngit commit --amend --date \"1 day ago\" -m \"커밋 메시지\"\n\n\n\nconmit rule#\n\nhttps://github.com/conventional-changelog/conventional-changelog/tree/master/pac\nkages\n\n * angular\n * atom\n * codemirror\n * ember\n * eslint\n * express\n * jquery\n * jshint\n * conventionalcommits","routePath":"/tools/git","lang":"","toc":[{"text":"revert","id":"revert","depth":3,"charIndex":3},{"text":"커밋 취소","id":"커밋-취소","depth":3,"charIndex":102},{"text":"대소문자 이슈","id":"대소문자-이슈","depth":3,"charIndex":136},{"text":"커밋 날짜 변경","id":"커밋-날짜-변경","depth":3,"charIndex":182},{"text":"conmit rule","id":"conmit-rule","depth":3,"charIndex":272}],"frontmatter":{},"version":""},{"title":"Npm","content":"#\n\n\ninstall 팁#\n\ninstall 시 https://registry.npmjs.org/jnpkg 여기서 다운로드\n\n\n동일패키지 여러 버전 공존#\n\nnpm install --save lodash-v1@npm:lodash@1.0.0\n\n\n\n\n\n\n기본설치된 package 리스트#\n\nnpm list --depth=0\nnpm list --depth=0 -global\n\n\n\n배포된 패키지 제거하기#\n\nnpm unpublish dzmtest@1.0.1 --force # 특정 버정만 제거\nnpm unpublish dzmtest --force # 패지지 제거\nnpm unpublish --force # package.json에 지정된 패키지 제거\n\n\n\npnpm 명령어#\n\n카테고리     명령어                                  설명\n기본       pnpm --version                       버전 확인\n         pnpm init                            프로젝트 초기화\n설치       pnpm install (pnpm i)                의존성 설치\n         pnpm add <패키지>                       패키지 설치\n         pnpm add <패키지> -D                    개발 의존성 설치\n         pnpm add <패키지> -g                    전역 설치\n         pnpm update                          의존성 업데이트\n제거       pnpm remove <패키지>                    패키지 삭제\n실행       pnpm run <script>                    스크립트 실행\n         pnpm exec <명령어>                      로컬 바이너리 실행\n관리       pnpm list (pnpm ls)                  패키지 목록\n         pnpm outdated                        업데이트 확인\n         pnpm prune                           불필요한 패키지 제거\n         pnpm audit                           보안 점검\n         pnpm why <패키지>                       설치 이유 확인\n워크스페이스   pnpm init -w                         워크스페이스 초기화\n         pnpm add <패키지> -w                    전체 워크스페이스에 추가\n         pnpm recursive install (pnpm i -r)   모든 워크스페이스 설치\n         pnpm recursive run <script>          모든 워크스페이스 스크립트 실행\n전역       pnpm add -g <패키지>                    전역 설치\n         pnpm remove -g <패키지>                 전역 제거\n         pnpm list -g                         전역 패키지 목록\n캐시/설정    pnpm store path                      캐시 저장소 경로\n         pnpm store prune                     캐시 정리\n         pnpm config get <key>                설정 값 확인\n         pnpm config set <key> <value>        설정 값 변경\n\n\nyarn 명령어#\n\n카테고리     명령어                        설명\n기본       yarn --version             버전 확인\n         yarn init                  새 프로젝트 초기화\n         yarn init -y               기본 설정으로 초기화\n설치       yarn install (yarn)        의존성 설치\n         yarn add <패키지>             패키지 설치\n         yarn add <패키지> --dev       개발 의존성 설치\n         yarn global add <패키지>      전역 설치\n         yarn upgrade               의존성 업데이트\n제거       yarn remove <패키지>          패키지 삭제\n실행       yarn run <script>          스크립트 실행\n         yarn <script> (단축)         run 생략 가능\n관리       yarn list                  설치된 패키지 목록\n         yarn outdated              업데이트 가능 패키지 확인\n         yarn cache clean           캐시 삭제\n         yarn why <패키지>             특정 패키지 설치 이유 확인\n워크스페이스   yarn workspaces info       워크스페이스 정보 출력\n         yarn workspace <이름> <명령>   특정 워크스페이스에서 명령 실행\n전역       yarn global add <패키지>      전역 설치\n         yarn global remove <패키지>   전역 제거\n         yarn global list           전역 패키지 목록","routePath":"/tools/npm","lang":"","toc":[{"text":"install 팁","id":"install-팁","depth":3,"charIndex":3},{"text":"동일패키지 여러 버전 공존","id":"동일패키지-여러-버전-공존","depth":3,"charIndex":69},{"text":"기본설치된 package 리스트","id":"기본설치된-package-리스트","depth":3,"charIndex":138},{"text":"배포된 패키지 제거하기","id":"배포된-패키지-제거하기","depth":3,"charIndex":207},{"text":"pnpm 명령어","id":"pnpm-명령어","depth":3,"charIndex":361},{"text":"yarn 명령어","id":"yarn-명령어","depth":3,"charIndex":1851}],"frontmatter":{},"version":""},{"title":"babel","content":"#\n\nsample code#\n\nexport default `function square(n) {\n  return n * n;\n}`;\n\n\n\nparser#\n\nbabel-parser(旧 Babylon) 是 Babel 的解析器。最初是 从 Acorn 项目 fork 出来的。Acorn\n非常快，易于使用，并且针对非标准特性(以及那些未来的标准特性) 设计了一个基于插件的架构。\n\n\n\n\nconst ast = parse(code);\nconsole.log(JSON.stringify(ast, null, 2));\n\n\n\ntraverse#\n\nBabel Traverse（遍历）模块维护了整棵树的状态，并且负责替换、移除和添加节点。\n\n\n\n\n\nconst ast = parse(code);\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type === \"Identifier\" && path.node.name === \"n\") {\n      path.node.name = \"x\";\n    }\n  },\n});\n\nconsole.log(JSON.stringify(ast, null, 2));\n\n\n\ntypes#\n\nBabel Types 模块是一个用于 AST 节点的 Lodash 式工具库（译注：Lodash 是一个 JavaScript\n函数工具库，提供了基于函数式编程风格的众多工具函数）， 它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理 AST\n逻辑非常有用。\n\n\n\n\n\n\nconst ast = parse(code);\ntraverse(ast, {\n  enter(path) {\n    if (t.isIdentifier(path.node, { name: \"n\" })) {\n      path.node.name = \"x\";\n    }\n  },\n});\nconsole.log(JSON.stringify(ast, null, 2));\n\n\n\ngenerator#\n\nBabel Traverse（遍历）模块维护了整棵树的状态，并且负责替换、移除和添加节点。\n\n\n\n\n\n\n\nconst ast = parse(code);\ntraverse(ast, {\n  enter(path) {\n    if (t.isIdentifier(path.node, { name: \"n\" })) {\n      path.node.name = \"x\";\n    }\n  },\n});\nconsole.log(generate(ast).code);\n\n\n\ntemplate#\n\n它能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST 的时候。 在计算机科学中，这种能力被称为准引用（quasiquotes）。\n\n\n\n\n\nconst buildRequire = template(`\n  var IMPORT_NAME = require(SOURCE);\n`);\nconst ast = buildRequire({\n  IMPORT_NAME: t.identifier(\"myModule\"),\n  SOURCE: t.stringLiteral(\"my-module\"),\n});\nconsole.log(generate(ast).code);\n\n\n\ntypes-vistor#\n\n// types\nconst EXPRESSION_TYPES = [];\nconst BINARY_TYPES = [];\nconst SCOPABLE_TYPES = [];\nconst BLOCKPARENT_TYPES = [];\nconst BLOCK_TYPES = [];\nconst STATEMENT_TYPES = [];\nconst TERMINATORLESS_TYPES = [];\nconst COMPLETIONSTATEMENT_TYPES = [];\nconst CONDITIONAL_TYPES = [];\nconst LOOP_TYPES = [];\nconst WHILE_TYPES = [];\nconst EXPRESSIONWRAPPER_TYPES = [];\nconst FOR_TYPES = [];\nconst FORXSTATEMENT_TYPES = [];\nconst FUNCTION_TYPES = [];\nconst FUNCTIONPARENT_TYPES = [];\nconst PUREISH_TYPES = [];\nconst DECLARATION_TYPES = [];\nconst PATTERNLIKE_TYPES = [];\nconst LVAL_TYPES = [];\nconst TSENTITYNAME_TYPES = [];\nconst LITERAL_TYPES = [];\nconst IMMUTABLE_TYPES = [];\nconst USERWHITESPACABLE_TYPES = [];\nconst METHOD_TYPES = [];\nconst OBJECTMEMBER_TYPES = [];\nconst PROPERTY_TYPES = [];\nconst UNARYLIKE_TYPES = [];\nconst PATTERN_TYPES = [];\nconst CLASS_TYPES = [];\nconst MODULEDECLARATION_TYPES = [];\nconst EXPORTDECLARATION_TYPES = [];\nconst MODULESPECIFIER_TYPES = [];\nconst PRIVATE_TYPES = [];\nconst FLOW_TYPES = [];\nconst FLOWTYPE_TYPES = [];\nconst FLOWBASEANNOTATION_TYPES = [];\nconst FLOWDECLARATION_TYPES = [];\nconst FLOWPREDICATE_TYPES = [];\nconst ENUMBODY_TYPES = [];\nconst ENUMMEMBER_TYPES = [];\nconst JSX_TYPES = [];\nconst TSTYPEELEMENT_TYPES = [];\nconst TSTYPE_TYPES = [];\nconst TSBASETYPE_TYPES = [];\n\n// operator\nconst LOGICAL_OPERATORS = [];\nconst UPDATE_OPERATORS = [];\nconst BOOLEAN_NUMBER_BINARY_OPERATORS = [];\nconst EQUALITY_BINARY_OPERATORS = [];\nconst COMPARISON_BINARY_OPERATORS = [];\nconst BOOLEAN_BINARY_OPERATORS = [];\nconst NUMBER_BINARY_OPERATORS = [];\nconst BINARY_OPERATORS = [];\nconst ASSIGNMENT_OPERATORS = [];\nconst BOOLEAN_UNARY_OPERATORS = [];\nconst NUMBER_UNARY_OPERATORS = [];\nconst STRING_UNARY_OPERATORS = [];\nconst UNARY_OPERATORS = [];\n","routePath":"/tools/plugins/babel","lang":"","toc":[{"text":"sample code","id":"sample-code","depth":4,"charIndex":2},{"text":"parser","id":"parser","depth":3,"charIndex":76},{"text":"traverse","id":"traverse","depth":3,"charIndex":273},{"text":"types","id":"types","depth":3,"charIndex":551},{"text":"generator","id":"generator","depth":3,"charIndex":915},{"text":"template","id":"template","depth":3,"charIndex":1168},{"text":"types-vistor","id":"types-vistor","depth":3,"charIndex":1486}],"frontmatter":{},"version":""},{"title":"eslint","content":"#\n\n 1. code\n 2. parser(esprima, @babel/eslint-parser, @typescript-eslint/parser)\n 3. AST\n 4. plugin(report or fix)\n\n\nbuild option#\n\n// build.js\nrequire(\"esbuild\")\n  .build({\n    entryPoints: [\"./src/index.js\"],\n    bundle: true,\n    minify: true,\n    platform: \"node\",\n    outfile: \"./lib/index.js\",\n    watch: true,\n  })\n  .then(() => console.log(\"빌드완료\"))\n  .catch(() => process.exit(1));\n\n\n// ./src/index.js\n// module.exports = {\n//   rules: {......},\n//   configs: {......},\n// }\n\n\nexport const rules = {\n  \"max-params\": maxParams,\n};\n\nexport const configs = {\n  recommended: {\n    plugins: [\"jl\"],\n    rules: {\n      \"jl/max-params\": [\"warn\", { max: 3 }],\n    },\n  },\n};\n\n// ./src/rules/max-params.js\n// https://astexplorer.net/\nexport default {\n  meta: {\n    docs: {\n      description: \"enforce a maximum number of parameters in function definitions\",\n      category: \"Stylistic Issues\", // https://cn.eslint.org/docs/rules/\n      recommended: false,\n    },\n  },\n  create: (context) => {\n    // https://eslint.org/docs/developer-guide/working-with-rules#the-context-object\n    // context: {\n    //   report,\n    //   id, // jl/max-params\n    //   options, // [{max: 3}, ......]\n    //   ......\n    // }\n    const fn = (node) => {\n      if (node.params.length > 3) {\n        // https://eslint.org/docs/developer-guide/working-with-rules\n        context.report({\n          node,\n          message: \"파라미터는 3개 이상 초과 할수 없습니다.\" + context.options[0].max,\n        });\n      }\n    };\n    // https://esprima.readthedocs.io/en/latest/syntax-tree-format.html#expressions-and-patterns\n    return {\n      FunctionDeclaration: fn,\n      ArrowFunctionExpression: fn,\n      FunctionExpression: fn,\n    };\n  },\n};\n\n\n\nuse plugin#\n\n// .eslintrc.json\n{\n  \"plugins\": [\n    \"jl\"\n  ],\n  \"extends\": [\n    \"plugin:jl/recommended\"\n  ],\n  \"rules\": {\n    \"jl/max-params\": \"off\", // off, warn, error, 0, 1,2\n    \"jl/max-params\": [\"warn\", {\"max\": 3}],\n  }\n}\n","routePath":"/tools/plugins/eslint","lang":"","toc":[{"text":"build option","id":"build-option","depth":3,"charIndex":116},{"text":"use plugin","id":"use-plugin","depth":3,"charIndex":1703}],"frontmatter":{},"version":""},{"title":"swc","content":"#\n\n\nVisitor#\n\n// https://swc.rs/docs/usage/core\n\n// https://github.com/swc-project/swc/blob/main/node-swc/src/Visitor.ts\n\n\ninterface ITransformResult {\n  code: string;\n  map?: string;\n}\nclass PluginName extends Visitor {\n  // run visitor\n  visitCallExpression(n: CallExpression) {\n    // any work\n    return super.visitCallExpression(n);\n  }\n}\n\nnew PluginName().visitProgram(program);\n\nconst transform = (src, id) => {\n  // default 값 지정 필요.\n  let result: ITransformResult = { code: src };\n\n  // 코드 변환\n  result = transformSync(src, {\n    plugin,\n    sourceMaps: true,\n    jsc: {\n      parser: {\n        syntax: \"ecmascript\",\n        jsx: true,\n      },\n    },\n  });\n  return result;\n};\n","routePath":"/tools/plugins/swc","lang":"","toc":[{"text":"Visitor","id":"visitor","depth":3,"charIndex":3}],"frontmatter":{},"version":""},{"title":"","content":"https://github.com/microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin","routePath":"/tools/plugins/typescript","lang":"","toc":[],"frontmatter":{},"version":""},{"title":"vite","content":"#\n\n\nsample code#\n\nexport default function myPlugin() {\n  return {\n    name: \"my-plugin\", // 插件名称\n    enforce: \"pre\", //调整插件被执行顺序\n    apply: \"build | serve\", // 指定插件应用情景\n    options(options) {},\n    buildStart(options) {},\n    resolveId(id) {},\n    load(id) {},\n    transform(src, id) {},\n    buildEnd(error) {},\n    closeBundle() {},\n    config(config, env) {},\n    configResolved(config) {},\n    configureServer(server) {},\n    transformIndexHtml(html, ctx) {},\n    handleHotUpdate(ctx) {},\n  };\n}\n","routePath":"/tools/plugins/vite","lang":"","toc":[{"text":"sample code","id":"sample-code","depth":3,"charIndex":3}],"frontmatter":{},"version":""}]